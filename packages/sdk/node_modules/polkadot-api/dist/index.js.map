{"version":3,"file":"index.js","sources":["../src/compatibility.ts","../src/constants.ts","../src/utils/shareLatest.ts","../src/utils/firstValueFromWithSignal.ts","../src/utils/lossLessExhaustMap.ts","../src/utils/continue-with.ts","../src/utils/optional-arg.ts","../src/utils/self-dependent.ts","../src/event.ts","../src/runtime-call.ts","../src/storage.ts","../src/tx/signed-extensions/system-version.ts","../src/tx/signed-extensions/mortal-enc.ts","../src/tx/signed-extensions/charge-asset-tx-enc.ts","../src/tx/signed-extensions/sign-extensions.ts","../src/tx/create-tx.ts","../src/tx/submit-fns.ts","../src/tx/tx.ts","../src/watch-entries.ts","../src/viewFns.ts","../src/client.ts","../src/offline.ts","../src/typed-codecs/typed-codecs.ts"],"sourcesContent":["import { MetadataLookup } from \"@polkadot-api/metadata-builders\"\nimport {\n  CompatibilityCache,\n  CompatibilityLevel,\n  EntryPoint,\n  EntryPointCodec,\n  TypedefCodec,\n  TypedefNode,\n  entryPointsAreCompatible,\n  mapLookupToTypedef,\n  valueIsCompatibleWithDest,\n} from \"@polkadot-api/metadata-compatibility\"\nimport { ChainHead$, RuntimeContext } from \"@polkadot-api/observable-client\"\nimport { Tuple, Vector } from \"@polkadot-api/substrate-bindings\"\nimport { Observable, combineLatest, filter, firstValueFrom, map } from \"rxjs\"\nimport { ChainDefinition } from \"./descriptors\"\n\nexport class RuntimeToken<D = unknown> {\n  private constructor() {}\n\n  // @ts-ignore\n  protected _runtime(value: D) {}\n}\n\nexport class CompatibilityToken<D = unknown> {\n  private constructor() {}\n\n  // @ts-ignore\n  protected _compatibility(value: D) {}\n}\n\ninterface RuntimeTokenApi {\n  runtime: () => RuntimeContext\n}\ninterface CompatibilityTokenApi extends RuntimeTokenApi {\n  typedefNodes: TypedefNode[]\n  getEntryPoint: (opType: OpType, pallet: string, name: string) => EntryPoint\n}\nconst compatibilityTokenApi = new WeakMap<\n  CompatibilityToken,\n  CompatibilityTokenApi\n>()\nconst runtimeTokenApi = new WeakMap<RuntimeToken, RuntimeTokenApi>()\nexport const getCompatibilityApi = (\n  token: RuntimeToken | CompatibilityToken,\n): RuntimeTokenApi | CompatibilityTokenApi =>\n  token instanceof RuntimeToken\n    ? runtimeTokenApi.get(token)!\n    : compatibilityTokenApi.get(token)!\n\nexport const enum OpType {\n  Storage = \"storage\",\n  Tx = \"tx\",\n  Event = \"events\",\n  Const = \"constants\",\n  ViewFns = \"viewFns\",\n  Api = \"apis\",\n}\n\nconst EntryPointsCodec = Vector(EntryPointCodec)\nconst TypedefsCodec = Vector(TypedefCodec)\nconst TypesCodec = Tuple(EntryPointsCodec, TypedefsCodec)\n\nexport const createCompatibilityToken = <D extends ChainDefinition>(\n  chainDefinition: D,\n  chainHead: ChainHead$,\n): Promise<CompatibilityToken<D>> => {\n  const awaitedRuntime = new Promise<() => RuntimeContext>(async (resolve) => {\n    const loadedRuntime$ = chainHead.runtime$.pipe(filter((v) => v != null))\n\n    let latest = await firstValueFrom(loadedRuntime$)\n    loadedRuntime$.subscribe((v) => (latest = v))\n\n    resolve(() => latest)\n  })\n\n  const promise = Promise.all([\n    chainDefinition.metadataTypes.then(TypesCodec.dec),\n    chainDefinition.descriptors,\n    awaitedRuntime,\n  ]).then(([[entryPoints, typedefNodes], descriptors, runtime]) => {\n    const token = new (CompatibilityToken as any)()\n    compatibilityTokenApi.set(token, {\n      runtime,\n      getEntryPoint(opType, pallet, name) {\n        const idx = descriptors[opType]?.[pallet]?.[name]\n        if (idx == null)\n          throw new Error(\n            `Descriptor for ${opType} ${pallet}.${name} does not exist`,\n          )\n        return entryPoints[idx]\n      },\n      typedefNodes,\n    })\n\n    return token\n  })\n\n  return promise\n}\n\nexport const createRuntimeToken = <D>(\n  chainHead: ChainHead$,\n): Promise<RuntimeToken<D>> => {\n  const awaitedRuntime = new Promise<() => RuntimeContext>(async (resolve) => {\n    const loadedRuntime$ = chainHead.runtime$.pipe(filter((v) => v != null))\n\n    let latest = await firstValueFrom(loadedRuntime$)\n    loadedRuntime$.subscribe((v) => (latest = v))\n\n    resolve(() => latest)\n  })\n\n  const promise = awaitedRuntime.then((runtime) => {\n    const token = new (RuntimeToken as any)()\n    runtimeTokenApi.set(token, {\n      runtime,\n    })\n    return token\n  })\n\n  return promise\n}\n\n// metadataRaw -> cache\nconst metadataCache = new WeakMap<\n  Uint8Array,\n  {\n    compat: CompatibilityCache\n    lookup: MetadataLookup\n    typeNodes: (TypedefNode | null)[]\n  }\n>()\nconst getMetadataCache = (ctx: RuntimeContext) => {\n  if (!metadataCache.has(ctx.metadataRaw)) {\n    metadataCache.set(ctx.metadataRaw, {\n      compat: new Map(),\n      lookup: ctx.lookup,\n      typeNodes: [],\n    })\n  }\n  return metadataCache.get(ctx.metadataRaw)!\n}\nexport const compatibilityHelper = (\n  descriptors: Promise<RuntimeToken | CompatibilityToken>,\n  getDescriptorEntryPoint: (descriptorApi: CompatibilityTokenApi) => EntryPoint,\n  getRuntimeEntryPoint: (ctx: RuntimeContext) => EntryPoint | null,\n) => {\n  const getRuntimeTypedef = (ctx: RuntimeContext, id: number) => {\n    const cache = getMetadataCache(ctx)\n    return (cache.typeNodes[id] ||= mapLookupToTypedef(cache.lookup(id)))\n  }\n\n  function getCompatibilityLevels(\n    descriptors: CompatibilityToken | RuntimeToken,\n    /**\n     * The `Runtime` of runtimeWithDescriptors already has a RuntimeContext,\n     * which is the runtime of the finalized block.\n     * But on some cases, the user wants to perform an action on a specific\n     * block hash, which has a different RuntimeContext.\n     */\n    ctx?: RuntimeContext,\n  ) {\n    if (descriptors instanceof RuntimeToken) {\n      return {\n        args: CompatibilityLevel.Identical,\n        values: CompatibilityLevel.Identical,\n      }\n    }\n    const compatibilityApi = compatibilityTokenApi.get(descriptors)!\n    ctx ||= compatibilityApi.runtime()\n    const runtimeEntryPoint = getRuntimeEntryPoint(ctx)\n    if (runtimeEntryPoint == null)\n      return {\n        args: CompatibilityLevel.Incompatible,\n        values: CompatibilityLevel.Incompatible,\n      }\n    const descriptorNodes = compatibilityApi.typedefNodes\n\n    const cache = getMetadataCache(ctx)\n\n    const descriptorEntryPoint = getDescriptorEntryPoint(compatibilityApi)\n    const result = entryPointsAreCompatible(\n      descriptorEntryPoint,\n      (id) => descriptorNodes[id],\n      runtimeEntryPoint,\n      (id) => getRuntimeTypedef(ctx, id),\n      cache.compat,\n    )\n    return {\n      args: result.args.level,\n      values: result.values.level,\n    }\n  }\n\n  const getCompatibilityLevel = withOptionalToken(descriptors, (runtime) =>\n    minCompatLevel(getCompatibilityLevels(runtime)),\n  )\n  const isCompatible = withOptionalToken(\n    descriptors,\n    (threshold: CompatibilityLevel, runtime) =>\n      getCompatibilityLevel(runtime) >= threshold,\n  )\n\n  const compatibleRuntime$ = (chainHead: ChainHead$, hash: string | null) =>\n    combineLatest([descriptors, chainHead.getRuntimeContext$(hash)])\n\n  const withCompatibleRuntime =\n    <T>(chainHead: ChainHead$, mapper: (x: T) => string) =>\n    (\n      source$: Observable<T>,\n    ): Observable<[T, CompatibilityToken | RuntimeToken, RuntimeContext]> =>\n      combineLatest([\n        source$.pipe(chainHead.withRuntime(mapper)),\n        descriptors,\n      ]).pipe(map(([[x, ctx], descriptors]) => [x, descriptors, ctx]))\n\n  const argsAreCompatible = (\n    descriptors: CompatibilityToken | RuntimeToken,\n    ctx: RuntimeContext,\n    args: unknown,\n  ) => {\n    if (descriptors instanceof RuntimeToken) return true\n    const levels = getCompatibilityLevels(descriptors, ctx)\n    if (levels.args === CompatibilityLevel.Incompatible) return false\n    if (levels.args > CompatibilityLevel.Partial) return true\n    // Although technically args could still be compatible, if the output will be incompatible we might as well just return false to skip sending the request.\n    if (levels.values === CompatibilityLevel.Incompatible) return false\n\n    const entryPoint = getRuntimeEntryPoint(ctx)\n    if (entryPoint == null) return false\n\n    return valueIsCompatibleWithDest(\n      entryPoint.args,\n      (id) => getRuntimeTypedef(ctx, id),\n      args,\n    )\n  }\n  const valuesAreCompatible = (\n    descriptors: CompatibilityToken | RuntimeToken,\n    ctx: RuntimeContext,\n    values: unknown,\n  ) => {\n    if (descriptors instanceof RuntimeToken) return true\n    const level = getCompatibilityLevels(descriptors, ctx).values\n    if (level === CompatibilityLevel.Incompatible) return false\n    if (level > CompatibilityLevel.Partial) return true\n\n    const compatibilityApi = compatibilityTokenApi.get(descriptors)!\n\n    const entryPoint = getDescriptorEntryPoint(compatibilityApi)\n\n    return valueIsCompatibleWithDest(\n      entryPoint.values,\n      (id) => compatibilityApi.typedefNodes[id],\n      values,\n    )\n  }\n\n  return {\n    isCompatible,\n    getCompatibilityLevel,\n    getCompatibilityLevels,\n    descriptors,\n    withCompatibleRuntime,\n    compatibleRuntime$,\n    argsAreCompatible,\n    valuesAreCompatible,\n    getRuntimeTypedef,\n  }\n}\nexport type CompatibilityHelper = ReturnType<typeof compatibilityHelper>\n\nexport const minCompatLevel = (levels: {\n  args: CompatibilityLevel\n  values: CompatibilityLevel\n}) => Math.min(levels.args, levels.values)\n\nconst withOptionalToken =\n  <T, D, A extends [...any[], CompatibilityToken | RuntimeToken]>(\n    compatibilityToken: Promise<CompatibilityToken<D> | RuntimeToken<D>>,\n    fn: (...args: A) => T,\n  ): WithOptionalRuntime<T, D, A extends [...infer R, any] ? R : []> =>\n  (...args: any): any => {\n    const lastElement = args.at(-1)\n    if (\n      lastElement instanceof CompatibilityToken ||\n      lastElement instanceof RuntimeToken\n    ) {\n      return fn(...args)\n    }\n    return compatibilityToken.then((token) => (fn as any)(...args, token))\n  }\n\nexport type WithOptionalRuntime<T, D, A extends any[]> = {\n  /**\n   * Returns the result after waiting for the runtime to load.\n   */\n  (...args: A): Promise<T>\n  /**\n   * Returns the result synchronously with the loaded runtime.\n   */\n  (...args: [...A, runtime: CompatibilityToken<D> | RuntimeToken<D>]): T\n}\n\nexport interface CompatibilityFunctions<D> {\n  /**\n   * Returns the `CompatibilityLevel` for this call comparing the descriptors\n   * generated on dev time with the current live metadata.\n   */\n  getCompatibilityLevel(): Promise<CompatibilityLevel>\n  /**\n   * Returns the `CompatibilityLevel` for this call comparing the descriptors\n   * generated on dev time with the current live metadata.\n   *\n   * @param compatibilityToken  CompatibilityToken awaited from\n   *                            typedApi.compatibilityToken.\n   */\n  getCompatibilityLevel(\n    compatibilityToken: CompatibilityToken<D>,\n  ): CompatibilityLevel\n\n  /**\n   * Returns whether this call is compatible based on the CompatibilityLevel\n   * threshold.\n   *\n   * @param threshold  CompatibilityLevel threshold to use, inclusive.\n   */\n  isCompatible(threshold: CompatibilityLevel): Promise<boolean>\n\n  /**\n   * Returns whether this call is compatible based on the CompatibilityLevel\n   * threshold.\n   *\n   * @param threshold           CompatibilityLevel threshold to use,\n   *                            inclusive.\n   * @param compatibilityToken  CompatibilityToken awaited from\n   *                            typedApi.compatibilityToken.\n   */\n  isCompatible(\n    threshold: CompatibilityLevel,\n    compatibilityToken: CompatibilityToken<D>,\n  ): boolean\n}\n","import { RuntimeContext } from \"@polkadot-api/observable-client\"\nimport {\n  CompatibilityFunctions,\n  CompatibilityHelper,\n  CompatibilityToken,\n  getCompatibilityApi,\n  RuntimeToken,\n} from \"./compatibility\"\n\nexport type ConstantEntry<Unsafe, D, T> = Unsafe extends true\n  ? {\n      /**\n       * Constants are simple key-value structures found in the runtime\n       * metadata.\n       *\n       * @returns Promise that will resolve in the value of the constant.\n       */\n      (): Promise<T>\n      /**\n       * @param runtimeToken  Token from got with `await\n       *                      typedApi.runtimeToken`\n       * @returns Synchronously returns value of the constant.\n       */\n      (runtimeToken: RuntimeToken): T\n    }\n  : {\n      /**\n       * Constants are simple key-value structures found in the runtime\n       * metadata.\n       *\n       * @returns Promise that will resolve in the value of the constant.\n       */\n      (): Promise<T>\n      /**\n       * @param compatibilityToken  Token from got with `await\n       *                            typedApi.compatibilityToken`\n       * @returns Synchronously returns value of the constant.\n       */\n      (compatibilityToken: CompatibilityToken): T\n    } & CompatibilityFunctions<D>\n\nexport const createConstantEntry = <D, T>(\n  palletName: string,\n  name: string,\n  {\n    valuesAreCompatible,\n    descriptors,\n    isCompatible,\n    getCompatibilityLevel,\n  }: CompatibilityHelper,\n): ConstantEntry<any, D, T> => {\n  const cachedResults = new WeakMap<RuntimeContext, T>()\n  const getValueWithContext = (ctx: RuntimeContext) => {\n    if (cachedResults.has(ctx)) {\n      return cachedResults.get(ctx)!\n    }\n\n    const pallet = ctx.lookup.metadata.pallets.find(\n      (p) => p.name === palletName,\n    )\n    const constant = pallet?.constants.find((c) => c.name === name)\n    if (constant == null)\n      throw new Error(`Runtime entry Constant(${palletName}.${name}) not found`)\n    const result = ctx.dynamicBuilder\n      .buildConstant(palletName, name)\n      .dec(constant.value)\n    cachedResults.set(ctx, result)\n    return result\n  }\n\n  const fn = (token?: CompatibilityToken | RuntimeToken): any => {\n    if (token) {\n      const ctx = getCompatibilityApi(token).runtime()\n      const value = getValueWithContext(ctx)\n      if (!valuesAreCompatible(token, ctx, value))\n        throw new Error(\n          `Incompatible runtime entry Constant(${palletName}.${name})`,\n        )\n      return value\n    }\n    return descriptors.then(fn)\n  }\n\n  return Object.assign(fn, { isCompatible, getCompatibilityLevel })\n}\n","import { Observable, ReplaySubject, share } from \"rxjs\"\n\nexport const shareLatest: <T>(base: Observable<T>) => Observable<T> = share({\n  connector: () => new ReplaySubject(1),\n  resetOnError: true,\n  resetOnComplete: true,\n  resetOnRefCountZero: true,\n})\n","import { AbortError } from \"@polkadot-api/utils\"\nimport { Observable, Subscription, noop } from \"rxjs\"\n\nexport function firstValueFromWithSignal<T>(\n  source: Observable<T>,\n  signal?: AbortSignal,\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    let subscription: Subscription | null = null\n    let isDone = false\n\n    const onAbort = signal\n      ? () => {\n          subscription?.unsubscribe()\n          reject(new AbortError())\n        }\n      : noop\n\n    subscription = source.subscribe({\n      next: (value) => {\n        resolve(value)\n        subscription?.unsubscribe()\n        isDone = true\n      },\n      error: (e) => {\n        signal?.removeEventListener(\"abort\", onAbort)\n        reject(e)\n        isDone = true\n      },\n      complete: () => {\n        signal?.removeEventListener(\"abort\", onAbort)\n        reject(new Error(\"Observable completed without emitting\"))\n        isDone = true\n      },\n    })\n\n    // the observable could have emitted synchronously\n    if (!isDone) signal?.addEventListener(\"abort\", onAbort)\n  })\n}\n","import { Observable, Subscription } from \"rxjs\"\n\nconst EMPTY_VALUE = Symbol(\"EMPTY_VALUE\")\ntype EMPTY_VALUE = typeof EMPTY_VALUE\n\nexport const lossLessExhaustMap =\n  <I, O>(mapper: (x: I, idx: number) => Observable<O>) =>\n  (source$: Observable<I>): Observable<O> =>\n    new Observable((observer) => {\n      let idx = 0\n      let innerSubscription: Subscription | null = null\n      let queuedValue: I | EMPTY_VALUE = EMPTY_VALUE\n      let isOutterDone = false\n\n      const setInnerSubscription = () => {\n        const observable = mapper(queuedValue as I, idx++)\n        queuedValue = EMPTY_VALUE\n        innerSubscription = observable.subscribe({\n          next(vv) {\n            observer.next(vv)\n          },\n          error(ee) {\n            observer.error(ee)\n          },\n          complete() {\n            if (queuedValue !== EMPTY_VALUE) setInnerSubscription()\n            else {\n              innerSubscription = null\n              if (isOutterDone) observer.complete()\n            }\n          },\n        })\n      }\n\n      const subscription = source$.subscribe({\n        next(v) {\n          queuedValue = v\n          if (!innerSubscription) setInnerSubscription()\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          if (!innerSubscription) observer.complete()\n          isOutterDone = true\n        },\n      })\n\n      return () => {\n        innerSubscription?.unsubscribe()\n        subscription.unsubscribe()\n      }\n    })\n","import { Observable } from \"rxjs\"\n\nlet NOTIN = {}\nexport const continueWith =\n  <I, O>(\n    mapper: (input: I) => Observable<O>,\n  ): ((source: Observable<I>) => Observable<I | O>) =>\n  (source) =>\n    new Observable((observer) => {\n      let latestValue: I = NOTIN as I\n      let subscription = source.subscribe({\n        next(v) {\n          observer.next((latestValue = v))\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          if (latestValue === NOTIN) observer.complete()\n          else subscription = mapper(latestValue).subscribe(observer)\n        },\n      })\n\n      return () => {\n        subscription.unsubscribe()\n      }\n    })\n","export const isOptionalArg = (lastArg: unknown) =>\n  typeof lastArg === \"object\" &&\n  lastArg !== null &&\n  Object.entries(lastArg).every(\n    ([k, v]) =>\n      (k === \"at\" && (v === undefined || typeof v === \"string\")) ||\n      (k === \"signal\" && (v === undefined || v instanceof AbortSignal)),\n  )\n","import {\n  Observable,\n  Subject,\n  MonoTypeOperatorFunction,\n  BehaviorSubject,\n} from \"rxjs\"\nimport { switchAll, tap } from \"rxjs/operators\"\n\n/**\n * A creation operator that helps at creating observables that have circular\n * dependencies.\n *\n * @returns\n */\nexport const selfDependent = <T>(): [\n  Observable<T>,\n  () => MonoTypeOperatorFunction<T>,\n] => {\n  const activeSubject: BehaviorSubject<Subject<T>> = new BehaviorSubject(\n    new Subject<T>(),\n  )\n  return [\n    activeSubject.pipe(switchAll()),\n    () =>\n      tap({\n        next: (v) => activeSubject.value.next(v),\n        error: (e) => {\n          activeSubject.value.error(e)\n          activeSubject.next(new Subject<T>())\n        },\n        complete: () => {\n          activeSubject.value.complete()\n          activeSubject.next(new Subject<T>())\n        },\n      }) as MonoTypeOperatorFunction<T>,\n  ]\n}\n","import { Observable, firstValueFrom, map, mergeMap } from \"rxjs\"\nimport { BlockInfo, ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { CompatibilityFunctions, CompatibilityHelper } from \"./compatibility\"\nimport { concatMapEager, shareLatest } from \"./utils\"\n\nexport type EventPhase =\n  | { type: \"ApplyExtrinsic\"; value: number }\n  | { type: \"Finalization\" }\n  | { type: \"Initialization\" }\n\nexport type EvWatch<T> = (filter?: (value: T) => boolean) => Observable<{\n  meta: {\n    block: BlockInfo\n    phase: EventPhase\n  }\n  payload: T\n}>\n\nexport type EvPull<T> = () => Promise<\n  Array<{\n    meta: {\n      block: BlockInfo\n      phase: EventPhase\n    }\n    payload: T\n  }>\n>\n\nexport type EvFilter<T> = (collection: SystemEvent[\"event\"][]) => Array<T>\n\nexport type EvClient<Unsafe, D, T> = {\n  /**\n   * Multicast and stateful Observable watching for new events (matching the\n   * event kind chosen) in the latest known `finalized` block.\n   *\n   * @param filter  Optional filter function to only emit events complying\n   *                with the function.\n   */\n  watch: EvWatch<T>\n  /**\n   * Fetch (Promise-based) all events (matching the event kind chosen) available\n   * in the latest known `finalized` block.\n   */\n  pull: EvPull<T>\n  /**\n   * Filter a bunch of `SystemEvent` and return the decoded `payload` of every\n   * of them.\n   *\n   * @param collection  Array of `SystemEvent` to filter.\n   */\n  filter: EvFilter<T>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\ntype SystemEvent = {\n  phase: EventPhase\n  event: {\n    type: string\n    value: {\n      type: string\n      value: any\n    }\n  }\n  topics: Array<any>\n}\n\nexport const createEventEntry = <D, T>(\n  pallet: string,\n  name: string,\n  chainHead: ChainHead$,\n  {\n    isCompatible,\n    getCompatibilityLevel,\n    withCompatibleRuntime,\n    argsAreCompatible,\n    valuesAreCompatible,\n  }: CompatibilityHelper,\n): EvClient<any, D, T> => {\n  const compatibilityError = () =>\n    new Error(`Incompatible runtime entry Event(${pallet}.${name})`)\n\n  const shared$ = chainHead.finalized$.pipe(\n    withCompatibleRuntime(chainHead, (x) => x.hash),\n    map(([block, runtime, ctx]) => {\n      const eventsIdx = ctx.lookup.metadata.pallets.find(\n        (p) => p.name === pallet,\n      )?.events?.type\n      if (\n        eventsIdx == null ||\n        ctx.lookup.metadata.lookup[eventsIdx].def.tag !== \"variant\" ||\n        ctx.lookup.metadata.lookup[eventsIdx].def.value.find(\n          (ev) => ev.name === name,\n        ) == null\n      )\n        throw new Error(`Runtime entry Event(${pallet}.${name}) not found`)\n\n      if (!argsAreCompatible(runtime, ctx, null)) throw compatibilityError()\n      return [block, runtime, ctx] as const\n    }),\n    concatMapEager(([block, runtime, ctx]) =>\n      chainHead.eventsAt$(block.hash).pipe(\n        map((events) => {\n          const winners = events.filter(\n            (e) => e.event.type === pallet && e.event.value.type === name,\n          )\n          return winners.map((x) => {\n            if (!valuesAreCompatible(runtime, ctx, x.event.value.value))\n              throw compatibilityError()\n            return {\n              meta: {\n                phase: x.phase,\n                block,\n              },\n              payload: x.event.value.value,\n            }\n          })\n        }),\n      ),\n    ),\n    shareLatest,\n  )\n\n  const watch: EvWatch<T> = (f) =>\n    shared$.pipe(mergeMap((x) => (f ? x.filter((d) => f(d.payload)) : x)))\n\n  const pull: EvPull<T> = () => firstValueFrom(shared$)\n\n  const filter: EvFilter<T> = (events) =>\n    events\n      .filter((e) => e.type === pallet && e.value.type === name)\n      .map((x) => x.value.value)\n\n  return { watch, pull, filter, getCompatibilityLevel, isCompatible }\n}\n","import { firstValueFromWithSignal, isOptionalArg } from \"@/utils\"\nimport { ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { toHex } from \"@polkadot-api/utils\"\nimport { map, mergeMap } from \"rxjs\"\nimport { CompatibilityFunctions, CompatibilityHelper } from \"./compatibility\"\nimport { PullOptions } from \"./types\"\n\ntype WithCallOptions<Args extends Array<any>> = Args[\"length\"] extends 0\n  ? [options?: PullOptions]\n  : [...args: Args, options?: PullOptions]\n\nexport type RuntimeCall<Unsafe, D, Args extends Array<any>, Payload> = {\n  /**\n   * Get `Payload` (Promise-based) for the runtime call.\n   *\n   * @param args  All keys needed for that runtime call.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   */\n  (...args: WithCallOptions<Args>): Promise<Payload>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nexport const createRuntimeCallEntry = (\n  api: string,\n  method: string,\n  chainHead: ChainHead$,\n  {\n    isCompatible,\n    getCompatibilityLevel,\n    compatibleRuntime$,\n    argsAreCompatible,\n    valuesAreCompatible,\n  }: CompatibilityHelper,\n): RuntimeCall<any, any, any, any> => {\n  const callName = `${api}_${method}`\n  const compatibilityError = () =>\n    new Error(`Incompatible runtime entry RuntimeCall(${callName})`)\n\n  const fn = (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: PullOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = compatibleRuntime$(chainHead, at).pipe(\n      mergeMap(([runtime, ctx]) => {\n        let codecs\n        try {\n          codecs = ctx.dynamicBuilder.buildRuntimeCall(api, method)\n        } catch {\n          throw new Error(`Runtime entry RuntimeCall(${callName}) not found`)\n        }\n        if (!argsAreCompatible(runtime, ctx, args)) throw compatibilityError()\n        return chainHead.call$(at, callName, toHex(codecs.args.enc(args))).pipe(\n          map(codecs.value.dec),\n          map((value) => {\n            if (!valuesAreCompatible(runtime, ctx, value))\n              throw compatibilityError()\n            return value\n          }),\n        )\n      }),\n      chainHead.withHodl(at),\n    )\n\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  return Object.assign(fn, { getCompatibilityLevel, isCompatible })\n}\n","import {\n  firstValueFromWithSignal,\n  isOptionalArg,\n  lossLessExhaustMap,\n} from \"@/utils\"\nimport { CompatibilityLevel } from \"@polkadot-api/metadata-compatibility\"\nimport {\n  BlockInfo,\n  BlockNotPinnedError,\n  ChainHead$,\n  RuntimeContext,\n} from \"@polkadot-api/observable-client\"\nimport { FixedSizeBinary, HexString } from \"@polkadot-api/substrate-bindings\"\nimport { StorageItemInput, StorageResult } from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  OperatorFunction,\n  catchError,\n  combineLatestWith,\n  distinctUntilChanged,\n  filter,\n  from,\n  identity,\n  map,\n  mergeMap,\n  pipe,\n  shareReplay,\n  take,\n} from \"rxjs\"\nimport {\n  CompatibilityFunctions,\n  CompatibilityHelper,\n  CompatibilityToken,\n  getCompatibilityApi,\n  minCompatLevel,\n  RuntimeToken,\n} from \"./compatibility\"\nimport { createWatchEntries } from \"./watch-entries\"\nimport { PullOptions } from \"./types\"\n\ntype WithCallOptions<Args extends Array<any>> = [\n  ...args: Args,\n  options?: PullOptions,\n]\n\ntype WithWatchOptions<Args extends Array<any>> = [\n  ...args: Args,\n  options?: { at: \"best\" },\n]\n\ntype PossibleParents<A extends Array<any>> = A extends [...infer Left, any]\n  ? Left | PossibleParents<Left>\n  : ArrayPossibleParents<A>\n\ntype AllPermutations<A extends Array<any>> = PossibleParents<A> | A\n\n// Fixed-size arrays values can't be extracted one-by-one, so that's a specific case\ntype ArrayPossibleParents<\n  A extends Array<any>,\n  Count extends Array<any> = [],\n  R = [],\n> = A extends Array<infer T> & { length: infer L }\n  ? number extends L\n    ? Array<T> // Case variable-size array it's an unknown amount of entries\n    : L extends Count[\"length\"]\n      ? R\n      : ArrayPossibleParents<A, [...Count, T], R | Count>\n  : never\n\ntype GetKey<Args extends Array<any>, Unsafe> = Unsafe extends true\n  ? {\n      /**\n       * Get the storage-key for this storage entry.\n       *\n       * @param args  All keys needed for that storage entry.\n       * @returns Promise that will resolve the hexadecimal value of the\n       *          storage key.\n       */\n      (...args: AllPermutations<Args>): Promise<HexString>\n      /**\n       * Get the storage-key for this storage entry.\n       *\n       * @param ...args       All keys needed for that storage entry.\n       * @param runtimeToken  Token from got with `await\n       *                      typedApi.runtimeToken`\n       * @returns Synchronously returns the hexadecimal value of the\n       *          storage key.\n       */\n      (\n        ...args: [...AllPermutations<Args>, runtimeToken: RuntimeToken]\n      ): HexString\n    }\n  : {\n      /**\n       * Get the storage-key for this storage entry.\n       *\n       * @param args  All keys needed for that storage entry.\n       * @returns Promise that will resolve the hexadecimal value of the\n       *          storage key.\n       */\n      (...args: AllPermutations<Args>): Promise<HexString>\n      /**\n       * Get the storage-key for this storage entry.\n       *\n       * @param ...args             All keys needed for that storage entry.\n       * @param compatibilityToken  Token from got with `await\n       *                            typedApi.compatibilityToken`\n       * @returns Synchronously returns the hexadecimal value of the\n       *          storage key.\n       */\n      (\n        ...args: [\n          ...AllPermutations<Args>,\n          compatibilityToken: CompatibilityToken,\n        ]\n      ): HexString\n    }\n\ntype StorageEntryWithoutKeys<Unsafe, D, Payload> = {\n  /**\n   * Get `Payload` (Promise-based) for the storage entry.\n   *\n   * @param options  Optionally set which block to target (latest known\n   *                 finalized is the default) and an AbortSignal.\n   */\n  getValue: (options?: PullOptions) => Promise<Payload>\n  /**\n   * Watch changes in `Payload` (observable-based) for the storage entry.\n   *\n   * @param bestOrFinalized  Optionally choose which block to query and watch\n   *                         changes, `best` or `finalized` (default)\n   */\n  watchValue: (bestOrFinalized?: \"best\" | \"finalized\") => Observable<Payload>\n  getKey: GetKey<[], Unsafe>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nexport type StorageEntryWithKeys<\n  Unsafe,\n  D,\n  Args extends Array<any>,\n  Payload,\n  ArgsOut extends Array<any>,\n> = {\n  /**\n   * Get `Payload` (Promise-based) for the storage entry with a specific set of\n   * `Args`.\n   *\n   * @param args  All keys needed for that storage entry.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   */\n  getValue: (...args: [...WithCallOptions<Args>]) => Promise<Payload>\n  /**\n   * Watch changes in `Payload` (observable-based) for the storage entry.\n   *\n   * @param args  All keys needed for that storage entry.\n   *              At the end, optionally choose which block to query and\n   *              watch changes, `best` or `finalized` (default)\n   */\n  watchValue: (\n    ...args: [...Args, bestOrFinalized?: \"best\" | \"finalized\"]\n  ) => Observable<Payload>\n  /**\n   * Get an Array of `Payload` (Promise-based) for the storage entry with\n   * several sets of `Args`.\n   *\n   * @param keys     Array of sets of keys needed for the storage entry.\n   * @param options  Optionally set which block to target (latest known\n   *                 finalized is the default) and an AbortSignal.\n   */\n  getValues: (\n    keys: Array<[...Args]>,\n    options?: PullOptions,\n  ) => Promise<Array<Payload>>\n  /**\n   * Get an Array of `Payload` (Promise-based) for the storage entry with a\n   * subset of `Args`.\n   *\n   * @param args  Subset of keys needed for the storage entry.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   * @example\n   *\n   *   // this is a query with 3 keys\n   *   typedApi.query.Pallet.Query.getEntries({ at: \"best\" }) // no keys\n   *   typedApi.query.Pallet.Query.getEntries(arg1, { at: \"finalized\" }) // 1/3 keys\n   *   typedApi.query.Pallet.Query.getEntries(arg1, arg2, { at: \"0x12345678\" }) // 2/3 keys\n   *\n   */\n  getEntries: (\n    ...args: WithCallOptions<PossibleParents<Args>>\n  ) => Promise<Array<{ keyArgs: ArgsOut; value: NonNullable<Payload> }>>\n  /**\n   * Watch changes (Observable-based) for the storage entries with a subset of\n   * `Args`.\n   *\n   * @param args  Subset of keys needed for the storage entry.\n   *              At the end, optionally set whether to watch against the\n   *              `best` block.\n   *              By default watches changes against the finalized block.\n   *              When watching changes against the \"best\" block, this API\n   *              gratiously handles the re-orgs and provides the deltas\n   *              based on the latest emission.\n   *              The observed value contains the following properties:\n   *              - `block`: the block in where the `deltas` took place -\n   *              `deltas`: `null` indicates that nothing has changed from\n   *              the latest emission.\n   *              If the value is not `null` then the `deleted` and `upsrted`\n   *              properties indicate the entries that have changed.\n   *              - `entries`: it's an immutable data-structure with the\n   *              latest entries.\n   * @example\n   *\n   *   typedApi.query.Staking.Nominators.watchEntries()\n   *   typedApi.query.Staking.Nominators.watchEntries({ at: \"best\" })\n   *\n   */\n  watchEntries: (\n    ...args: WithWatchOptions<PossibleParents<Args>>\n  ) => Observable<{\n    block: BlockInfo\n    deltas: null | {\n      deleted: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n      upserted: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n    }\n    entries: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n  }>\n\n  getKey: GetKey<Args, Unsafe>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nexport type StorageEntry<\n  Unsafe,\n  D,\n  Args extends Array<any>,\n  ArgsOut extends Array<any>,\n  Payload,\n> = Args extends []\n  ? StorageEntryWithoutKeys<Unsafe, D, Payload>\n  : StorageEntryWithKeys<Unsafe, D, Args, Payload, ArgsOut>\n\nexport type Storage$ = <Type extends StorageItemInput[\"type\"]>(\n  hash: string | null,\n  type: Type,\n  key: string,\n  childTrie: string | null,\n) => Observable<StorageResult<Type>>\n\nconst toMapped = map(<T>(x: { mapped: T }) => x.mapped)\nexport const createStorageEntry = (\n  pallet: string,\n  name: string,\n  chainHead: ChainHead$,\n  getWatchEntries: ReturnType<typeof createWatchEntries>,\n  {\n    isCompatible,\n    getCompatibilityLevel,\n    getCompatibilityLevels,\n    descriptors: descriptorsPromise,\n    argsAreCompatible,\n    valuesAreCompatible,\n  }: CompatibilityHelper,\n): StorageEntry<any, any, any, any, any> => {\n  const isSystemNumber = pallet === \"System\" && name === \"Number\"\n  const isBlockHash = pallet === \"System\" && name === \"BlockHash\"\n  const sysNumberMapper$ = chainHead.runtime$.pipe(\n    filter(Boolean),\n    take(1),\n    map(({ dynamicBuilder }) =>\n      typeof dynamicBuilder\n        .buildStorage(\"System\", \"Number\")\n        .value.dec(new Uint8Array(32)) === \"bigint\"\n        ? BigInt\n        : identity,\n    ),\n    shareReplay(),\n  )\n  const bigIntOrNumber: OperatorFunction<number, number | bigint> = pipe(\n    combineLatestWith(sysNumberMapper$),\n    map(([input, mapper]) => mapper(input)),\n  )\n\n  const incompatibleError = () =>\n    new Error(`Incompatible runtime entry Storage(${pallet}.${name})`)\n  const invalidArgs = (args: Array<any>) =>\n    new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`)\n\n  const getCodec = (ctx: RuntimeContext) => {\n    try {\n      return ctx.dynamicBuilder.buildStorage(pallet, name)\n    } catch (e: any) {\n      throw new Error(`Runtime entry Storage(${pallet}.${name}) not found`)\n    }\n  }\n\n  const watchValue = (...args: Array<any>) => {\n    const target = args[args.length - 1]\n    const isBest = target === \"best\"\n    const actualArgs =\n      isBest || target === \"finalized\" ? args.slice(0, -1) : args\n\n    return chainHead[isBest ? \"best$\" : \"finalized$\"].pipe(\n      lossLessExhaustMap(() =>\n        getRawValue$(...actualArgs, isBest ? { at: \"best\" } : {}),\n      ),\n      distinctUntilChanged((a, b) => a.raw === b.raw),\n      toMapped,\n    )\n  }\n\n  const getRawValue$ = (\n    ...args: Array<any>\n  ): Observable<{ raw: string | null; mapped: any }> => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { at: _at }: PullOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = from(descriptorsPromise).pipe(\n      mergeMap((descriptors) =>\n        chainHead.storage$(\n          at,\n          \"value\",\n          (ctx) => {\n            const codecs = getCodec(ctx)\n            const actualArgs =\n              args.length === codecs.len ? args : args.slice(0, -1)\n            if (args !== actualArgs && !isLastArgOptional)\n              throw invalidArgs(args)\n            if (!argsAreCompatible(descriptors, ctx, actualArgs))\n              throw incompatibleError()\n            return codecs.keys.enc(...actualArgs)\n          },\n          null,\n          (data, ctx) => {\n            const codecs = getCodec(ctx)\n            const mapped =\n              data === null ? codecs.fallback : codecs.value.dec(data)\n            if (!valuesAreCompatible(descriptors, ctx, mapped))\n              throw incompatibleError()\n            return { raw: data, mapped }\n          },\n        ),\n      ),\n      chainHead.withHodl(at),\n    )\n\n    if (isSystemNumber)\n      return chainHead.pinnedBlocks$.pipe(\n        map((blocks) => {\n          const hash =\n            at === \"finalized\" || !at\n              ? blocks.finalized\n              : at === \"best\"\n                ? blocks.best\n                : at\n          const block = blocks.blocks.get(hash)\n          if (!block) {\n            throw new BlockNotPinnedError(hash, \"System.Number\")\n          }\n          return block.number\n        }),\n        distinctUntilChanged(),\n        bigIntOrNumber,\n        map((mapped) => ({ raw: mapped.toString(), mapped })),\n        catchError((e) => {\n          if (e instanceof BlockNotPinnedError) return result$\n          throw e\n        }),\n      )\n\n    return isBlockHash && Number(args[0]) === 0\n      ? chainHead.genesis$.pipe(\n          map((raw) => ({ raw, mapped: FixedSizeBinary.fromHex(raw) })),\n        )\n      : result$\n  }\n\n  const getValue = async (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal }: PullOptions = isLastArgOptional ? lastArg : {}\n\n    return firstValueFromWithSignal(\n      getRawValue$(...args).pipe(toMapped),\n      signal,\n    )\n  }\n\n  const getEntries = async (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: PullOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = from(descriptorsPromise).pipe(\n      mergeMap((descriptors) =>\n        chainHead.storage$(\n          at,\n          \"descendantsValues\",\n          (ctx) => {\n            const codecs = getCodec(ctx)\n            // TODO partial compatibility check for args that become optional\n            if (\n              minCompatLevel(getCompatibilityLevels(descriptors, ctx)) ===\n              CompatibilityLevel.Incompatible\n            )\n              throw incompatibleError()\n\n            if (args.length > codecs.len) throw invalidArgs(args)\n            const actualArgs =\n              args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args\n            if (args.length === codecs.len && actualArgs === args)\n              throw invalidArgs(args)\n            return codecs.keys.enc(...actualArgs)\n          },\n          null,\n          (values, ctx) => {\n            const codecs = getCodec(ctx)\n            const decodedValues = values.map(({ key, value }) => ({\n              keyArgs: codecs.keys.dec(key),\n              value: codecs.value.dec(value),\n            }))\n            if (\n              decodedValues.some(\n                ({ value }) => !valuesAreCompatible(descriptors, ctx, value),\n              )\n            )\n              throw incompatibleError()\n            return decodedValues\n          },\n        ),\n      ),\n      chainHead.withHodl(at),\n    )\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  const getValues = (keyArgs: Array<Array<any>>, options?: PullOptions) =>\n    Promise.all(\n      keyArgs.map((args) => getValue(...(options ? [...args, options] : args))),\n    )\n\n  const watchEntries: any = (...args: Array<any>) => {\n    const lastArg = args.at(-1)\n    const isLastArgOptional = isOptionalArg(lastArg)\n\n    return getWatchEntries(\n      pallet,\n      name,\n      isLastArgOptional ? args.slice(0, -1) : args,\n      isLastArgOptional && lastArg.at === \"best\",\n    )\n  }\n\n  const getKey = (...args: Array<any>): Promise<string> | string => {\n    const token = args.at(-1)\n    if (token instanceof CompatibilityToken || token instanceof RuntimeToken) {\n      const actualArgs = args.slice(0, -1)\n      const ctx = getCompatibilityApi(token).runtime()\n      if (!argsAreCompatible(token, ctx, actualArgs)) throw incompatibleError()\n      return getCodec(ctx).keys.enc(...actualArgs)\n    }\n    return descriptorsPromise.then((x) => getKey(...args, x))\n  }\n\n  return {\n    isCompatible,\n    getCompatibilityLevel,\n    getKey: getKey as GetKey<any, any>,\n    getValue,\n    getValues,\n    getEntries,\n    watchValue,\n    watchEntries,\n  }\n}\n","import {\n  getDynamicBuilder,\n  MetadataLookup,\n} from \"@polkadot-api/metadata-builders\"\n\ntype DynamicBuilder = ReturnType<typeof getDynamicBuilder>\nexport const getSystemVersionStruct = (\n  lookupFn: MetadataLookup,\n  dynamicBuilder: DynamicBuilder,\n): Record<string, any> => {\n  const constant = lookupFn.metadata.pallets\n    .find((x) => x.name === \"System\")!\n    .constants!.find((s) => s.name === \"Version\")!\n\n  const systemVersion = lookupFn(constant.type)\n  const systemVersionDec = dynamicBuilder.buildDefinition(constant.type).dec\n\n  if (systemVersion.type !== \"struct\") throw new Error(\"not a struct\")\n  return systemVersionDec(constant.value)\n}\n","import { Bytes, enhanceEncoder, u16 } from \"@polkadot-api/substrate-bindings\"\n\nfunction trailingZeroes(n: number) {\n  let i = 0\n  while (!(n & 1)) {\n    i++\n    n >>= 1\n  }\n  return i\n}\n\nconst nextPower = (n: number) => 1 << Math.ceil(Math.log2(n))\n\nexport const mortal = enhanceEncoder(\n  Bytes(2)[0],\n  (value: { period: number; startAtBlock: number }) => {\n    const period = Math.min(Math.max(nextPower(value.period), 4), 1 << 16)\n    const phase = value.startAtBlock % period\n    const factor = Math.max(period >> 12, 1)\n    const left = Math.min(Math.max(trailingZeroes(period) - 1, 1), 15)\n    const right = (phase / factor) << 4\n    return u16[0](left | right)\n  },\n)\n","import {\n  Bytes,\n  compact,\n  Option,\n  Struct,\n} from \"@polkadot-api/substrate-bindings\"\n\nexport const [ChargeAssetTxPaymentEnc] = Struct({\n  tip: compact,\n  asset: Option(Bytes(Infinity)),\n})\n","import {\n  getDynamicBuilder,\n  MetadataLookup,\n} from \"@polkadot-api/metadata-builders\"\nimport { Encoder } from \"@polkadot-api/substrate-bindings\"\nimport { OfflineTxExtensions } from \"../types\"\nimport { fromHex, mapObject } from \"@polkadot-api/utils\"\nimport { getSystemVersionStruct } from \"./system-version\"\nimport { mortal } from \"./mortal-enc\"\nimport { ChargeAssetTxPaymentEnc } from \"./charge-asset-tx-enc\"\n\nconst empty = new Uint8Array()\nconst zero = Uint8Array.from([0])\ntype DynamicBuilder = ReturnType<typeof getDynamicBuilder>\n\nconst value = (value: Uint8Array) => ({\n  value,\n  additionalSigned: empty,\n})\nconst additionalSigned = (additionalSigned: Uint8Array) => ({\n  value: empty,\n  additionalSigned,\n})\nconst both = (value: Uint8Array, additionalSigned: Uint8Array) => ({\n  value,\n  additionalSigned,\n})\n\nexport const getSignExtensionsCreator = (\n  genesis: Uint8Array,\n  lookupFn: MetadataLookup,\n  dynamicBuilder: DynamicBuilder,\n) => {\n  const signedExtensionsEncoders: Record<string, [Encoder<any>, Encoder<any>]> =\n    {}\n  lookupFn.metadata.extrinsic.signedExtensions.forEach(\n    ({ identifier, type, additionalSigned }) => {\n      signedExtensionsEncoders[identifier] = [type, additionalSigned].map(\n        (x) => dynamicBuilder.buildDefinition(x)[0],\n      ) as [Encoder<any>, Encoder<any>]\n    },\n  )\n\n  return <Asset>({\n    mortality,\n    tip = 0n,\n    nonce,\n    customSignedExtensions = {},\n    ...rest\n  }: OfflineTxExtensions<Asset>): Record<\n    string,\n    { identifier: string; value: Uint8Array; additionalSigned: Uint8Array }\n  > => {\n    const invalidKeys: string[] = []\n    const systemVersion = getSystemVersionStruct(lookupFn, dynamicBuilder)\n    const getFromCustomEntry = (key: string) => {\n      const [valueEnc, additionalEnc] = signedExtensionsEncoders[key]\n      const customEntry = customSignedExtensions[key] as any\n      try {\n        return mapObject(\n          {\n            value: valueEnc,\n            additionalSigned: additionalEnc,\n          },\n          (encoder, key) => {\n            const input = customEntry?.[key]\n            // if the encoder is _void, then the input value is ignored, so no harm in passing `undefined`\n            // only an `Option` encoder will accept `undefined` as an input without crashing\n            return input instanceof Uint8Array ? input : encoder(input)\n          },\n        )\n      } catch {\n        // this means that a non optional custom signed-extension has not received its value\n        invalidKeys.push(key)\n        return null\n      }\n    }\n\n    const result = mapObject(\n      signedExtensionsEncoders,\n      ([valueEnc, additionalEnc], key) => {\n        if (customSignedExtensions[key]) return getFromCustomEntry(key)\n\n        switch (key) {\n          case \"CheckNonce\":\n            return value(valueEnc(nonce))\n\n          case \"CheckMortality\":\n            return mortality.mortal\n              ? both(\n                  mortal({\n                    period: mortality.period,\n                    startAtBlock: mortality.startAtBlock.height,\n                  }),\n                  fromHex(mortality.startAtBlock.hash),\n                )\n              : both(zero, genesis)\n\n          case \"ChargeTransactionPayment\":\n            return value(valueEnc(tip))\n\n          case \"ChargeAssetTxPayment\":\n            return value(\n              ChargeAssetTxPaymentEnc({\n                tip,\n                asset: (rest as any).asset,\n              }),\n            )\n\n          case \"CheckGenesis\":\n            return additionalSigned(genesis)\n\n          case \"CheckMetadataHash\":\n            return both(zero, zero)\n\n          case \"CheckSpecVersion\":\n            return additionalSigned(\n              additionalEnc(systemVersion[\"spec_version\"]),\n            )\n\n          case \"CheckTxVersion\":\n            return additionalSigned(\n              additionalEnc(systemVersion[\"transaction_version\"]),\n            )\n\n          default:\n            return getFromCustomEntry(key)\n        }\n      },\n    )\n\n    invalidKeys.forEach((key) => {\n      delete result[key]\n    })\n    return mapObject(result, (x, identifier) => ({ ...x, identifier })) as any\n  }\n}\n","import { BlockInfo, ChainHead$ } from \"@polkadot-api/observable-client\"\nimport type { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nimport { HexString, u16, u32, u64, u8 } from \"@polkadot-api/substrate-bindings\"\nimport { fromHex, toHex } from \"@polkadot-api/utils\"\nimport {\n  Observable,\n  catchError,\n  combineLatest,\n  distinctUntilChanged,\n  filter,\n  map,\n  mergeMap,\n  of,\n  scan,\n  startWith,\n  switchMap,\n  take,\n} from \"rxjs\"\nimport { getSignExtensionsCreator } from \"./signed-extensions\"\nimport { CustomSignedExtensionValues } from \"./types\"\n\ntype HintedSignedExtensions = Partial<{\n  tip: bigint\n  mortality: { mortal: false } | { mortal: true; period: number }\n  asset: Uint8Array\n  nonce: number\n}>\n\nconst NONCE_RUNTIME_CALL = \"AccountNonceApi_account_nonce\"\nconst lenToDecoder = {\n  1: u8.dec,\n  2: u16.dec,\n  4: u32.dec,\n  8: u64.dec,\n}\n\nconst getNonceAtBlock$ = (\n  call$: ChainHead$[\"call$\"],\n  from: HexString,\n  at: string,\n) =>\n  call$(at, NONCE_RUNTIME_CALL, from).pipe(\n    map((result) => {\n      const bytes = fromHex(result)\n      const decoder = lenToDecoder[bytes.length as 2 | 4 | 8]\n      if (!decoder)\n        throw new Error(`${NONCE_RUNTIME_CALL} retrieved wrong data`)\n      return decoder(bytes)\n    }),\n  )\n\nexport const createTx: (\n  chainHead: ChainHead$,\n  signer: PolkadotSigner,\n  callData: Uint8Array,\n  atBlock: BlockInfo,\n  customSignExt: Record<string, CustomSignedExtensionValues>,\n  hinted?: HintedSignedExtensions,\n) => Observable<Uint8Array> = (\n  chainHead,\n  signer,\n  callData,\n  atBlock,\n  customSignedExtensions,\n  hinted = {},\n) =>\n  combineLatest([\n    hinted.nonce\n      ? of(hinted.nonce)\n      : getNonce$(chainHead, toHex(signer.publicKey)),\n    chainHead.getRuntimeContext$(atBlock.hash),\n    chainHead.genesis$,\n  ]).pipe(\n    take(1),\n    mergeMap(([nonce, ctx, genesis]) => {\n      const signExtCreator = getSignExtensionsCreator(\n        fromHex(genesis),\n        ctx.lookup,\n        ctx.dynamicBuilder,\n      )\n\n      const mortality: HintedSignedExtensions[\"mortality\"] =\n        hinted.mortality ?? { period: 64, mortal: true }\n\n      const signExtensions = signExtCreator({\n        nonce: nonce as number,\n        tip: hinted.tip ?? 0n,\n        mortality: mortality.mortal\n          ? {\n              mortal: true,\n              period: mortality.period,\n              startAtBlock: {\n                height: atBlock.number,\n                hash: atBlock.hash,\n              },\n            }\n          : { mortal: false },\n        customSignedExtensions,\n        asset: hinted.asset,\n      })\n\n      return signer.signTx(\n        callData,\n        signExtensions,\n        ctx.metadataRaw,\n        atBlock.number,\n      )\n    }),\n  )\n\nconst getNonce$ = (chainHead: ChainHead$, from: HexString) => {\n  const followHead$ = (head: string) =>\n    chainHead.newBlocks$.pipe(\n      scan((acc, block) => (block.parent === acc ? block.hash : acc), head),\n      startWith(head),\n      distinctUntilChanged(),\n    )\n  const followNonce$ = (head: string) =>\n    followHead$(head).pipe(\n      take(2),\n      switchMap((hash) => getNonceAtBlock$(chainHead.call$, from, hash)),\n    )\n  const getHeadsNonce$ = (heads: string[]) =>\n    combineLatest(\n      heads.map((head) =>\n        followNonce$(head).pipe(\n          map((value) => ({\n            success: true as const,\n            value,\n          })),\n          catchError((err) =>\n            of({\n              success: false as const,\n              value: err,\n            }),\n          ),\n        ),\n      ),\n    ).pipe(take(1))\n\n  return chainHead.pinnedBlocks$.pipe(\n    filter((v) => !v.recovering && v.blocks.size > 0),\n    take(1),\n    map(({ blocks, best }) => {\n      // Grab only the heads: those blocks above the best that don't have children and are not getting pruned\n      const bestBlock = blocks.get(best)!\n      return [...blocks.values()]\n        .filter(\n          (v) =>\n            !v.unpinnable &&\n            v.children.size === 0 &&\n            v.number >= bestBlock.number,\n        )\n        .map((v) => v.hash)\n    }),\n    switchMap(getHeadsNonce$),\n    map((result) => {\n      const winner = result.reduce(\n        (acc: bigint | number | null, v) =>\n          v.success ? (v.value >= (acc ?? 0) ? v.value : acc) : acc,\n        null,\n      )\n\n      if (winner == null) {\n        // We must have at least one error\n        throw result[0].value\n      }\n      return winner\n    }),\n  )\n}\n","import {\n  Binary,\n  HexString,\n  ResultPayload,\n} from \"@polkadot-api/substrate-bindings\"\nimport {\n  EMPTY,\n  Observable,\n  concat,\n  defer,\n  distinctUntilChanged,\n  endWith,\n  filter,\n  ignoreElements,\n  lastValueFrom,\n  map,\n  merge,\n  mergeMap,\n  of,\n  race,\n  take,\n  takeWhile,\n} from \"rxjs\"\nimport {\n  BlockInfo,\n  ChainHead$,\n  PinnedBlocks,\n  SystemEvent,\n} from \"@polkadot-api/observable-client\"\nimport { AnalyzedBlock } from \"@polkadot-api/observable-client\"\nimport { TxEvent, TxEventsPayload, TxFinalizedPayload } from \"./types\"\nimport { continueWith } from \"@/utils\"\nimport { fromHex, toHex } from \"@polkadot-api/utils\"\n\nconst computeState = (\n  analized$: Observable<AnalyzedBlock>,\n  blocks$: Observable<PinnedBlocks>,\n) =>\n  new Observable<\n    | {\n        found: true\n        hash: string\n        number: number\n        index: number\n        events: any\n      }\n    | { found: false; validity: ResultPayload<any, any> | null }\n  >((observer) => {\n    const analyzedBlocks = new Map<string, AnalyzedBlock>()\n    let pinnedBlocks: PinnedBlocks\n    let latestState:\n      | {\n          found: true\n          hash: string\n          number: number\n          index: number\n          events: any\n        }\n      | { found: false; validity: ResultPayload<any, any> | null }\n\n    const computeNextState = () => {\n      let current: string = pinnedBlocks.best\n      let analyzed: AnalyzedBlock | undefined = analyzedBlocks.get(current)\n      let analyzedNumber = pinnedBlocks.blocks.get(current)!.number\n\n      while (!analyzed) {\n        const block = pinnedBlocks.blocks.get(current)\n        if (!block) break\n        analyzed = analyzedBlocks.get((current = block.parent))\n        analyzedNumber--\n      }\n\n      if (!analyzed) return // this shouldn't happen, though\n\n      const isFinalized =\n        analyzedNumber <=\n        pinnedBlocks.blocks.get(pinnedBlocks.finalized)!.number\n\n      const found = analyzed.found.type\n      if (found && latestState?.found && latestState.hash === analyzed.hash) {\n        if (isFinalized) observer.complete()\n        return\n      }\n\n      observer.next(\n        (latestState = analyzed.found.type\n          ? {\n              found: found as true,\n              hash: analyzed.hash,\n              number: analyzedNumber,\n              index: analyzed.found.index,\n              events: analyzed.found.events,\n            }\n          : {\n              found: found as false,\n              validity: analyzed.found.validity,\n            }),\n      )\n\n      if (isFinalized) {\n        if (found) observer.complete()\n        else if (analyzed.found.validity?.success === false)\n          observer.error(new InvalidTxError(analyzed.found.validity.value))\n      }\n    }\n\n    const subscription = blocks$\n      .pipe(\n        distinctUntilChanged(\n          (a, b) => a.finalized === b.finalized && a.best === b.best,\n        ),\n      )\n      .subscribe({\n        next: (pinned: PinnedBlocks) => {\n          pinnedBlocks = pinned\n          if (analyzedBlocks.size === 0) return\n          computeNextState()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      })\n\n    subscription.add(\n      analized$.subscribe({\n        next: (block) => {\n          analyzedBlocks.set(block.hash, block)\n          computeNextState()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      }),\n    )\n\n    return subscription\n  }).pipe(distinctUntilChanged((a, b) => a === b))\n\nconst getTxSuccessFromSystemEvents = (\n  systemEvents: Array<SystemEvent>,\n  txIdx: number,\n): Omit<TxEventsPayload, \"block\"> => {\n  const events = systemEvents\n    .filter((x) => x.phase.type === \"ApplyExtrinsic\" && x.phase.value === txIdx)\n    .map((x) => ({ ...x.event, topics: x.topics }))\n\n  const lastEvent = events[events.length - 1]\n  if (\n    lastEvent.type === \"System\" &&\n    lastEvent.value.type === \"ExtrinsicFailed\"\n  ) {\n    return {\n      ok: false,\n      events,\n      dispatchError: lastEvent.value.value.dispatch_error,\n    }\n  }\n\n  return { ok: true, events }\n}\n\n/*\ntype TransactionValidityError = Enum<{\n  Invalid: Enum<{\n    Call: undefined\n    Payment: undefined\n    Future: undefined\n    Stale: undefined\n    BadProof: undefined\n    AncientBirthBlock: undefined\n    ExhaustsResources: undefined\n    Custom: number\n    BadMandatory: undefined\n    MandatoryValidation: undefined\n    BadSigner: undefined\n  }>\n  Unknown: Enum<{\n    CannotLookup: undefined\n    NoUnsignedValidator: undefined\n    Custom: number\n  }>\n}>\n*/\nexport class InvalidTxError extends Error {\n  error: any // likely to be a `TransactionValidityError`\n  constructor(e: any) {\n    super(\n      JSON.stringify(\n        e,\n        (_, value) => {\n          if (typeof value === \"bigint\") return value.toString()\n          return value instanceof Binary ? value.asHex() : value\n        },\n        2,\n      ),\n    )\n    this.name = \"InvalidTxError\"\n    this.error = e\n  }\n}\n\nexport const submit$ = (\n  chainHead: ChainHead$,\n  broadcastTx$: (tx: string) => Observable<never>,\n  tx: HexString,\n  emitSign = false,\n): Observable<TxEvent> =>\n  chainHead.hasher$.pipe(\n    mergeMap((hasher) => {\n      const txHash = toHex(hasher(fromHex(tx)))\n      const getTxEvent = <\n        Type extends TxEvent[\"type\"],\n        Rest extends Omit<TxEvent & { type: Type }, \"type\" | \"txHash\">,\n      >(\n        type: Type,\n        rest: Rest,\n      ): TxEvent & { type: Type } =>\n        ({\n          type,\n          txHash,\n          ...rest,\n        }) as any\n\n      const pinnedBlocks = chainHead.pinnedBlocks$.state\n      const getHeightFromMortality = (\n        mortality:\n          | {\n              mortal: false\n            }\n          | {\n              mortal: true\n              period: number\n              phase: number\n            },\n      ) => {\n        if (!mortality.mortal) return 0\n        const { phase, period } = mortality\n        const topNumber = pinnedBlocks.blocks.get(pinnedBlocks.best)!.number\n        return (\n          Math.floor((Math.max(topNumber, phase) - phase) / period) * period +\n          phase\n        )\n      }\n\n      const getTipsFromHeight = (height: number): BlockInfo[] => {\n        let tips: BlockInfo[] = [...pinnedBlocks.blocks.values()].filter(\n          (block) => !block.unpinnable && !block.children.size,\n        )\n        const higherTip = Math.max(...tips.map(({ number }) => number))\n        // take only tips \"with chance to become canonical\"\n        tips = tips.filter(({ number }) => number >= higherTip - 1)\n\n        const finalized = pinnedBlocks.blocks.get(pinnedBlocks.finalized)!\n        tips = finalized.children ? [finalized, ...tips] : tips\n\n        return tips.filter((x) => x.number >= height)\n      }\n\n      const validateTxAt$ = ({ hash }: BlockInfo) =>\n        chainHead.validateTx$(hash, tx)\n      const validate$: Observable<never> = defer(() =>\n        pinnedBlocks.finalizedRuntime.runtime.pipe(\n          map((r) => r.getMortalityFromTx(tx)),\n          map(getHeightFromMortality),\n          map(getTipsFromHeight),\n          mergeMap((blocksToValidate) => {\n            let err: InvalidTxError\n            return merge(\n              ...blocksToValidate.map((b) =>\n                race(\n                  validateTxAt$(b),\n                  chainHead.finalized$.pipe(\n                    takeWhile((finalized) => {\n                      if (finalized.number < b.number) return true\n                      let curr = finalized\n                      while (curr.number > b.number) {\n                        const parent = pinnedBlocks.blocks.get(curr.parent)\n                        if (!parent) return false\n                        curr = parent\n                      }\n                      return curr.hash === finalized.hash\n                    }),\n                    ignoreElements(),\n                    endWith({ success: null }),\n                  ),\n                ),\n              ),\n            ).pipe(\n              filter((v, idx) => {\n                // save first error\n                if (v.success === false) err ??= new InvalidTxError(v.value)\n\n                if (v.success) return true\n                if (idx === blocksToValidate.length - 1 && err) throw err\n                return false\n              }),\n              take(1),\n            )\n          }),\n          ignoreElements(),\n        ),\n      )\n\n      const track$ = new Observable<AnalyzedBlock>((observer) => {\n        const subscription = chainHead.trackTx$(tx).subscribe(observer)\n        subscription.add(\n          broadcastTx$(tx).subscribe({\n            error(e) {\n              observer.error(e)\n            },\n          }),\n        )\n        return subscription\n      })\n\n      const bestBlockState$ = computeState(\n        track$,\n        chainHead.pinnedBlocks$,\n      ).pipe(\n        map((x) => {\n          if (!x.found)\n            return getTxEvent(\"txBestBlocksState\", {\n              found: false,\n              isValid: x.validity?.success !== false,\n            })\n\n          return getTxEvent(\"txBestBlocksState\", {\n            found: true,\n            block: {\n              index: x.index,\n              number: x.number,\n              hash: x.hash,\n            },\n            ...getTxSuccessFromSystemEvents(x.events, x.index),\n          })\n        }),\n      )\n\n      return concat(\n        emitSign ? of(getTxEvent(\"signed\", {})) : EMPTY,\n        validate$,\n        of(getTxEvent(\"broadcasted\", {})),\n        bestBlockState$.pipe(\n          continueWith(({ found, type, ...rest }) =>\n            found ? of(getTxEvent(\"finalized\", rest as any)) : EMPTY,\n          ),\n        ),\n      )\n    }),\n  )\n\nexport const submit = async (\n  chainHead: ChainHead$,\n  broadcastTx$: (tx: string) => Observable<never>,\n  transaction: HexString,\n  _at?: HexString,\n): Promise<TxFinalizedPayload> =>\n  lastValueFrom(submit$(chainHead, broadcastTx$, transaction)).then((x) => {\n    if (x.type !== \"finalized\") throw null\n    const result: TxFinalizedPayload = { ...x }\n    delete (result as any).type\n    return result\n  })\n","import type { BlockInfo, ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nimport { getPolkadotSigner } from \"@polkadot-api/signer\"\nimport {\n  _void,\n  AccountId,\n  Binary,\n  compactBn,\n  Decoder,\n  Enum,\n  Struct,\n  u128,\n  u32,\n  Variant,\n} from \"@polkadot-api/substrate-bindings\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport {\n  Observable,\n  combineLatest,\n  firstValueFrom,\n  map,\n  mergeMap,\n  take,\n  throwError,\n} from \"rxjs\"\nimport { PlainDescriptor } from \"@/descriptors\"\nimport {\n  CompatibilityHelper,\n  CompatibilityToken,\n  getCompatibilityApi,\n  RuntimeToken,\n} from \"../compatibility\"\nimport { createTx } from \"./create-tx\"\nimport { InvalidTxError, submit, submit$ } from \"./submit-fns\"\nimport {\n  PaymentInfo,\n  TxCall,\n  TxEntry,\n  TxObservable,\n  TxOptions,\n  TxPromise,\n  TxSignFn,\n} from \"./types\"\nimport {\n  isCompatible,\n  mapLookupToTypedef,\n} from \"@polkadot-api/metadata-compatibility\"\n\nexport { submit, submit$, InvalidTxError }\n\nconst accountIdEnc = AccountId().enc\nconst fakeSignature = new Uint8Array(64)\nconst fakeSignatureEth = new Uint8Array(65)\nconst getFakeSignature = (isEth: boolean) => () =>\n  isEth ? fakeSignatureEth : fakeSignature\n\nconst [, queryInfoDecFallback] = Struct({\n  weight: Struct({\n    ref_time: compactBn,\n    proof_size: compactBn,\n  }),\n  class: Variant({\n    Normal: _void,\n    Operational: _void,\n    Mandatory: _void,\n  }),\n  partial_fee: u128,\n})\n\nexport const createTxEntry = <\n  D,\n  Arg extends {} | undefined,\n  Pallet extends string,\n  Name extends string,\n  Asset extends PlainDescriptor<any>,\n>(\n  pallet: Pallet,\n  name: Name,\n  chainHead: ChainHead$,\n  broadcast: (tx: string) => Observable<never>,\n  {\n    isCompatible: isCompatibleHelper,\n    getCompatibilityLevel,\n    compatibleRuntime$,\n    argsAreCompatible,\n    getRuntimeTypedef,\n  }: CompatibilityHelper,\n  checkCompatibility: boolean,\n): TxEntry<D, Arg, Pallet, Name, Asset> => {\n  const fn = (arg?: Arg): any => {\n    const getCallDataWithContext = (\n      runtime: CompatibilityToken | RuntimeToken,\n      arg: any,\n      txOptions: Partial<{ asset: any }> = {},\n    ) => {\n      const ctx = getCompatibilityApi(runtime).runtime()\n      const { dynamicBuilder, assetId, lookup } = ctx\n      let codecs\n      try {\n        codecs = dynamicBuilder.buildCall(pallet, name)\n      } catch {\n        throw new Error(`Runtime entry Tx(${pallet}.${name}) not found`)\n      }\n      if (checkCompatibility && !argsAreCompatible(runtime, ctx, arg))\n        throw new Error(`Incompatible runtime entry Tx(${pallet}.${name})`)\n\n      let returnOptions = txOptions\n      if (txOptions.asset) {\n        if (\n          assetId == null ||\n          !isCompatible(\n            txOptions.asset,\n            mapLookupToTypedef(lookup(assetId)),\n            (id) => getRuntimeTypedef(ctx, id),\n          )\n        )\n          throw new Error(`Incompatible runtime asset`)\n        returnOptions = {\n          ...txOptions,\n          asset: dynamicBuilder.buildDefinition(assetId).enc(txOptions.asset),\n        }\n      }\n\n      const { location, codec } = codecs\n      return {\n        callData: Binary.fromBytes(\n          mergeUint8([new Uint8Array(location), codec.enc(arg)]),\n        ),\n        options: returnOptions,\n      }\n    }\n\n    const getCallData$ = (arg: any, options: Partial<{ asset: any }> = {}) =>\n      compatibleRuntime$(chainHead, null).pipe(\n        map(([runtime]) => getCallDataWithContext(runtime, arg, options)),\n      )\n\n    const getEncodedData: TxCall = (\n      token?: CompatibilityToken | RuntimeToken,\n    ): any => {\n      if (!token)\n        return firstValueFrom(getCallData$(arg).pipe(map((x) => x.callData)))\n\n      return getCallDataWithContext(token, arg).callData\n    }\n\n    const sign$ = (\n      from: PolkadotSigner,\n      { ..._options }: Omit<TxOptions<{}>, \"at\">,\n      atBlock: BlockInfo,\n    ) =>\n      getCallData$(arg, _options).pipe(\n        mergeMap(({ callData, options }) =>\n          createTx(\n            chainHead,\n            from,\n            callData.asBytes(),\n            atBlock,\n            _options.customSignedExtensions || {},\n            options,\n          ),\n        ),\n      )\n\n    const _sign = (\n      from: PolkadotSigner,\n      { at, ..._options }: TxOptions<{}> = {},\n    ) => {\n      return (\n        !at || at === \"finalized\"\n          ? chainHead.finalized$\n          : at === \"best\"\n            ? chainHead.best$\n            : chainHead.bestBlocks$.pipe(\n                map((x) => x.find((b) => b.hash === at)),\n              )\n      ).pipe(\n        take(1),\n        mergeMap((atBlock) =>\n          atBlock\n            ? sign$(from, _options, atBlock).pipe(\n                map((signed) => ({\n                  tx: toHex(signed),\n                  block: atBlock,\n                })),\n              )\n            : throwError(() => new Error(`Uknown block ${at}`)),\n        ),\n      )\n    }\n\n    const sign: TxSignFn<Asset> = (from, options) =>\n      firstValueFrom(_sign(from, options)).then((x) => x.tx)\n\n    const signAndSubmit: TxPromise<Asset> = (from, _options) =>\n      firstValueFrom(_sign(from, _options)).then(({ tx, block }) =>\n        submit(chainHead, broadcast, tx, block.hash),\n      )\n\n    const signSubmitAndWatch: TxObservable<Asset> = (from, _options) =>\n      _sign(from, _options).pipe(\n        mergeMap(({ tx }) => submit$(chainHead, broadcast, tx, true)),\n      )\n\n    const getPaymentInfo = async (\n      from: Uint8Array | string,\n      _options?: any,\n    ) => {\n      if (typeof from === \"string\")\n        from = from.startsWith(\"0x\") ? fromHex(from) : accountIdEnc(from)\n      const isEth = from.length === 20\n      const fakeSigner = getPolkadotSigner(\n        from,\n        isEth ? \"Ecdsa\" : \"Sr25519\",\n        getFakeSignature(isEth),\n      )\n      const encoded = fromHex(await sign(fakeSigner, _options))\n      const args = toHex(mergeUint8([encoded, u32.enc(encoded.length)]))\n\n      const decoder$: Observable<Decoder<PaymentInfo>> = chainHead\n        .getRuntimeContext$(null)\n        .pipe(\n          map((ctx) => {\n            try {\n              return ctx.dynamicBuilder.buildRuntimeCall(\n                \"TransactionPaymentApi\",\n                \"query_info\",\n              ).value[1]\n            } catch {\n              return queryInfoDecFallback\n            }\n          }),\n        )\n\n      const call$ = chainHead.call$(\n        null,\n        \"TransactionPaymentApi_query_info\",\n        args,\n      )\n\n      return firstValueFrom(\n        combineLatest([call$, decoder$]).pipe(\n          map(([result, decoder]) => decoder(result)),\n        ),\n      )\n    }\n\n    const getEstimatedFees = async (\n      from: Uint8Array | string,\n      _options?: any,\n    ) => (await getPaymentInfo(from, _options)).partial_fee\n\n    return {\n      getPaymentInfo,\n      getEstimatedFees,\n      decodedCall: {\n        type: pallet,\n        value: Enum(name, arg as any),\n      },\n      getEncodedData,\n      sign,\n      signSubmitAndWatch,\n      signAndSubmit,\n    }\n  }\n\n  return Object.assign(fn, {\n    getCompatibilityLevel,\n    isCompatible: isCompatibleHelper,\n  })\n}\n","import { HexString } from \"@polkadot-api/substrate-bindings\"\nimport type {\n  PinnedBlocks,\n  BlockInfo,\n  ChainHead$,\n  RuntimeContext,\n} from \"@polkadot-api/observable-client\"\nimport {\n  BlockNotPinnedError,\n  isBestOrFinalizedBlock,\n} from \"@polkadot-api/observable-client\"\nimport {\n  catchError,\n  combineLatest,\n  delay,\n  distinctUntilChanged,\n  EMPTY,\n  filter,\n  map,\n  merge,\n  mergeMap,\n  Observable,\n  of,\n  pairwise,\n  startWith,\n  take,\n  takeUntil,\n  throwError,\n  withLatestFrom,\n} from \"rxjs\"\nimport { selfDependent, lossLessExhaustMap } from \"@/utils\"\nimport { state } from \"@rx-state/core\"\n\ninterface StorageEntry {\n  key: HexString\n  value: HexString\n  dec: {\n    args: Array<any>\n    value: any\n  }\n}\n\ntype Deltas = {\n  upserted: Array<StorageEntry>\n  deleted: Array<StorageEntry>\n}\n\ninterface MemoryBlock {\n  prev: HexString | null\n  block: BlockInfo\n  rootHash: string\n  entries: Array<StorageEntry>\n  deltas: Deltas | null\n}\n\ntype MemoryBlocks = {\n  blocks: Record<HexString, MemoryBlock>\n  finalized: HexString\n}\n\nconst getDiff = (\n  _prev: Array<StorageEntry>,\n  _current: Array<StorageEntry>,\n  patch: (input: StorageEntry) => StorageEntry,\n): Pick<MemoryBlock, \"entries\" | \"deltas\"> => {\n  const current = new Map(_current.map((x) => [x.key, x]))\n  const prev = new Map(_prev.map((x) => [x.key, x]))\n\n  const upserted: Map<string, StorageEntry> = new Map()\n  const deleted: Array<StorageEntry> = []\n\n  _current.forEach((value) => {\n    const { key } = value\n    const prevVal = prev.get(key)\n    if (!prevVal || prevVal.value !== value.value)\n      upserted.set(key, patch(value))\n  })\n\n  _prev.forEach((x) => {\n    if (!current.has(x.key)) deleted.push(x)\n  })\n\n  return {\n    deltas: {\n      deleted,\n      upserted: [...upserted.values()],\n    },\n    entries: _current.map(({ key }) => upserted.get(key) ?? prev.get(key)!),\n  }\n}\n\nconst findPrevious = (\n  start: HexString,\n  state: MemoryBlocks[\"blocks\"],\n  pinned: PinnedBlocks,\n  includeStart = false,\n) => {\n  try {\n    let target = includeStart ? start : pinned.blocks.get(start)!.parent\n    while (target && !state[target]) target = pinned.blocks.get(target)!.parent!\n\n    if (!target) return null\n    return state[target]\n  } catch {\n    return null\n  }\n}\n\nconst getPatcherFromRuntime =\n  (pallet: string, entry: string) => (runtime: RuntimeContext) => {\n    const { keys, value } = runtime.dynamicBuilder.buildStorage(pallet, entry)\n    return (x: StorageEntry) => {\n      x.dec = {\n        value: value.dec(x.value),\n        args: keys.dec(x.key),\n      }\n      return x\n    }\n  }\n\nexport const createWatchEntries = (\n  blocks$: Observable<PinnedBlocks>,\n  storage: ChainHead$[\"storage$\"],\n  withRuntime: ChainHead$[\"withRuntime\"],\n) => {\n  const getMemoryBlocks$ = state(\n    (pallet: string, entry: string, storageKey: string) => {\n      const getPatcher = getPatcherFromRuntime(pallet, entry)\n      const getNextMemoryBlock$ = (\n        prev: MemoryBlock | null,\n        block: BlockInfo,\n      ): Observable<MemoryBlock> => {\n        const isNotCanonical$ = isBestOrFinalizedBlock(\n          blocks$,\n          block.hash,\n        ).pipe(\n          filter((x) => !x),\n          take(1),\n        )\n\n        return storage(\n          block.hash,\n          \"closestDescendantMerkleValue\",\n          () => storageKey,\n        ).pipe(\n          mergeMap((rootHash) => {\n            if (rootHash === prev?.rootHash)\n              return of({\n                ...prev,\n                block,\n                deltas: null,\n                prev: prev.block.hash,\n              })\n\n            return storage(\n              block.hash,\n              \"descendantsValues\",\n              () => storageKey,\n            ).pipe(\n              withRuntime(() => block.hash),\n              map(\n                ([entries, runtimeCtx]) =>\n                  [entries, getPatcher(runtimeCtx)] as const,\n              ),\n              map(\n                ([entries, patcher]): MemoryBlock => ({\n                  prev: prev && prev.block.hash,\n                  rootHash: rootHash!,\n                  block,\n                  ...getDiff(\n                    prev?.entries ?? [],\n                    entries as StorageEntry[],\n                    patcher,\n                  ),\n                }),\n              ),\n            )\n          }),\n          takeUntil(isNotCanonical$),\n          catchError((e) =>\n            e instanceof BlockNotPinnedError ? EMPTY : throwError(() => e),\n          ),\n        )\n      }\n\n      const initial$ = blocks$.pipe(\n        distinctUntilChanged((a, b) => a.finalized === b.finalized),\n        lossLessExhaustMap(({ blocks, finalized }) =>\n          getNextMemoryBlock$(null, blocks.get(finalized)!),\n        ),\n        take(1),\n        map(\n          (x): MemoryBlocks => ({\n            blocks: { [x.block.hash]: x },\n            finalized: x.block.hash,\n          }),\n        ),\n      )\n\n      const [_memoryBlocks$, connectMemoryBlocks] =\n        selfDependent<MemoryBlocks>()\n      const updates$ = blocks$.pipe(\n        distinctUntilChanged((a, b) => a.best === b.best),\n        withLatestFrom(_memoryBlocks$),\n        lossLessExhaustMap(([pinned, memoryBlocks]) => {\n          const { best } = pinned\n          const { blocks } = memoryBlocks\n          let target = !blocks[best] ? best : null\n          if (!target) return EMPTY\n\n          const previous = findPrevious(target, blocks, pinned)\n          if (previous)\n            return getNextMemoryBlock$(\n              previous,\n              pinned.blocks.get(target)!,\n            ).pipe(\n              map((x) => {\n                blocks[target!] = x\n                return memoryBlocks\n              }),\n            )\n\n          // This means that there has been a stop event that the pinned-blocks\n          // couldn't recover from. Therefore, we must \"start over\"\n          target = pinned.finalized\n          return getNextMemoryBlock$(\n            blocks[memoryBlocks.finalized],\n            pinned.blocks.get(target)!,\n          ).pipe(\n            map((x) => {\n              x.prev = null\n              return {\n                blocks: { [target]: x },\n                finalized: target,\n              }\n            }),\n          )\n        }),\n      )\n\n      return merge(initial$, updates$).pipe(connectMemoryBlocks())\n    },\n  )\n\n  const getBestOrFinalized =\n    (isFinalized: boolean) =>\n    (pallet: string, entry: string, storageKey: string) => {\n      const memoryBlocks$ = getMemoryBlocks$(pallet, entry, storageKey)\n      const getPatcher = getPatcherFromRuntime(pallet, entry)\n\n      const prop = isFinalized ? \"finalized\" : \"best\"\n\n      return combineLatest([\n        memoryBlocks$.pipe(delay(0)),\n        blocks$.pipe(distinctUntilChanged((a, b) => a[prop] === b[prop])),\n      ]).pipe(\n        map(([state, blocks]) =>\n          findPrevious(blocks[prop], state.blocks, blocks, true),\n        ),\n        filter(Boolean),\n        distinctUntilChanged(),\n        startWith(null),\n        pairwise(),\n        withLatestFrom(memoryBlocks$),\n        withRuntime(([[, _latest]]) => _latest!.block.hash),\n        map(\n          ([[[prevUpdate, latest], memoryBlocks], runtimeCtx]) =>\n            [\n              prevUpdate,\n              latest!,\n              memoryBlocks,\n              getPatcher(runtimeCtx),\n            ] as const,\n        ),\n        mergeMap(([prevUpdate, latest, memoryBlocks, patcher]) => {\n          if (!prevUpdate) return [latest]\n\n          let ancestor: MemoryBlock | null = latest\n          const updates: Array<MemoryBlock> = []\n          while (ancestor && ancestor.block.number > prevUpdate.block.number) {\n            updates.unshift(ancestor)\n            ancestor = ancestor.prev ? memoryBlocks.blocks[ancestor.prev] : null\n          }\n\n          if (isFinalized) {\n            memoryBlocks.finalized = latest.block.hash\n            if (updates.length) {\n              const { blocks } = memoryBlocks\n              Object.keys(blocks).forEach((key) => {\n                if (blocks[key].block.number < updates[0].block.number)\n                  delete blocks[key]\n              })\n            }\n          }\n\n          if (prevUpdate === ancestor) return updates\n\n          // It's a re-org\n          return [\n            {\n              ...latest,\n              ...(prevUpdate.rootHash === latest.rootHash\n                ? {\n                    entries: prevUpdate.entries,\n                    deltas: null,\n                  }\n                : getDiff(prevUpdate.entries, latest.entries, patcher)),\n            },\n          ]\n        }),\n      )\n    }\n\n  const getFinalized$ = state(getBestOrFinalized(true))\n  const getBest$ = state(getBestOrFinalized(false))\n\n  return (pallet: string, entry: string, args: Array<any>, atBest: boolean) => {\n    const fn = atBest ? getBest$ : getFinalized$\n    const storageKey$ = blocks$.pipe(\n      take(1),\n      mergeMap(\n        (b) =>\n          b.runtimes[b.blocks.get(b[atBest ? \"best\" : \"finalized\"])!.runtime]\n            .runtime,\n      ),\n      map((runtime) =>\n        runtime.dynamicBuilder.buildStorage(pallet, entry).keys.enc(...args),\n      ),\n    )\n    return storageKey$.pipe(\n      take(1),\n      mergeMap((storageKey) => fn(pallet, entry, storageKey)),\n      map(({ block: { hash, number, parent }, deltas, entries }, idx) => {\n        const actualDeltas =\n          idx > 0 ? deltas : { deleted: [], upserted: entries }\n\n        return {\n          block: { hash, number, parent },\n          entries: entries.map(toDec),\n          deltas: actualDeltas && {\n            deleted: actualDeltas.deleted.map(toDec),\n            upserted: actualDeltas.upserted.map(toDec),\n          },\n        }\n      }),\n    )\n  }\n}\n\nconst toDec = <T>(x: { dec: T }): T => x.dec\n","import { firstValueFromWithSignal, isOptionalArg } from \"@/utils\"\nimport { ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport { map, mergeMap } from \"rxjs\"\nimport { CompatibilityFunctions, CompatibilityHelper } from \"./compatibility\"\nimport { compactNumber, _void } from \"@polkadot-api/substrate-bindings\"\nimport { PullOptions } from \"./types\"\n\ntype WithCallOptions<Args extends Array<any>> = Args[\"length\"] extends 0\n  ? [options?: PullOptions]\n  : [...args: Args, options?: PullOptions]\n\nexport type ViewFn<Unsafe, D, Args extends Array<any>, Payload> = {\n  /**\n   * Get `Payload` (Promise-based) for the view function.\n   *\n   * @param args  All keys needed for that runtime call.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   */\n  (...args: WithCallOptions<Args>): Promise<Payload>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nconst RUNTIME_NAMESPACE = \"RuntimeViewFunction\"\nconst RUNTIME_METHOD = \"execute_view_function\"\nconst RUNTIME_CALL_NAME = RUNTIME_NAMESPACE + \"_\" + RUNTIME_METHOD\n\nexport const createViewFnEntry = (\n  pallet: string,\n  entry: string,\n  chainHead: ChainHead$,\n  {\n    isCompatible,\n    getCompatibilityLevel,\n    compatibleRuntime$,\n    argsAreCompatible,\n    valuesAreCompatible,\n  }: CompatibilityHelper,\n): ViewFn<any, any, any, any> => {\n  const compatibilityError = () =>\n    new Error(`Incompatible runtime entry ViewFn(${pallet}.${entry})`)\n\n  const fn = (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: PullOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = compatibleRuntime$(chainHead, at).pipe(\n      mergeMap(([runtime, ctx]) => {\n        let apiCodec\n        try {\n          apiCodec = ctx.dynamicBuilder.buildRuntimeCall(\n            RUNTIME_NAMESPACE,\n            RUNTIME_METHOD,\n          )\n        } catch {\n          throw new Error(\n            `Runtime entry RuntimeCall(${RUNTIME_CALL_NAME}) not found`,\n          )\n        }\n        let viewCodec\n        try {\n          viewCodec = ctx.dynamicBuilder.buildViewFn(pallet, entry)\n        } catch {\n          throw new Error(`Runtime entry ViewFn(${pallet}.${entry}) not found`)\n        }\n        if (!argsAreCompatible(runtime, ctx, args)) throw compatibilityError()\n        const viewArgs = viewCodec.args.enc(args)\n        const arg = mergeUint8([\n          fromHex(\n            ctx.lookup.metadata.pallets\n              .find(({ name }) => name === pallet)!\n              .viewFns.find(({ name }) => name === entry)!.id,\n          ),\n          compactNumber.enc(viewArgs.length),\n          viewArgs,\n        ])\n\n        return chainHead.call$(at, RUNTIME_CALL_NAME, toHex(arg)).pipe(\n          map((v) => {\n            try {\n              const decoded = apiCodec.value.dec(v)\n              if (\n                !(\"success\" in decoded && \"value\" in decoded) ||\n                (!(\"type\" in decoded.value) && !(\"asBytes\" in decoded.value))\n              )\n                throw null\n              return decoded\n            } catch {\n              throw new Error(\n                `Unexpected RuntimeCall(${RUNTIME_CALL_NAME}) type`,\n              )\n            }\n          }),\n          map(({ success, value }) => {\n            if (!success) throw new Error(`ViewFn API Error: ${value.type}`)\n            const decoded = viewCodec.value.dec(value.asBytes())\n            if (!valuesAreCompatible(runtime, ctx, decoded))\n              throw compatibilityError()\n            return decoded\n          }),\n        )\n      }),\n      chainHead.withHodl(at),\n    )\n\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  return Object.assign(fn, { getCompatibilityLevel, isCompatible })\n}\n","import { JsonRpcProvider } from \"@polkadot-api/json-rpc-provider\"\nimport {\n  enumValueEntryPointNode,\n  runtimeCallEntryPoint,\n  singleValueEntryPoint,\n  storageEntryPoint,\n  voidEntryPointNode,\n} from \"@polkadot-api/metadata-compatibility\"\nimport {\n  ChainHead$,\n  RuntimeContext,\n  getObservableClient,\n  withArchive,\n} from \"@polkadot-api/observable-client\"\nimport { Binary, HexString } from \"@polkadot-api/substrate-bindings\"\nimport {\n  SubstrateClient,\n  createClient as createRawClient,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  catchError,\n  defer,\n  firstValueFrom,\n  from,\n  map,\n  shareReplay,\n} from \"rxjs\"\nimport {\n  CompatibilityToken,\n  OpType,\n  RuntimeToken,\n  compatibilityHelper,\n  createCompatibilityToken,\n  createRuntimeToken,\n  getCompatibilityApi,\n} from \"./compatibility\"\nimport { createConstantEntry } from \"./constants\"\nimport { ChainDefinition } from \"./descriptors\"\nimport { createEventEntry } from \"./event\"\nimport { createRuntimeCallEntry } from \"./runtime-call\"\nimport { createStorageEntry } from \"./storage\"\nimport { createTxEntry, submit, submit$ } from \"./tx\"\nimport type { AnyApi, PolkadotClient } from \"./types\"\nimport { createWatchEntries } from \"./watch-entries\"\nimport { createViewFnEntry } from \"./viewFns\"\nimport { firstValueFromWithSignal } from \"./utils\"\n\nconst HEX_REGEX = /^(?:0x)?((?:[0-9a-fA-F][0-9a-fA-F])+)$/\n\nconst createApi = <Unsafe extends true | false, D>(\n  compatibilityToken: Promise<CompatibilityToken | RuntimeToken>,\n  chainHead: ChainHead$,\n  broadcast$: (tx: string) => Observable<never>,\n): AnyApi<Unsafe, D> => {\n  const target = {}\n  const createProxy = (propCall: (prop: string) => unknown) =>\n    new Proxy(target, {\n      get(_, prop) {\n        return propCall(prop as string)\n      },\n    })\n  const createProxyPath = <T>(pathCall: (a: string, b: string) => T) => {\n    const cache: Record<string, Record<string, T>> = {}\n    return createProxy((a) => {\n      if (!cache[a]) cache[a] = {}\n      return createProxy((b) => {\n        if (!cache[a][b]) cache[a][b] = pathCall(a, b)\n        return cache[a][b]\n      })\n    }) as Record<string, Record<string, T>>\n  }\n\n  const getPallet = (ctx: RuntimeContext, name: string) =>\n    ctx.lookup.metadata.pallets.find((p) => p.name === name)\n\n  const getWatchEntries = createWatchEntries(\n    chainHead.pinnedBlocks$,\n    chainHead.storage$,\n    chainHead.withRuntime,\n  )\n  const query = createProxyPath((pallet, name) =>\n    createStorageEntry(\n      pallet,\n      name,\n      chainHead,\n      getWatchEntries,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getEntryPoint(OpType.Storage, pallet, name),\n        // TODO this is way sub-optimal. Needs some rethought - maybe a builder for entry points?.\n        (ctx) => {\n          const item = getPallet(ctx, pallet)?.storage?.items.find(\n            (s) => s.name === name,\n          )\n          return item == null ? null : storageEntryPoint(item)\n        },\n      ),\n    ),\n  )\n\n  const getEnumEntry = (\n    ctx: RuntimeContext,\n    side: \"args\" | \"values\",\n    id: number | undefined,\n    name: string,\n  ) => {\n    if (id == null) return null\n    const entry = ctx.lookup(id)\n    if (entry.type !== \"enum\") throw new Error(\"Expected enum\")\n\n    if (entry.value[name] == null) return null\n    const node = enumValueEntryPointNode(entry.value[name])\n    return {\n      args: side === \"args\" ? node : voidEntryPointNode,\n      values: side === \"args\" ? voidEntryPointNode : node,\n    }\n  }\n  const tx = createProxyPath((pallet, name) =>\n    createTxEntry(\n      pallet,\n      name,\n      chainHead,\n      broadcast$,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getEntryPoint(OpType.Tx, pallet, name),\n        (ctx) =>\n          getEnumEntry(ctx, \"args\", getPallet(ctx, pallet)?.calls?.type, name),\n      ),\n      true,\n    ),\n  )\n\n  const event = createProxyPath((pallet, name) =>\n    createEventEntry(\n      pallet,\n      name,\n      chainHead,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getEntryPoint(OpType.Event, pallet, name),\n        (ctx) =>\n          getEnumEntry(\n            ctx,\n            \"values\",\n            getPallet(ctx, pallet)?.events?.type,\n            name,\n          ),\n      ),\n    ),\n  )\n\n  const constants = createProxyPath((pallet, name) =>\n    createConstantEntry(\n      pallet,\n      name,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getEntryPoint(OpType.Const, pallet, name),\n        (ctx) => {\n          const item = getPallet(ctx, pallet)?.constants.find(\n            (c) => c.name === name,\n          )?.type\n          return item == null ? null : singleValueEntryPoint(item)\n        },\n      ),\n    ),\n  )\n\n  const apis = createProxyPath((api, method) =>\n    createRuntimeCallEntry(\n      api,\n      method,\n      chainHead,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getEntryPoint(OpType.Api, api, method),\n        (ctx) =>\n          runtimeCallEntryPoint(\n            ctx.lookup.metadata.apis\n              .find((a) => a.name === api)!\n              .methods.find((m) => m.name === method)!,\n          ),\n      ),\n    ),\n  )\n  const view = createProxyPath((pallet, entry) =>\n    createViewFnEntry(\n      pallet,\n      entry,\n      chainHead,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getEntryPoint(OpType.ViewFns, pallet, entry),\n        (ctx) =>\n          runtimeCallEntryPoint(\n            ctx.lookup.metadata.pallets\n              .find((a) => a.name === pallet)!\n              .viewFns.find((m) => m.name === entry)!,\n          ),\n      ),\n    ),\n  )\n\n  const _callDataTx = (\n    callData: Binary,\n    token: CompatibilityToken | RuntimeToken,\n  ) => {\n    const { lookup, dynamicBuilder } = getCompatibilityApi(token).runtime()\n    try {\n      const decoded = dynamicBuilder\n        .buildDefinition(lookup.call!)\n        .dec(callData.asBytes())\n      const pallet = decoded.type\n      const call = decoded.value.type\n      const args = decoded.value.value\n\n      return createTxEntry(\n        pallet,\n        call,\n        chainHead,\n        broadcast$,\n        compatibilityHelper(\n          compatibilityToken,\n          (r) => r.getEntryPoint(OpType.Tx, pallet, call),\n          (ctx) =>\n            getEnumEntry(\n              ctx,\n              \"args\",\n              getPallet(ctx, pallet)?.calls?.type,\n              call,\n            ),\n        ),\n        false,\n      )(args)\n    } catch {\n      throw new Error(\"createTx: invalid call data\")\n    }\n  }\n\n  return {\n    query,\n    txFromCallData: (\n      callData: Binary,\n      token?: CompatibilityToken | RuntimeToken,\n    ) =>\n      token\n        ? _callDataTx(callData, token)\n        : compatibilityToken.then((t) => _callDataTx(callData, t)),\n    tx,\n    event,\n    apis,\n    constants,\n    view,\n  } as any\n}\n\nexport type CreateClientOptions = Partial<{\n  getMetadata: (codeHash: HexString) => Promise<Uint8Array | null>\n  setMetadata: (codeHash: HexString, metadata: Uint8Array) => void\n}>\n\n/**\n * This is the top-level export for `polkadot-api`.\n *\n * @param provider  A `JsonRpcProvider` compliant with the [JSON-RPC\n *                  spec](https://paritytech.github.io/json-rpc-interface-spec/),\n *                  which must support the `chainHead`, `transaction` and\n *                  `chainSpec` groups.\n * @param options   - *(Optional)* An object that allows customization of\n *                  metadata handling.\n *                  You can supply functions to retrieve and/or persist the\n *                  metadata associated with runtime `codeHash` values:\n *\n *                  - `getMetadata`: A function that, given a `codeHash` (the\n *                  `:code:` hash),\n *                  returns a `Promise` resolving to a `Uint8Array`\n *                  representing the metadata,\n *                  or `null` if unavailable.\n *                  - `setMetadata`: A function that accepts a `codeHash` and\n *                  its associated `Uint8Array` metadata,\n *                  allowing you to persist the metadata (e.g., in a cache or\n *                  local store).\n * @example\n *\n *   import { getMetadata } from \"@polkadot-api/descriptors\"\n *   import { createClient } from \"polkadot-api\"\n *   import { getSmProvider } from \"polkadot-api/sm-provider\"\n *   import { chainSpec } from \"polkadot-api/chains/polkadot\"\n *   import { start } from \"polkadot-api/smoldot\"\n *\n *   const smoldot = start()\n *   const chain = await smoldot.addChain({ chainSpec })\n *\n *   // Connect to the polkadot relay chain.\n *   const client = createClient(getSmProvider(chain), { getMetadata })\n *\n */\nexport function createClient(\n  provider: JsonRpcProvider,\n  { getMetadata, setMetadata }: CreateClientOptions = {},\n): PolkadotClient {\n  const rawClient: SubstrateClient = createRawClient(provider)\n  const client = getObservableClient(rawClient, {\n    getMetadata: getMetadata\n      ? (codeHash: string) => from(getMetadata(codeHash))\n      : undefined,\n    setMetadata,\n  })\n  const { getChainSpecData } = rawClient\n\n  const { genesis$, ..._chainHead } = client.chainHead$()\n  const archive = client.archive(_chainHead.getRuntime$)\n  const chainHead: ChainHead$ = {\n    ..._chainHead,\n    genesis$: defer(getChainSpecData).pipe(\n      map(({ genesisHash }) => genesisHash),\n      catchError(() => genesis$),\n      shareReplay(1),\n    ),\n    storage$: withArchive(_chainHead.storage$, archive.storage$),\n    body$: withArchive(_chainHead.body$, archive.body$),\n    call$: withArchive(_chainHead.call$, archive.call$),\n    header$: withArchive(_chainHead.header$, archive.header$),\n    eventsAt$: withArchive(_chainHead.eventsAt$, archive.eventsAt$),\n    storageQueries$: withArchive(\n      _chainHead.storageQueries$,\n      archive.storageQueries$,\n    ),\n    getRuntimeContext$: withArchive(\n      _chainHead.getRuntimeContext$,\n      archive.getRuntimeContext$,\n    ),\n  }\n\n  const _request: <Reply = any, Params extends Array<any> = any[]>(\n    method: string,\n    params: Params,\n  ) => Promise<Reply> = rawClient.request\n\n  let runtimeToken: Promise<RuntimeToken>\n  const compatibilityToken = new WeakMap<\n    ChainDefinition,\n    Promise<CompatibilityToken<any>>\n  >()\n  const getChainToken = (chainDefinition: ChainDefinition) => {\n    const result =\n      compatibilityToken.get(chainDefinition) ||\n      createCompatibilityToken(chainDefinition, chainHead)\n    compatibilityToken.set(chainDefinition, result)\n    return result\n  }\n  const getRuntimeToken = <D>(): Promise<RuntimeToken<D>> =>\n    (runtimeToken ??= createRuntimeToken(chainHead))\n  const { broadcastTx$ } = client\n\n  const getMetadata$ = (at: HexString) =>\n    chainHead.getRuntimeContext$(at).pipe(map((ctx) => ctx.metadataRaw))\n\n  const result: PolkadotClient = {\n    getChainSpecData,\n\n    getMetadata$,\n    getMetadata: (atBlock: HexString, signal?: AbortSignal) =>\n      firstValueFromWithSignal(getMetadata$(atBlock), signal),\n\n    blocks$: chainHead.newBlocks$,\n    hodlBlock: (block: HexString) => chainHead.holdBlock(block, true),\n\n    finalizedBlock$: chainHead.finalized$,\n    getFinalizedBlock: () => firstValueFrom(chainHead.finalized$),\n\n    bestBlocks$: chainHead.bestBlocks$,\n    getBestBlocks: () => firstValueFrom(chainHead.bestBlocks$),\n\n    watchBlockBody: chainHead.body$,\n    getBlockBody: (hash: string) => firstValueFrom(chainHead.body$(hash)),\n\n    getBlockHeader: (hash?: string) =>\n      firstValueFrom(chainHead.header$(hash ?? null)),\n\n    submit: (...args) => submit(chainHead, broadcastTx$, ...args),\n    submitAndWatch: (tx) => submit$(chainHead, broadcastTx$, tx),\n\n    getTypedApi: <D extends ChainDefinition>(chainDefinition: D) => {\n      const token = getChainToken(chainDefinition)\n      return Object.assign(\n        createApi<false, D>(token, chainHead, broadcastTx$),\n        { compatibilityToken: token },\n      )\n    },\n\n    getUnsafeApi: <D>() => {\n      const token = getRuntimeToken()\n      return Object.assign(createApi<true, D>(token, chainHead, broadcastTx$), {\n        runtimeToken: token,\n      })\n    },\n\n    rawQuery: (key, { at, signal } = {}) =>\n      firstValueFromWithSignal(\n        chainHead.storage$(at ?? null, \"value\", () => {\n          const hex = key.match(HEX_REGEX)?.[1]\n          return hex ? `0x${hex}` : Binary.fromText(key).asHex()\n        }),\n        signal,\n      ),\n\n    destroy: () => {\n      chainHead.unfollow()\n      client.destroy()\n    },\n\n    _request,\n  }\n\n  ;(result as any).___INTERNAL_DO_NOT_USE = chainHead\n\n  return result\n}\n","import { getDynamicBuilder, getLookupFn } from \"@polkadot-api/metadata-builders\"\nimport { ChainDefinition, PlainDescriptor } from \"./descriptors\"\nimport { OfflineTxEntry } from \"./tx\"\nimport {\n  Binary,\n  Enum,\n  metadata as metadataCodec,\n  unifyMetadata,\n} from \"@polkadot-api/substrate-bindings\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport { OfflineApi } from \"./types\"\nimport { getSignExtensionsCreator } from \"./tx/signed-extensions\"\n\nconst createOfflineTxEntry = <\n  Arg extends {} | undefined,\n  Pallet extends string,\n  Name extends string,\n  Asset extends PlainDescriptor<any>,\n>(\n  pallet: Pallet,\n  name: Name,\n  metadataRaw: Uint8Array,\n  dynamicBuilder: ReturnType<typeof getDynamicBuilder>,\n  signExtensionCreator: ReturnType<typeof getSignExtensionsCreator>,\n): OfflineTxEntry<Arg, Pallet, Name, Asset> => {\n  let codecs\n  try {\n    codecs = dynamicBuilder.buildCall(pallet, name)\n  } catch {\n    throw new Error(`Runtime entry Tx(${pallet}.${name}) not found`)\n  }\n  const { location, codec } = codecs\n  const locationBytes = new Uint8Array(location)\n\n  return (arg: Arg) => {\n    const encodedData = Binary.fromBytes(\n      mergeUint8([locationBytes, codec.enc(arg)]),\n    )\n\n    return {\n      encodedData,\n      decodedCall: Enum(pallet, Enum(name, arg as any) as any),\n      sign: async (from, extensions) =>\n        toHex(\n          await from.signTx(\n            encodedData.asBytes(),\n            signExtensionCreator(extensions),\n            metadataRaw,\n            extensions.mortality.mortal\n              ? extensions.mortality.startAtBlock.height\n              : 0,\n          ),\n        ),\n    }\n  }\n}\n\n/**\n * Asynchronously create an instance of `OfflineApi`.\n * OfflineApi allows to create and sign transactions and access chain constants.\n *\n * @param chainDefinition  Pass descriptors from `@polkadot-api/descriptors`\n *                         generated by `papi` CLI.\n */\nexport const getOfflineApi: <D extends ChainDefinition>(\n  chainDefinition: D,\n) => Promise<OfflineApi<D>> = async ({ genesis: genesisHex, getMetadata }) => {\n  if (!genesisHex) throw new Error(\"Missing genesis hash\")\n  const genesis = fromHex(genesisHex)\n  const metadataRaw = await getMetadata()\n  const metadata = unifyMetadata(metadataCodec.dec(metadataRaw))\n  const lookupFn = getLookupFn(metadata)\n  const dynamicBuilder = getDynamicBuilder(lookupFn)\n  const signExtensionCreator = getSignExtensionsCreator(\n    genesis,\n    lookupFn,\n    dynamicBuilder,\n  )\n\n  const getPallet = (name: string) =>\n    metadata.pallets.find((p) => p.name === name)\n\n  const target = {}\n  const createProxy = (propCall: (prop: string) => unknown) =>\n    new Proxy(target, {\n      get(_, prop) {\n        return propCall(prop as string)\n      },\n    })\n\n  const createProxyPath = <T>(pathCall: (a: string, b: string) => T) => {\n    const cache: Record<string, Record<string, T>> = {}\n    return createProxy((a) => {\n      if (!cache[a]) cache[a] = {}\n      return createProxy((b) => {\n        if (!cache[a][b]) cache[a][b] = pathCall(a, b)\n        return cache[a][b]\n      })\n    }) as Record<string, Record<string, T>>\n  }\n\n  const constants = createProxyPath((pallet, name) => {\n    const constant = getPallet(pallet)?.constants.find((c) => c.name === name)\n    if (!constant)\n      throw new Error(`Runtime entry Constant(${pallet}.${name}) not found`)\n    return dynamicBuilder.buildConstant(pallet, name).dec(constant.value)\n  })\n\n  const tx = createProxyPath((pallet, name) =>\n    createOfflineTxEntry(\n      pallet,\n      name,\n      metadataRaw,\n      dynamicBuilder,\n      signExtensionCreator,\n    ),\n  )\n\n  return { constants, tx } as any\n}\n","import { type ChainDefinition } from \"@/descriptors\"\nimport {\n  getDynamicBuilder,\n  getLookupFn,\n  MetadataLookup,\n} from \"@polkadot-api/metadata-builders\"\nimport { decAnyMetadata, unifyMetadata } from \"@polkadot-api/substrate-bindings\"\nimport { TypedCodecs } from \"./types\"\n\nexport const createConstantEntry = (\n  palletName: string,\n  name: string,\n  lookup: MetadataLookup,\n  { buildConstant }: ReturnType<typeof getDynamicBuilder>,\n) => {\n  const pallet = lookup.metadata.pallets.find((p) => p.name === palletName)\n  const constant = pallet?.constants.find((c) => c.name === name)\n  if (constant == null)\n    throw new Error(`Runtime entry Constant(${palletName}.${name}) not found`)\n  return buildConstant(palletName, name)\n}\n\nconst withError =\n  <T>(\n    builder: (pallet: string, name: string) => T,\n    errName: string,\n  ): ((pallet: string, name: string) => T) =>\n  (pallet, name) => {\n    try {\n      return builder(pallet, name)\n    } catch {\n      throw new Error(`Runtime entry ${errName}(${pallet}.${name}) not found`)\n    }\n  }\n\n/**\n * It provides access the codecs of all possible on-chain interactions.\n *\n * @param descriptors  Pass descriptors from `@polkadot-api/descriptors`\n *                     generated by `papi` CLI.\n */\nexport const getTypedCodecs = async <D extends ChainDefinition>(\n  descriptors: D,\n): Promise<TypedCodecs<D>> => {\n  const metadata = unifyMetadata(\n    decAnyMetadata(await descriptors.getMetadata()),\n  )\n  const target = {}\n  const createProxy = (propCall: (prop: string) => unknown) =>\n    new Proxy(target, {\n      get(_, prop) {\n        return propCall(prop as string)\n      },\n    })\n  const createProxyPath = <T>(pathCall: (a: string, b: string) => T) => {\n    const cache: Record<string, Record<string, T>> = {}\n    return createProxy((a) => {\n      if (!cache[a]) cache[a] = {}\n      return createProxy((b) => {\n        if (!cache[a][b]) cache[a][b] = pathCall(a, b)\n        return cache[a][b]\n      })\n    }) as Record<string, Record<string, T>>\n  }\n\n  const lookup = getLookupFn(metadata)\n  const {\n    buildRuntimeCall,\n    buildStorage,\n    buildConstant,\n    buildCall,\n    buildEvent,\n    buildViewFn,\n  } = getDynamicBuilder(lookup)\n\n  return {\n    query: createProxyPath((...a) => {\n      const { value, args } = withError(buildStorage, \"Storage\")(...a)\n      return { value, args }\n    }),\n    tx: createProxyPath((...a) => withError(buildCall, \"Call\")(...a).codec),\n    event: createProxyPath(\n      (...args) => withError(buildEvent, \"Event\")(...args).codec,\n    ),\n    apis: createProxyPath(withError(buildRuntimeCall, \"Runtime API\")),\n    constants: createProxyPath(withError(buildConstant, \"Constant\")),\n    view: createProxyPath(withError(buildViewFn, \"ViewFn\")),\n  } as TypedCodecs<D>\n}\n"],"names":["OpType","Vector","EntryPointCodec","TypedefCodec","Tuple","filter","firstValueFrom","mapLookupToTypedef","descriptors","CompatibilityLevel","entryPointsAreCompatible","combineLatest","map","valueIsCompatibleWithDest","share","ReplaySubject","AbortError","noop","Observable","BehaviorSubject","Subject","switchAll","tap","concatMapEager","mergeMap","toHex","take","identity","shareReplay","pipe","combineLatestWith","distinctUntilChanged","from","BlockNotPinnedError","catchError","FixedSizeBinary","enhanceEncoder","Bytes","u16","Struct","compact","Option","value","additionalSigned","mapObject","key","fromHex","u8","u32","u64","of","scan","startWith","switchMap","Binary","defer","merge","race","takeWhile","ignoreElements","endWith","concat","EMPTY","lastValueFrom","AccountId","compactBn","Variant","_void","u128","arg","isCompatible","mergeUint8","throwError","getPolkadotSigner","Enum","state","isBestOrFinalizedBlock","takeUntil","withLatestFrom","delay","pairwise","compactNumber","storageEntryPoint","enumValueEntryPointNode","voidEntryPointNode","singleValueEntryPoint","runtimeCallEntryPoint","createRawClient","getObservableClient","withArchive","result","unifyMetadata","metadataCodec","getLookupFn","getDynamicBuilder","decAnyMetadata"],"mappings":"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"}