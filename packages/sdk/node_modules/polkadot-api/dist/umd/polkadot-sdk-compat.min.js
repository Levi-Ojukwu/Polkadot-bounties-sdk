(function(H,O){typeof exports=="object"&&typeof module<"u"?O(exports):typeof define=="function"&&define.amd?define(["exports"],O):(H=typeof globalThis<"u"?globalThis:H||self,O(H.papiPolkadotSdkCompat={}))})(this,(function(H){"use strict";const O=p=>{let a=null;const{send:o,disconnect:i}=p(r=>{a?.(JSON.parse(r))});return r=>(a=r,{send(f){o(JSON.stringify(f))},disconnect(){a=null,i()}})},C=p=>{let a=null;const{send:o,disconnect:i}=p(r=>{a?.(JSON.stringify(r))});return r=>(a=r,{send(f){o(JSON.parse(f))},disconnect(){a=null,i()}})},z=(...p)=>a=>C(p.reduce((o,i)=>i(o),O(a))),k={body:"",call:"",continue:"",follow:"",header:"",stopOperation:"",storage:"",unfollow:"",unpin:""},y={broadcast:"",stop:""},B={chainName:"",genesisHash:"",properties:""};Object.entries({chainHead:k,chainSpec:B,transaction:y}).forEach(([p,a])=>{Object.keys(a).forEach(o=>{a[o]=`${p}_v1_${o}`})});var W=Object.freeze({__proto__:null,chainHead:k,chainSpec:B,transaction:y});const L=p=>a=>{const{send:o,disconnect:i}=p(a);return{send:f=>{switch(f.method){case B.chainName:return o({...f,method:"system_chain"});case B.genesisHash:return o({...f,method:"chain_getBlockHash",params:[0]});case B.properties:return o({...f,method:"system_properties"})}o(f)},disconnect:i}},R=p=>a=>{const o=new Set,i=new Map,r=new Map,{send:f,disconnect:l}=p(c=>{if("id"in c){a(c);const{id:n,result:t}=c;if(o.has(n)){o.delete(n),i.set(t,new Set),r.set(t,new Map);return}}else{const{subscription:n}=c.params,t=i.get(n),s=r.get(n);if(t){const e=c.params.result,{event:d}=e;if(d==="initialized"&&e.finalizedBlockHashes.forEach(u=>{t.add(u)}),d==="newBlock"){const{parentBlockHash:u}=e;if(!t.has(u)){const _=s.get(u)??[];_.push(c),s.set(u,_);return}const h=e.blockHash;t.add(e.blockHash),a(c);const w=s.get(h);w&&(s.delete(h),w.forEach(_=>{t.add(_.params.result.blockHash),a(_)}));return}d==="stop"&&(t.delete(n),r.delete(n))}a(c)}});return{send:c=>{const n=c.params[0];switch(c.method){case k.follow:o.add(c.id);break;case k.unpin:const[t,s]=c.params;s.forEach(e=>{i.get(t)?.delete(e),r.get(t)?.delete(e)});break;case k.unfollow:i.delete(n),r.delete(n);break}f(c)},disconnect:l}},N=p=>({jsonrpc:"2.0",...p}),P=(p,a,o,i={})=>N({method:"chainHead_v1_followEvent",params:{subscription:p,result:{event:a,operationId:o,...i}}}),Q="__INNER_RQ_DesV",Z=p=>{let a=0;const o=new Map,i=({id:b,error:c,result:n})=>{const t=o.get(b);return t&&(o.delete(b),c?t(!1,c):t(!0,n)),!t};let r=()=>{};return[b=>{const{send:c,disconnect:n}=p(t=>{i(t)&&b(t)});return r=c,{send:r,disconnect:()=>{o.clear(),n()}}},(b,c,n,t)=>{const s=Q+a++;o.set(s,(e,d)=>{(e?n:t)(d)}),r(N({id:s,method:b,params:c}))}]},X="__INNER_OP_DesV";let Y=0;const V=p=>a=>{const[o,i]=Z(p),r=ee(i),f=new Map,l=new Map,{send:b,disconnect:c}=o(s=>{if("id"in s){const e=f.get(s.id);e&&(f.delete(s.id),s.result.result==="started"&&e(s.result.operationId))}else if(s.params){const{subscription:e,result:d}=s.params,{operationId:u}=d||{},h=l.get(e);h&&d.event==="stop"&&(h.forEach(_=>{_.cancel()}),l.delete(e));const w=h?.get(u);if(w)switch(d.event){case"operationInaccessible":case"operationError":w.cancel();break;case"operationStorageDone":if(w.isInnerDone)h.delete(u);else{w.isOutterDone=!0;return}}}a(s)}),n=(s,e,d)=>u=>{let h=()=>{};l.has(s)||l.set(s,new Map);const w=l.get(s),_={isOutterDone:!1,isInnerDone:!1,cancel:()=>{h()}};w.set(u,_);let v=0;const I=d.map(S=>r(S,e,E=>{a(P(s,"operationStorageItems",u,{items:E.map(([g,D])=>({key:g,value:D}))}))},E=>{h(),_.isOutterDone||b(N({method:"chainHead_v1_stopOperation",params:[u]})),a(P(s,"operationError",u,{error:typeof E=="string"?E:JSON.stringify(E)}))},()=>{++v===d.length&&(_.isOutterDone?(h(),a(P(s,"operationStorageDone",u))):_.isInnerDone=!0)}));h=()=>{w.delete(u),I.forEach(S=>S())}};return{send:s=>{switch(s.method){case k.storage:{const[e,d,u]=s.params,h=[],w=u.filter(v=>{const I=v.type==="descendantsValues";return I&&h.push(v.key),!I}),_=n(e,d,h);if(w.length)h.length&&f.set(s.id,_);else{const v=X+Y++;a(N({id:s.id,result:{result:"started",operationId:v}})),_(v),l.get(e).get(v).isOutterDone=!0;return}s.params[2]=w;break}case k.stopOperation:{const[e,d]=s.params,u=l.get(e)?.get(d);if(u&&(u.cancel(),u.isOutterDone))return;break}case k.unfollow:{const[e]=s.params;l.get(e)?.forEach(d=>d.cancel()),l.delete(e);break}}b(s)},disconnect:c}},ee=p=>(a,o,i,r,f)=>{let l=!0,b=!1,c=0;const n=e=>{l&&(l=!1,r(e))},t=1e3,s=e=>{p("state_getKeysPaged",[a,t,e||void 0,o],d=>{l&&(d.length>0&&(c++,p("state_queryStorageAt",[d,o],([{changes:u}])=>{l&&(c--,i(u),b&&!c&&f())},n)),d.length<t?(b=!0,c||f()):s(d.at(-1)))},n)};return s(),()=>{l=!1}},$=p=>a=>{const o=new Set,i=new Map,r=new Map,{send:f,disconnect:l}=p(c=>{if("id"in c){a(c);const{id:n,result:t}=c;if(o.has(n)){o.delete(n),i.set(t,new Set),r.set(t,new Map);return}}else{const{subscription:n}=c.params,t=i.get(n),s=r.get(n);if(t){const e=c.params.result,{event:d}=e;if(d==="initialized"&&e.finalizedBlockHashes.forEach(u=>{t.add(u)}),d==="finalized"&&(e.prunedBlockHashes=e.prunedBlockHashes.filter(u=>t.has(u))),d==="newBlock"){t.add(e.blockHash);const u=e.blockHash,h=s.get(u);if(h){s.delete(u),a(c),Promise.resolve().then(()=>{a(h)});return}}if(d==="bestBlockChanged"){const u=e.bestBlockHash;if(!t.has(u)){r.get(n).set(u,c);return}}d==="stop"&&(t.delete(n),r.delete(n))}a(c)}});return{send:c=>{const n=c.params[0];switch(c.method){case k.follow:o.add(c.id);break;case k.unpin:const[t,s]=c.params;s.forEach(e=>{i.get(t)?.delete(e),r.get(t)?.delete(e)});break;case k.unfollow:i.delete(n),r.delete(n);break}f(c)},disconnect:l}},te=new Set(["BodyDone","CallDone","StorageDone","Inaccessible","Error"].map(p=>"operation"+p)),j=p=>te.has(p.params?.result?.event),A=p=>a=>{const o=new Set,i=new Map,r=new Map,f=new Map,{send:l,disconnect:b}=p(n=>{if("id"in n){a(n);const{id:t,result:s}=n;if(o.has(t)){o.delete(t),r.set(s,new Set),f.set(s,new Map);return}const e=i.get(t);if(e!==void 0){i.delete(t);const d=n.result?.operationId;if(d!==void 0&&r.has(e)){const u=r.get(e);u.add(d);const h=f.get(e)?.get(d);h&&(h.forEach(a),f.get(e).delete(d),j(h.at(-1))&&u.delete(d))}}}else{const{subscription:t,result:s}=n.params,e=r.get(t);if(e){const{operationId:d}=n.params.result;if(d!==void 0)if(e.has(d))j(n)&&e.delete(d);else{const u=f.get(t),h=u.get(d)??[];h.push(n),u.set(d,h);return}else s?.event==="stop"&&(r.delete(t),f.delete(t))}a(n)}});return{send:n=>{const t=n.params[0];switch(n.method){case k.follow:o.add(n.id);break;case k.body:case k.call:case k.storage:i.set(n.id,t);break;case k.unfollow:r.delete(t),f.delete(t);break;case k.stopOperation:r.get(t)?.delete(n.params[1])}l(n)},disconnect:b}},m=p=>a=>p(o=>{const i=o.params?.result;if(!("id"in o)&&i){const{prunedBlockHashes:r,finalizedBlockHash:f,event:l}=i;l==="finalized"&&Array.isArray(r)?i.prunedBlockHashes=[...new Set(i.prunedBlockHashes)]:l==="initialized"&&f&&(i.finalizedBlockHashes=[i.finalizedBlockHash],delete i.finalizedBlockHash)}a(o)}),G=p=>a=>{const{send:o,disconnect:i}=p(a);return{send:f=>{const{method:l,params:b,id:c,...n}=f;l==k.unpin&&b&&Array.isArray(b[1])?b[1].forEach((t,s)=>{o({...n,id:s===0?c:`${c}-patched-${s}`,method:l,params:[b[0],t]})}):o(f)},disconnect:i}},T=p=>({jsonrpc:"2.0",...p}),[M]=y.stop.split("_"),q="unstable",x="rpc_methods",J="__INTERNAL_ID",K=p=>a=>{let o=!0,i=[],r=e=>{i.push(e)};const f=({id:e,result:d,error:u})=>{if(e!==J||!o)return;if(!d){if(console.error(u),t<4){setTimeout(s,200);return}d={methods:[]}}const h=new Set(d.methods),w={};[k,B,y].forEach(I=>{Object.values(I).forEach(S=>{if(h.has(S))w[S]=S;else{const[E,,g]=S.split("_"),D=`${E}_${q}_${g}`;if(h.has(D))w[S]=D,h.delete(D),h.add(S);else if(w[S]=null,E===M){let F;const se=S==="stop"?"unwatch":"submitAndWatch";[M+"Watch",M].find(oe=>["v1",q].find(ie=>h.has(F=`${oe}_${ie}_${se}`)))&&(w[S]=F,h.add(S))}}})}),l=a;const _=({method:I,...S})=>{if(I===x){Promise.resolve().then(()=>{a(T({id:S.id,result:{methods:[...h]}}))});return}const E=w[I];E===null?I.split("_")[2]==="follow"?(n(),r({method:I,...S})):Promise.resolve().then(()=>{a({error:{code:-32603,message:`Method not found: ${I}`},id:S.id})}):b({method:E||I,...S})},v=[...i];i=[];for(let I=0;o&&I<v.length;I++)_(v[I]);o&&(r=_)};let l=f;const{send:b,disconnect:c}=p(e=>{l(e)}),n=()=>{o=!0,i=[],r=e=>{i.push(e)},l=f,s()};let t=0;const s=()=>{t++,b(T({id:J,method:x,params:[]}))};return s(),{send:e=>{r(e)},disconnect(){o=!1,r=l=()=>{},i=[],c()}}},U=p=>a=>{let o=0;const i=new Map,{send:r,disconnect:f}=p(l=>{const{id:b}=l;i.has(b)&&(l.id=i.get(b),i.delete(b)),a(l)});return{send:l=>{"id"in l&&(i.set(o,l.id),l.id=o++),r(l)},disconnect:f}},ne=z(U,K,A,G,m,R,$,L,V);H.fixDescendantValues=V,H.fixPrematureBlocks=R,H.fixUnorderedBlocks=$,H.fixUnorderedEvents=A,H.fromParsed=C,H.methods=W,H.parsed=z,H.patchChainHeadEvents=m,H.toParsed=O,H.translate=K,H.unpinHash=G,H.withNumericIds=U,H.withPolkadotSdkCompat=ne}));
