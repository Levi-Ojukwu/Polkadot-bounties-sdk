(function(C,v){typeof exports=="object"&&typeof module<"u"?v(exports):typeof define=="function"&&define.amd?define(["exports"],v):(C=typeof globalThis<"u"?globalThis:C||self,v(C.papiWsProviderWeb={}))})(this,(function(C){"use strict";const v=t=>JSON.stringify({jsonrpc:"2.0",...t}),M=new Set(["v1","unstable"].map(t=>`chainHead_${t}_unfollow`)),W=t=>{let e={type:1,pending:[]};const s=o=>{if(e.type===0){const n=JSON.parse(o);if("id"in n)"result"in n&&e.onGoingRequests.get(n.id)?.type===0&&e.activeChainHeads.add(n.result),e.onGoingRequests.delete(n.id);else if("params"in n){const{subscription:r,result:c}=n.params;c?.event==="stop"&&e.activeChainHeads.delete(r)}}e.type!==2&&t(o)},i=o=>{if(e.type===2)return;if(e.type===1){e.pending.push(o);return}const n=JSON.parse(o);if(M.has(n.method)&&e.activeChainHeads.delete(n.params[0]),"id"in n){const{method:r,id:c}=n,d=r.startsWith("chainHead")?r.endsWith("follow")?{type:0,msg:o}:{type:1,id:c}:{type:2,msg:o};e.onGoingRequests.set(c,d)}e.connection.send(o)};return{send:i,disconnect:()=>{e.type!==2&&(e.type===0&&e.connection.disconnect(),e={type:2})},connect:o=>{if(e.type!==1)throw new Error("Nonesense");const{pending:n}=e,r=new Map,c=new Set;e={type:0,connection:o(s,()=>{e={type:1,pending:[]},c.forEach(h=>{s(v({params:{subscription:h,result:{event:"stop",internal:!0}}}))}),c.clear();for(const h of r.values())h.type===1?s(v({id:h.id,error:{code:-32603,message:"Internal error"},internal:!0})):i(h.msg);r.clear()}),onGoingRequests:r,activeChainHeads:c},n.forEach(i)}}},A=t=>e=>{let s=W(e);const i=()=>{t().then(o=>{if(s)s.connect((n,r)=>o(n,()=>{r(),i()}));else try{o(()=>{},()=>{}).disconnect()}catch{}},()=>{s&&setTimeout(i,0)})};return i(),{send:o=>{s?.send(o)},disconnect:()=>{s?.disconnect(),s=null}}};var f=(t=>(t[t.CONNECTING=0]="CONNECTING",t[t.CONNECTED=1]="CONNECTED",t[t.ERROR=2]="ERROR",t[t.CLOSE=3]="CLOSE",t))(f||{});const _={};["v1","unstable"].forEach(t=>{_[`chainHead_${t}_follow`]="follow",_[`chainHead_${t}_unfollow`]="unfollow"});const P=(t,e)=>{const s=new Set,i=new Map,o=new Set;let n;return Object.assign(c=>{const{send:d,disconnect:h}=t(u=>{const p=JSON.parse(u);if("id"in p){const{id:a,result:E}=p;if(a===n&&(n=void 0,E&&!E.methods.some(m=>{const[l,,L]=m.split("_");return l==="chainHead"&&L==="follow"}))){c(u),e();return}const y=i.get(a);if(y){if(i.delete(a),s.has(E)){s.delete(E);return}o.add(E);const m=o.size+i.size;if(m>2)console.warn(`Too many chainHead follow subscriptions (${m})`);else if(p.error){console.warn(`chainHead follow failed on the ${m} sub`),e(),i.set(a,y),d(y);return}}}else{const{subscription:a,result:E}=p.params;E?.event==="stop"&&(o.has(a)?o.delete(a):s.add(a))}c(u)});return{send(u){const p=JSON.parse(u);p.method==="rpc_methods"&&(n=p.id);const a=_[p.method];a==="follow"?i.set(p.id,u):a==="unfollow"&&o.delete(p.params[0]),d(u)},disconnect:h}},{cleanup:()=>{s.clear(),i.clear(),o.clear()}})},k={type:f.ERROR,event:{type:"timeout"}},S=()=>{},G={onStatusChanged:S,innerEnhancer:t=>t,timeout:5e3},$=t=>t.map(e=>typeof e=="string"?[e]:[e.uri,e.protocol]),j=(t,e)=>{const{onStatusChanged:s,innerEnhancer:i,timeout:o}={...G,...e},n=$(Array.isArray(t)?t:[t]),r=e?.websocketClass??globalThis.WebSocket;if(!r)throw new Error("Missing WebSocket class");let c=0,d,h=null,u=S,p=S;const a=P(A(async()=>{const[y,m]=h||n[c++%t.length];h=null;const l=new r(y,m),L=()=>{try{l.addEventListener("error",S,{once:!0}),l.close()}catch{}};s(d={type:f.CONNECTING,uri:y,protocols:m}),await new Promise((b,O)=>{const T=()=>{N(),b()},R=g=>{N(),g==null&&L(),console.error(`Unable to connect to ${y}${m?", protocols: "+m:""}`),s(d={type:g?f.ERROR:f.CLOSE,event:g}),setTimeout(O,g?300:0,g)},H=o!==1/0?setTimeout(()=>{N(),L(),s(d=k),O(k.event)},o):void 0,N=()=>{clearTimeout(H),l.removeEventListener("error",R),l.removeEventListener("open",T)};l.addEventListener("open",T),l.addEventListener("error",R),u=()=>{R(null)}}),s(d={type:f.CONNECTED,uri:y,protocols:m});let I;const J=i(b=>(I=b,{send:O=>{l.send(O)},disconnect:()=>{u()}}));return(b,O)=>{const T=J(b),R=w=>{typeof w.data=="string"&&I(w.data)},H=w=>z=>{console.warn(`WS halt (${w})`),s(d={type:w,event:z}),O()},N=H(f.ERROR),g=H(f.CLOSE);return l.addEventListener("message",R),l.addEventListener("error",N),l.addEventListener("close",g),u=w=>{p(),u=S,l.removeEventListener("message",R),l.removeEventListener("error",N),l.removeEventListener("close",g),L(),w&&g({})},T}}),()=>{E()});p=a.cleanup,delete a.cleanup;const E=(...y)=>{d.type!==f.CLOSE&&(y.length&&(h=y),d.type!==f.ERROR&&u(!0))};return Object.assign(a,{switch:E,getStatus:()=>d})},q=(t=>(...e)=>{let s=[],{timeout:i,innerEnhancer:o,onStatusChanged:n}=G;const[r]=e;return e.length===1&&typeof r=="object"&&!Array.isArray(r)?(s=$(r.endpoints),n=r.onStatusChanged??S,i=r.timeout??i,o=r.innerEnhancer??(c=>c)):(typeof e[1]=="function"&&(n=e[1]),Array.isArray(r)?s=$(r):(s=[[r]],e[1]&&e[1]!==n&&(s[0][1]=e[1]),e[2]&&(n=e[2]))),j(s.map(c=>c.length===1?c[0]:{uri:c[0],protocol:c[1]}),{websocketClass:t,onStatusChanged:n,timeout:i,innerEnhancer:o})})(WebSocket);C.WsEvent=f,C.getWsProvider=q}));
