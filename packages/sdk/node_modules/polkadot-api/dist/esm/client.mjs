import { enumValueEntryPointNode, voidEntryPointNode, storageEntryPoint, singleValueEntryPoint, runtimeCallEntryPoint } from '@polkadot-api/metadata-compatibility';
import { getObservableClient, withArchive } from '@polkadot-api/observable-client';
import { Binary } from '@polkadot-api/substrate-bindings';
import { createClient as createClient$1 } from '@polkadot-api/substrate-client';
import { from, defer, map, catchError, shareReplay, firstValueFrom } from 'rxjs';
import { createRuntimeToken, createCompatibilityToken, getCompatibilityApi, compatibilityHelper, OpType } from './compatibility.mjs';
import { createConstantEntry } from './constants.mjs';
import { createEventEntry } from './event.mjs';
import { createRuntimeCallEntry } from './runtime-call.mjs';
import { createStorageEntry } from './storage.mjs';
import { createTxEntry } from './tx/tx.mjs';
import { createWatchEntries } from './watch-entries.mjs';
import { createViewFnEntry } from './viewFns.mjs';
import './utils/shareLatest.mjs';
import { firstValueFromWithSignal } from './utils/firstValueFromWithSignal.mjs';
import 'rxjs/operators';
import { submit$, submit } from './tx/submit-fns.mjs';

const HEX_REGEX = /^(?:0x)?((?:[0-9a-fA-F][0-9a-fA-F])+)$/;
const createApi = (compatibilityToken, chainHead, broadcast$) => {
  const target = {};
  const createProxy = (propCall) => new Proxy(target, {
    get(_, prop) {
      return propCall(prop);
    }
  });
  const createProxyPath = (pathCall) => {
    const cache = {};
    return createProxy((a) => {
      if (!cache[a]) cache[a] = {};
      return createProxy((b) => {
        if (!cache[a][b]) cache[a][b] = pathCall(a, b);
        return cache[a][b];
      });
    });
  };
  const getPallet = (ctx, name) => ctx.lookup.metadata.pallets.find((p) => p.name === name);
  const getWatchEntries = createWatchEntries(
    chainHead.pinnedBlocks$,
    chainHead.storage$,
    chainHead.withRuntime
  );
  const query = createProxyPath(
    (pallet, name) => createStorageEntry(
      pallet,
      name,
      chainHead,
      getWatchEntries,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.Storage, pallet, name),
        // TODO this is way sub-optimal. Needs some rethought - maybe a builder for entry points?.
        (ctx) => {
          const item = getPallet(ctx, pallet)?.storage?.items.find(
            (s) => s.name === name
          );
          return item == null ? null : storageEntryPoint(item);
        }
      )
    )
  );
  const getEnumEntry = (ctx, side, id, name) => {
    if (id == null) return null;
    const entry = ctx.lookup(id);
    if (entry.type !== "enum") throw new Error("Expected enum");
    if (entry.value[name] == null) return null;
    const node = enumValueEntryPointNode(entry.value[name]);
    return {
      args: side === "args" ? node : voidEntryPointNode,
      values: side === "args" ? voidEntryPointNode : node
    };
  };
  const tx = createProxyPath(
    (pallet, name) => createTxEntry(
      pallet,
      name,
      chainHead,
      broadcast$,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.Tx, pallet, name),
        (ctx) => getEnumEntry(ctx, "args", getPallet(ctx, pallet)?.calls?.type, name)
      ),
      true
    )
  );
  const event = createProxyPath(
    (pallet, name) => createEventEntry(
      pallet,
      name,
      chainHead,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.Event, pallet, name),
        (ctx) => getEnumEntry(
          ctx,
          "values",
          getPallet(ctx, pallet)?.events?.type,
          name
        )
      )
    )
  );
  const constants = createProxyPath(
    (pallet, name) => createConstantEntry(
      pallet,
      name,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.Const, pallet, name),
        (ctx) => {
          const item = getPallet(ctx, pallet)?.constants.find(
            (c) => c.name === name
          )?.type;
          return item == null ? null : singleValueEntryPoint(item);
        }
      )
    )
  );
  const apis = createProxyPath(
    (api, method) => createRuntimeCallEntry(
      api,
      method,
      chainHead,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.Api, api, method),
        (ctx) => runtimeCallEntryPoint(
          ctx.lookup.metadata.apis.find((a) => a.name === api).methods.find((m) => m.name === method)
        )
      )
    )
  );
  const view = createProxyPath(
    (pallet, entry) => createViewFnEntry(
      pallet,
      entry,
      chainHead,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.ViewFns, pallet, entry),
        (ctx) => runtimeCallEntryPoint(
          ctx.lookup.metadata.pallets.find((a) => a.name === pallet).viewFns.find((m) => m.name === entry)
        )
      )
    )
  );
  const _callDataTx = (callData, token) => {
    const { lookup, dynamicBuilder } = getCompatibilityApi(token).runtime();
    try {
      const decoded = dynamicBuilder.buildDefinition(lookup.call).dec(callData.asBytes());
      const pallet = decoded.type;
      const call = decoded.value.type;
      const args = decoded.value.value;
      return createTxEntry(
        pallet,
        call,
        chainHead,
        broadcast$,
        compatibilityHelper(
          compatibilityToken,
          (r) => r.getEntryPoint(OpType.Tx, pallet, call),
          (ctx) => getEnumEntry(
            ctx,
            "args",
            getPallet(ctx, pallet)?.calls?.type,
            call
          )
        ),
        false
      )(args);
    } catch {
      throw new Error("createTx: invalid call data");
    }
  };
  return {
    query,
    txFromCallData: (callData, token) => token ? _callDataTx(callData, token) : compatibilityToken.then((t) => _callDataTx(callData, t)),
    tx,
    event,
    apis,
    constants,
    view
  };
};
function createClient(provider, { getMetadata, setMetadata } = {}) {
  const rawClient = createClient$1(provider);
  const client = getObservableClient(rawClient, {
    getMetadata: getMetadata ? (codeHash) => from(getMetadata(codeHash)) : void 0,
    setMetadata
  });
  const { getChainSpecData } = rawClient;
  const { genesis$, ..._chainHead } = client.chainHead$();
  const archive = client.archive(_chainHead.getRuntime$);
  const chainHead = {
    ..._chainHead,
    genesis$: defer(getChainSpecData).pipe(
      map(({ genesisHash }) => genesisHash),
      catchError(() => genesis$),
      shareReplay(1)
    ),
    storage$: withArchive(_chainHead.storage$, archive.storage$),
    body$: withArchive(_chainHead.body$, archive.body$),
    call$: withArchive(_chainHead.call$, archive.call$),
    header$: withArchive(_chainHead.header$, archive.header$),
    eventsAt$: withArchive(_chainHead.eventsAt$, archive.eventsAt$),
    storageQueries$: withArchive(
      _chainHead.storageQueries$,
      archive.storageQueries$
    ),
    getRuntimeContext$: withArchive(
      _chainHead.getRuntimeContext$,
      archive.getRuntimeContext$
    )
  };
  const _request = rawClient.request;
  let runtimeToken;
  const compatibilityToken = /* @__PURE__ */ new WeakMap();
  const getChainToken = (chainDefinition) => {
    const result2 = compatibilityToken.get(chainDefinition) || createCompatibilityToken(chainDefinition, chainHead);
    compatibilityToken.set(chainDefinition, result2);
    return result2;
  };
  const getRuntimeToken = () => runtimeToken ?? (runtimeToken = createRuntimeToken(chainHead));
  const { broadcastTx$ } = client;
  const getMetadata$ = (at) => chainHead.getRuntimeContext$(at).pipe(map((ctx) => ctx.metadataRaw));
  const result = {
    getChainSpecData,
    getMetadata$,
    getMetadata: (atBlock, signal) => firstValueFromWithSignal(getMetadata$(atBlock), signal),
    blocks$: chainHead.newBlocks$,
    hodlBlock: (block) => chainHead.holdBlock(block, true),
    finalizedBlock$: chainHead.finalized$,
    getFinalizedBlock: () => firstValueFrom(chainHead.finalized$),
    bestBlocks$: chainHead.bestBlocks$,
    getBestBlocks: () => firstValueFrom(chainHead.bestBlocks$),
    watchBlockBody: chainHead.body$,
    getBlockBody: (hash) => firstValueFrom(chainHead.body$(hash)),
    getBlockHeader: (hash) => firstValueFrom(chainHead.header$(hash ?? null)),
    submit: (...args) => submit(chainHead, broadcastTx$, ...args),
    submitAndWatch: (tx) => submit$(chainHead, broadcastTx$, tx),
    getTypedApi: (chainDefinition) => {
      const token = getChainToken(chainDefinition);
      return Object.assign(
        createApi(token, chainHead, broadcastTx$),
        { compatibilityToken: token }
      );
    },
    getUnsafeApi: () => {
      const token = getRuntimeToken();
      return Object.assign(createApi(token, chainHead, broadcastTx$), {
        runtimeToken: token
      });
    },
    rawQuery: (key, { at, signal } = {}) => firstValueFromWithSignal(
      chainHead.storage$(at ?? null, "value", () => {
        const hex = key.match(HEX_REGEX)?.[1];
        return hex ? `0x${hex}` : Binary.fromText(key).asHex();
      }),
      signal
    ),
    destroy: () => {
      chainHead.unfollow();
      client.destroy();
    },
    _request
  };
  result.___INTERNAL_DO_NOT_USE = chainHead;
  return result;
}

export { createClient };
//# sourceMappingURL=client.mjs.map
