{"version":3,"file":"compatibility.mjs","sources":["../../src/compatibility.ts"],"sourcesContent":["import { MetadataLookup } from \"@polkadot-api/metadata-builders\"\nimport {\n  CompatibilityCache,\n  CompatibilityLevel,\n  EntryPoint,\n  EntryPointCodec,\n  TypedefCodec,\n  TypedefNode,\n  entryPointsAreCompatible,\n  mapLookupToTypedef,\n  valueIsCompatibleWithDest,\n} from \"@polkadot-api/metadata-compatibility\"\nimport { ChainHead$, RuntimeContext } from \"@polkadot-api/observable-client\"\nimport { Tuple, Vector } from \"@polkadot-api/substrate-bindings\"\nimport { Observable, combineLatest, filter, firstValueFrom, map } from \"rxjs\"\nimport { ChainDefinition } from \"./descriptors\"\n\nexport class RuntimeToken<D = unknown> {\n  private constructor() {}\n\n  // @ts-ignore\n  protected _runtime(value: D) {}\n}\n\nexport class CompatibilityToken<D = unknown> {\n  private constructor() {}\n\n  // @ts-ignore\n  protected _compatibility(value: D) {}\n}\n\ninterface RuntimeTokenApi {\n  runtime: () => RuntimeContext\n}\ninterface CompatibilityTokenApi extends RuntimeTokenApi {\n  typedefNodes: TypedefNode[]\n  getEntryPoint: (opType: OpType, pallet: string, name: string) => EntryPoint\n}\nconst compatibilityTokenApi = new WeakMap<\n  CompatibilityToken,\n  CompatibilityTokenApi\n>()\nconst runtimeTokenApi = new WeakMap<RuntimeToken, RuntimeTokenApi>()\nexport const getCompatibilityApi = (\n  token: RuntimeToken | CompatibilityToken,\n): RuntimeTokenApi | CompatibilityTokenApi =>\n  token instanceof RuntimeToken\n    ? runtimeTokenApi.get(token)!\n    : compatibilityTokenApi.get(token)!\n\nexport const enum OpType {\n  Storage = \"storage\",\n  Tx = \"tx\",\n  Event = \"events\",\n  Const = \"constants\",\n  ViewFns = \"viewFns\",\n  Api = \"apis\",\n}\n\nconst EntryPointsCodec = Vector(EntryPointCodec)\nconst TypedefsCodec = Vector(TypedefCodec)\nconst TypesCodec = Tuple(EntryPointsCodec, TypedefsCodec)\n\nexport const createCompatibilityToken = <D extends ChainDefinition>(\n  chainDefinition: D,\n  chainHead: ChainHead$,\n): Promise<CompatibilityToken<D>> => {\n  const awaitedRuntime = new Promise<() => RuntimeContext>(async (resolve) => {\n    const loadedRuntime$ = chainHead.runtime$.pipe(filter((v) => v != null))\n\n    let latest = await firstValueFrom(loadedRuntime$)\n    loadedRuntime$.subscribe((v) => (latest = v))\n\n    resolve(() => latest)\n  })\n\n  const promise = Promise.all([\n    chainDefinition.metadataTypes.then(TypesCodec.dec),\n    chainDefinition.descriptors,\n    awaitedRuntime,\n  ]).then(([[entryPoints, typedefNodes], descriptors, runtime]) => {\n    const token = new (CompatibilityToken as any)()\n    compatibilityTokenApi.set(token, {\n      runtime,\n      getEntryPoint(opType, pallet, name) {\n        const idx = descriptors[opType]?.[pallet]?.[name]\n        if (idx == null)\n          throw new Error(\n            `Descriptor for ${opType} ${pallet}.${name} does not exist`,\n          )\n        return entryPoints[idx]\n      },\n      typedefNodes,\n    })\n\n    return token\n  })\n\n  return promise\n}\n\nexport const createRuntimeToken = <D>(\n  chainHead: ChainHead$,\n): Promise<RuntimeToken<D>> => {\n  const awaitedRuntime = new Promise<() => RuntimeContext>(async (resolve) => {\n    const loadedRuntime$ = chainHead.runtime$.pipe(filter((v) => v != null))\n\n    let latest = await firstValueFrom(loadedRuntime$)\n    loadedRuntime$.subscribe((v) => (latest = v))\n\n    resolve(() => latest)\n  })\n\n  const promise = awaitedRuntime.then((runtime) => {\n    const token = new (RuntimeToken as any)()\n    runtimeTokenApi.set(token, {\n      runtime,\n    })\n    return token\n  })\n\n  return promise\n}\n\n// metadataRaw -> cache\nconst metadataCache = new WeakMap<\n  Uint8Array,\n  {\n    compat: CompatibilityCache\n    lookup: MetadataLookup\n    typeNodes: (TypedefNode | null)[]\n  }\n>()\nconst getMetadataCache = (ctx: RuntimeContext) => {\n  if (!metadataCache.has(ctx.metadataRaw)) {\n    metadataCache.set(ctx.metadataRaw, {\n      compat: new Map(),\n      lookup: ctx.lookup,\n      typeNodes: [],\n    })\n  }\n  return metadataCache.get(ctx.metadataRaw)!\n}\nexport const compatibilityHelper = (\n  descriptors: Promise<RuntimeToken | CompatibilityToken>,\n  getDescriptorEntryPoint: (descriptorApi: CompatibilityTokenApi) => EntryPoint,\n  getRuntimeEntryPoint: (ctx: RuntimeContext) => EntryPoint | null,\n) => {\n  const getRuntimeTypedef = (ctx: RuntimeContext, id: number) => {\n    const cache = getMetadataCache(ctx)\n    return (cache.typeNodes[id] ||= mapLookupToTypedef(cache.lookup(id)))\n  }\n\n  function getCompatibilityLevels(\n    descriptors: CompatibilityToken | RuntimeToken,\n    /**\n     * The `Runtime` of runtimeWithDescriptors already has a RuntimeContext,\n     * which is the runtime of the finalized block.\n     * But on some cases, the user wants to perform an action on a specific\n     * block hash, which has a different RuntimeContext.\n     */\n    ctx?: RuntimeContext,\n  ) {\n    if (descriptors instanceof RuntimeToken) {\n      return {\n        args: CompatibilityLevel.Identical,\n        values: CompatibilityLevel.Identical,\n      }\n    }\n    const compatibilityApi = compatibilityTokenApi.get(descriptors)!\n    ctx ||= compatibilityApi.runtime()\n    const runtimeEntryPoint = getRuntimeEntryPoint(ctx)\n    if (runtimeEntryPoint == null)\n      return {\n        args: CompatibilityLevel.Incompatible,\n        values: CompatibilityLevel.Incompatible,\n      }\n    const descriptorNodes = compatibilityApi.typedefNodes\n\n    const cache = getMetadataCache(ctx)\n\n    const descriptorEntryPoint = getDescriptorEntryPoint(compatibilityApi)\n    const result = entryPointsAreCompatible(\n      descriptorEntryPoint,\n      (id) => descriptorNodes[id],\n      runtimeEntryPoint,\n      (id) => getRuntimeTypedef(ctx, id),\n      cache.compat,\n    )\n    return {\n      args: result.args.level,\n      values: result.values.level,\n    }\n  }\n\n  const getCompatibilityLevel = withOptionalToken(descriptors, (runtime) =>\n    minCompatLevel(getCompatibilityLevels(runtime)),\n  )\n  const isCompatible = withOptionalToken(\n    descriptors,\n    (threshold: CompatibilityLevel, runtime) =>\n      getCompatibilityLevel(runtime) >= threshold,\n  )\n\n  const compatibleRuntime$ = (chainHead: ChainHead$, hash: string | null) =>\n    combineLatest([descriptors, chainHead.getRuntimeContext$(hash)])\n\n  const withCompatibleRuntime =\n    <T>(chainHead: ChainHead$, mapper: (x: T) => string) =>\n    (\n      source$: Observable<T>,\n    ): Observable<[T, CompatibilityToken | RuntimeToken, RuntimeContext]> =>\n      combineLatest([\n        source$.pipe(chainHead.withRuntime(mapper)),\n        descriptors,\n      ]).pipe(map(([[x, ctx], descriptors]) => [x, descriptors, ctx]))\n\n  const argsAreCompatible = (\n    descriptors: CompatibilityToken | RuntimeToken,\n    ctx: RuntimeContext,\n    args: unknown,\n  ) => {\n    if (descriptors instanceof RuntimeToken) return true\n    const levels = getCompatibilityLevels(descriptors, ctx)\n    if (levels.args === CompatibilityLevel.Incompatible) return false\n    if (levels.args > CompatibilityLevel.Partial) return true\n    // Although technically args could still be compatible, if the output will be incompatible we might as well just return false to skip sending the request.\n    if (levels.values === CompatibilityLevel.Incompatible) return false\n\n    const entryPoint = getRuntimeEntryPoint(ctx)\n    if (entryPoint == null) return false\n\n    return valueIsCompatibleWithDest(\n      entryPoint.args,\n      (id) => getRuntimeTypedef(ctx, id),\n      args,\n    )\n  }\n  const valuesAreCompatible = (\n    descriptors: CompatibilityToken | RuntimeToken,\n    ctx: RuntimeContext,\n    values: unknown,\n  ) => {\n    if (descriptors instanceof RuntimeToken) return true\n    const level = getCompatibilityLevels(descriptors, ctx).values\n    if (level === CompatibilityLevel.Incompatible) return false\n    if (level > CompatibilityLevel.Partial) return true\n\n    const compatibilityApi = compatibilityTokenApi.get(descriptors)!\n\n    const entryPoint = getDescriptorEntryPoint(compatibilityApi)\n\n    return valueIsCompatibleWithDest(\n      entryPoint.values,\n      (id) => compatibilityApi.typedefNodes[id],\n      values,\n    )\n  }\n\n  return {\n    isCompatible,\n    getCompatibilityLevel,\n    getCompatibilityLevels,\n    descriptors,\n    withCompatibleRuntime,\n    compatibleRuntime$,\n    argsAreCompatible,\n    valuesAreCompatible,\n    getRuntimeTypedef,\n  }\n}\nexport type CompatibilityHelper = ReturnType<typeof compatibilityHelper>\n\nexport const minCompatLevel = (levels: {\n  args: CompatibilityLevel\n  values: CompatibilityLevel\n}) => Math.min(levels.args, levels.values)\n\nconst withOptionalToken =\n  <T, D, A extends [...any[], CompatibilityToken | RuntimeToken]>(\n    compatibilityToken: Promise<CompatibilityToken<D> | RuntimeToken<D>>,\n    fn: (...args: A) => T,\n  ): WithOptionalRuntime<T, D, A extends [...infer R, any] ? R : []> =>\n  (...args: any): any => {\n    const lastElement = args.at(-1)\n    if (\n      lastElement instanceof CompatibilityToken ||\n      lastElement instanceof RuntimeToken\n    ) {\n      return fn(...args)\n    }\n    return compatibilityToken.then((token) => (fn as any)(...args, token))\n  }\n\nexport type WithOptionalRuntime<T, D, A extends any[]> = {\n  /**\n   * Returns the result after waiting for the runtime to load.\n   */\n  (...args: A): Promise<T>\n  /**\n   * Returns the result synchronously with the loaded runtime.\n   */\n  (...args: [...A, runtime: CompatibilityToken<D> | RuntimeToken<D>]): T\n}\n\nexport interface CompatibilityFunctions<D> {\n  /**\n   * Returns the `CompatibilityLevel` for this call comparing the descriptors\n   * generated on dev time with the current live metadata.\n   */\n  getCompatibilityLevel(): Promise<CompatibilityLevel>\n  /**\n   * Returns the `CompatibilityLevel` for this call comparing the descriptors\n   * generated on dev time with the current live metadata.\n   *\n   * @param compatibilityToken  CompatibilityToken awaited from\n   *                            typedApi.compatibilityToken.\n   */\n  getCompatibilityLevel(\n    compatibilityToken: CompatibilityToken<D>,\n  ): CompatibilityLevel\n\n  /**\n   * Returns whether this call is compatible based on the CompatibilityLevel\n   * threshold.\n   *\n   * @param threshold  CompatibilityLevel threshold to use, inclusive.\n   */\n  isCompatible(threshold: CompatibilityLevel): Promise<boolean>\n\n  /**\n   * Returns whether this call is compatible based on the CompatibilityLevel\n   * threshold.\n   *\n   * @param threshold           CompatibilityLevel threshold to use,\n   *                            inclusive.\n   * @param compatibilityToken  CompatibilityToken awaited from\n   *                            typedApi.compatibilityToken.\n   */\n  isCompatible(\n    threshold: CompatibilityLevel,\n    compatibilityToken: CompatibilityToken<D>,\n  ): boolean\n}\n"],"names":["OpType","descriptors"],"mappings":"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"}