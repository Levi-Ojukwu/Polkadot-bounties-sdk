import '@polkadot-api/observable-client';
import './utils/shareLatest.mjs';
import { mergeMap, map } from 'rxjs';
import { firstValueFromWithSignal } from './utils/firstValueFromWithSignal.mjs';
import { isOptionalArg } from './utils/optional-arg.mjs';
import 'rxjs/operators';
import { mergeUint8, fromHex, toHex } from '@polkadot-api/utils';
import { compactNumber } from '@polkadot-api/substrate-bindings';

const RUNTIME_NAMESPACE = "RuntimeViewFunction";
const RUNTIME_METHOD = "execute_view_function";
const RUNTIME_CALL_NAME = RUNTIME_NAMESPACE + "_" + RUNTIME_METHOD;
const createViewFnEntry = (pallet, entry, chainHead, {
  isCompatible,
  getCompatibilityLevel,
  compatibleRuntime$,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const compatibilityError = () => new Error(`Incompatible runtime entry ViewFn(${pallet}.${entry})`);
  const fn = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = compatibleRuntime$(chainHead, at).pipe(
      mergeMap(([runtime, ctx]) => {
        let apiCodec;
        try {
          apiCodec = ctx.dynamicBuilder.buildRuntimeCall(
            RUNTIME_NAMESPACE,
            RUNTIME_METHOD
          );
        } catch {
          throw new Error(
            `Runtime entry RuntimeCall(${RUNTIME_CALL_NAME}) not found`
          );
        }
        let viewCodec;
        try {
          viewCodec = ctx.dynamicBuilder.buildViewFn(pallet, entry);
        } catch {
          throw new Error(`Runtime entry ViewFn(${pallet}.${entry}) not found`);
        }
        if (!argsAreCompatible(runtime, ctx, args)) throw compatibilityError();
        const viewArgs = viewCodec.args.enc(args);
        const arg = mergeUint8([
          fromHex(
            ctx.lookup.metadata.pallets.find(({ name }) => name === pallet).viewFns.find(({ name }) => name === entry).id
          ),
          compactNumber.enc(viewArgs.length),
          viewArgs
        ]);
        return chainHead.call$(at, RUNTIME_CALL_NAME, toHex(arg)).pipe(
          map((v) => {
            try {
              const decoded = apiCodec.value.dec(v);
              if (!("success" in decoded && "value" in decoded) || !("type" in decoded.value) && !("asBytes" in decoded.value))
                throw null;
              return decoded;
            } catch {
              throw new Error(
                `Unexpected RuntimeCall(${RUNTIME_CALL_NAME}) type`
              );
            }
          }),
          map(({ success, value }) => {
            if (!success) throw new Error(`ViewFn API Error: ${value.type}`);
            const decoded = viewCodec.value.dec(value.asBytes());
            if (!valuesAreCompatible(runtime, ctx, decoded))
              throw compatibilityError();
            return decoded;
          })
        );
      }),
      chainHead.withHodl(at)
    );
    return firstValueFromWithSignal(result$, signal);
  };
  return Object.assign(fn, { getCompatibilityLevel, isCompatible });
};

export { createViewFnEntry };
//# sourceMappingURL=viewFns.mjs.map
