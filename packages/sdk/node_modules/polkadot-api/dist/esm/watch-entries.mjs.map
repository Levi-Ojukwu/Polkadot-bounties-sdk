{"version":3,"file":"watch-entries.mjs","sources":["../../src/watch-entries.ts"],"sourcesContent":["import { HexString } from \"@polkadot-api/substrate-bindings\"\nimport type {\n  PinnedBlocks,\n  BlockInfo,\n  ChainHead$,\n  RuntimeContext,\n} from \"@polkadot-api/observable-client\"\nimport {\n  BlockNotPinnedError,\n  isBestOrFinalizedBlock,\n} from \"@polkadot-api/observable-client\"\nimport {\n  catchError,\n  combineLatest,\n  delay,\n  distinctUntilChanged,\n  EMPTY,\n  filter,\n  map,\n  merge,\n  mergeMap,\n  Observable,\n  of,\n  pairwise,\n  startWith,\n  take,\n  takeUntil,\n  throwError,\n  withLatestFrom,\n} from \"rxjs\"\nimport { selfDependent, lossLessExhaustMap } from \"@/utils\"\nimport { state } from \"@rx-state/core\"\n\ninterface StorageEntry {\n  key: HexString\n  value: HexString\n  dec: {\n    args: Array<any>\n    value: any\n  }\n}\n\ntype Deltas = {\n  upserted: Array<StorageEntry>\n  deleted: Array<StorageEntry>\n}\n\ninterface MemoryBlock {\n  prev: HexString | null\n  block: BlockInfo\n  rootHash: string\n  entries: Array<StorageEntry>\n  deltas: Deltas | null\n}\n\ntype MemoryBlocks = {\n  blocks: Record<HexString, MemoryBlock>\n  finalized: HexString\n}\n\nconst getDiff = (\n  _prev: Array<StorageEntry>,\n  _current: Array<StorageEntry>,\n  patch: (input: StorageEntry) => StorageEntry,\n): Pick<MemoryBlock, \"entries\" | \"deltas\"> => {\n  const current = new Map(_current.map((x) => [x.key, x]))\n  const prev = new Map(_prev.map((x) => [x.key, x]))\n\n  const upserted: Map<string, StorageEntry> = new Map()\n  const deleted: Array<StorageEntry> = []\n\n  _current.forEach((value) => {\n    const { key } = value\n    const prevVal = prev.get(key)\n    if (!prevVal || prevVal.value !== value.value)\n      upserted.set(key, patch(value))\n  })\n\n  _prev.forEach((x) => {\n    if (!current.has(x.key)) deleted.push(x)\n  })\n\n  return {\n    deltas: {\n      deleted,\n      upserted: [...upserted.values()],\n    },\n    entries: _current.map(({ key }) => upserted.get(key) ?? prev.get(key)!),\n  }\n}\n\nconst findPrevious = (\n  start: HexString,\n  state: MemoryBlocks[\"blocks\"],\n  pinned: PinnedBlocks,\n  includeStart = false,\n) => {\n  try {\n    let target = includeStart ? start : pinned.blocks.get(start)!.parent\n    while (target && !state[target]) target = pinned.blocks.get(target)!.parent!\n\n    if (!target) return null\n    return state[target]\n  } catch {\n    return null\n  }\n}\n\nconst getPatcherFromRuntime =\n  (pallet: string, entry: string) => (runtime: RuntimeContext) => {\n    const { keys, value } = runtime.dynamicBuilder.buildStorage(pallet, entry)\n    return (x: StorageEntry) => {\n      x.dec = {\n        value: value.dec(x.value),\n        args: keys.dec(x.key),\n      }\n      return x\n    }\n  }\n\nexport const createWatchEntries = (\n  blocks$: Observable<PinnedBlocks>,\n  storage: ChainHead$[\"storage$\"],\n  withRuntime: ChainHead$[\"withRuntime\"],\n) => {\n  const getMemoryBlocks$ = state(\n    (pallet: string, entry: string, storageKey: string) => {\n      const getPatcher = getPatcherFromRuntime(pallet, entry)\n      const getNextMemoryBlock$ = (\n        prev: MemoryBlock | null,\n        block: BlockInfo,\n      ): Observable<MemoryBlock> => {\n        const isNotCanonical$ = isBestOrFinalizedBlock(\n          blocks$,\n          block.hash,\n        ).pipe(\n          filter((x) => !x),\n          take(1),\n        )\n\n        return storage(\n          block.hash,\n          \"closestDescendantMerkleValue\",\n          () => storageKey,\n        ).pipe(\n          mergeMap((rootHash) => {\n            if (rootHash === prev?.rootHash)\n              return of({\n                ...prev,\n                block,\n                deltas: null,\n                prev: prev.block.hash,\n              })\n\n            return storage(\n              block.hash,\n              \"descendantsValues\",\n              () => storageKey,\n            ).pipe(\n              withRuntime(() => block.hash),\n              map(\n                ([entries, runtimeCtx]) =>\n                  [entries, getPatcher(runtimeCtx)] as const,\n              ),\n              map(\n                ([entries, patcher]): MemoryBlock => ({\n                  prev: prev && prev.block.hash,\n                  rootHash: rootHash!,\n                  block,\n                  ...getDiff(\n                    prev?.entries ?? [],\n                    entries as StorageEntry[],\n                    patcher,\n                  ),\n                }),\n              ),\n            )\n          }),\n          takeUntil(isNotCanonical$),\n          catchError((e) =>\n            e instanceof BlockNotPinnedError ? EMPTY : throwError(() => e),\n          ),\n        )\n      }\n\n      const initial$ = blocks$.pipe(\n        distinctUntilChanged((a, b) => a.finalized === b.finalized),\n        lossLessExhaustMap(({ blocks, finalized }) =>\n          getNextMemoryBlock$(null, blocks.get(finalized)!),\n        ),\n        take(1),\n        map(\n          (x): MemoryBlocks => ({\n            blocks: { [x.block.hash]: x },\n            finalized: x.block.hash,\n          }),\n        ),\n      )\n\n      const [_memoryBlocks$, connectMemoryBlocks] =\n        selfDependent<MemoryBlocks>()\n      const updates$ = blocks$.pipe(\n        distinctUntilChanged((a, b) => a.best === b.best),\n        withLatestFrom(_memoryBlocks$),\n        lossLessExhaustMap(([pinned, memoryBlocks]) => {\n          const { best } = pinned\n          const { blocks } = memoryBlocks\n          let target = !blocks[best] ? best : null\n          if (!target) return EMPTY\n\n          const previous = findPrevious(target, blocks, pinned)\n          if (previous)\n            return getNextMemoryBlock$(\n              previous,\n              pinned.blocks.get(target)!,\n            ).pipe(\n              map((x) => {\n                blocks[target!] = x\n                return memoryBlocks\n              }),\n            )\n\n          // This means that there has been a stop event that the pinned-blocks\n          // couldn't recover from. Therefore, we must \"start over\"\n          target = pinned.finalized\n          return getNextMemoryBlock$(\n            blocks[memoryBlocks.finalized],\n            pinned.blocks.get(target)!,\n          ).pipe(\n            map((x) => {\n              x.prev = null\n              return {\n                blocks: { [target]: x },\n                finalized: target,\n              }\n            }),\n          )\n        }),\n      )\n\n      return merge(initial$, updates$).pipe(connectMemoryBlocks())\n    },\n  )\n\n  const getBestOrFinalized =\n    (isFinalized: boolean) =>\n    (pallet: string, entry: string, storageKey: string) => {\n      const memoryBlocks$ = getMemoryBlocks$(pallet, entry, storageKey)\n      const getPatcher = getPatcherFromRuntime(pallet, entry)\n\n      const prop = isFinalized ? \"finalized\" : \"best\"\n\n      return combineLatest([\n        memoryBlocks$.pipe(delay(0)),\n        blocks$.pipe(distinctUntilChanged((a, b) => a[prop] === b[prop])),\n      ]).pipe(\n        map(([state, blocks]) =>\n          findPrevious(blocks[prop], state.blocks, blocks, true),\n        ),\n        filter(Boolean),\n        distinctUntilChanged(),\n        startWith(null),\n        pairwise(),\n        withLatestFrom(memoryBlocks$),\n        withRuntime(([[, _latest]]) => _latest!.block.hash),\n        map(\n          ([[[prevUpdate, latest], memoryBlocks], runtimeCtx]) =>\n            [\n              prevUpdate,\n              latest!,\n              memoryBlocks,\n              getPatcher(runtimeCtx),\n            ] as const,\n        ),\n        mergeMap(([prevUpdate, latest, memoryBlocks, patcher]) => {\n          if (!prevUpdate) return [latest]\n\n          let ancestor: MemoryBlock | null = latest\n          const updates: Array<MemoryBlock> = []\n          while (ancestor && ancestor.block.number > prevUpdate.block.number) {\n            updates.unshift(ancestor)\n            ancestor = ancestor.prev ? memoryBlocks.blocks[ancestor.prev] : null\n          }\n\n          if (isFinalized) {\n            memoryBlocks.finalized = latest.block.hash\n            if (updates.length) {\n              const { blocks } = memoryBlocks\n              Object.keys(blocks).forEach((key) => {\n                if (blocks[key].block.number < updates[0].block.number)\n                  delete blocks[key]\n              })\n            }\n          }\n\n          if (prevUpdate === ancestor) return updates\n\n          // It's a re-org\n          return [\n            {\n              ...latest,\n              ...(prevUpdate.rootHash === latest.rootHash\n                ? {\n                    entries: prevUpdate.entries,\n                    deltas: null,\n                  }\n                : getDiff(prevUpdate.entries, latest.entries, patcher)),\n            },\n          ]\n        }),\n      )\n    }\n\n  const getFinalized$ = state(getBestOrFinalized(true))\n  const getBest$ = state(getBestOrFinalized(false))\n\n  return (pallet: string, entry: string, args: Array<any>, atBest: boolean) => {\n    const fn = atBest ? getBest$ : getFinalized$\n    const storageKey$ = blocks$.pipe(\n      take(1),\n      mergeMap(\n        (b) =>\n          b.runtimes[b.blocks.get(b[atBest ? \"best\" : \"finalized\"])!.runtime]\n            .runtime,\n      ),\n      map((runtime) =>\n        runtime.dynamicBuilder.buildStorage(pallet, entry).keys.enc(...args),\n      ),\n    )\n    return storageKey$.pipe(\n      take(1),\n      mergeMap((storageKey) => fn(pallet, entry, storageKey)),\n      map(({ block: { hash, number, parent }, deltas, entries }, idx) => {\n        const actualDeltas =\n          idx > 0 ? deltas : { deleted: [], upserted: entries }\n\n        return {\n          block: { hash, number, parent },\n          entries: entries.map(toDec),\n          deltas: actualDeltas && {\n            deleted: actualDeltas.deleted.map(toDec),\n            upserted: actualDeltas.upserted.map(toDec),\n          },\n        }\n      }),\n    )\n  }\n}\n\nconst toDec = <T>(x: { dec: T }): T => x.dec\n"],"names":["state"],"mappings":"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"}