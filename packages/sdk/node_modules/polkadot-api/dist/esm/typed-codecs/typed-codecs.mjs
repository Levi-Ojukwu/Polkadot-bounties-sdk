import { getLookupFn, getDynamicBuilder } from '@polkadot-api/metadata-builders';
import { unifyMetadata, decAnyMetadata } from '@polkadot-api/substrate-bindings';

const withError = (builder, errName) => (pallet, name) => {
  try {
    return builder(pallet, name);
  } catch {
    throw new Error(`Runtime entry ${errName}(${pallet}.${name}) not found`);
  }
};
const getTypedCodecs = async (descriptors) => {
  const metadata = unifyMetadata(
    decAnyMetadata(await descriptors.getMetadata())
  );
  const target = {};
  const createProxy = (propCall) => new Proxy(target, {
    get(_, prop) {
      return propCall(prop);
    }
  });
  const createProxyPath = (pathCall) => {
    const cache = {};
    return createProxy((a) => {
      if (!cache[a]) cache[a] = {};
      return createProxy((b) => {
        if (!cache[a][b]) cache[a][b] = pathCall(a, b);
        return cache[a][b];
      });
    });
  };
  const lookup = getLookupFn(metadata);
  const {
    buildRuntimeCall,
    buildStorage,
    buildConstant,
    buildCall,
    buildEvent,
    buildViewFn
  } = getDynamicBuilder(lookup);
  return {
    query: createProxyPath((...a) => {
      const { value, args } = withError(buildStorage, "Storage")(...a);
      return { value, args };
    }),
    tx: createProxyPath((...a) => withError(buildCall, "Call")(...a).codec),
    event: createProxyPath(
      (...args) => withError(buildEvent, "Event")(...args).codec
    ),
    apis: createProxyPath(withError(buildRuntimeCall, "Runtime API")),
    constants: createProxyPath(withError(buildConstant, "Constant")),
    view: createProxyPath(withError(buildViewFn, "ViewFn"))
  };
};

export { getTypedCodecs };
//# sourceMappingURL=typed-codecs.mjs.map
