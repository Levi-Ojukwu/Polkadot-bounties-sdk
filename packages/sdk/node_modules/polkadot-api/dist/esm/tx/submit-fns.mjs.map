{"version":3,"file":"submit-fns.mjs","sources":["../../../src/tx/submit-fns.ts"],"sourcesContent":["import {\n  Binary,\n  HexString,\n  ResultPayload,\n} from \"@polkadot-api/substrate-bindings\"\nimport {\n  EMPTY,\n  Observable,\n  concat,\n  defer,\n  distinctUntilChanged,\n  endWith,\n  filter,\n  ignoreElements,\n  lastValueFrom,\n  map,\n  merge,\n  mergeMap,\n  of,\n  race,\n  take,\n  takeWhile,\n} from \"rxjs\"\nimport {\n  BlockInfo,\n  ChainHead$,\n  PinnedBlocks,\n  SystemEvent,\n} from \"@polkadot-api/observable-client\"\nimport { AnalyzedBlock } from \"@polkadot-api/observable-client\"\nimport { TxEvent, TxEventsPayload, TxFinalizedPayload } from \"./types\"\nimport { continueWith } from \"@/utils\"\nimport { fromHex, toHex } from \"@polkadot-api/utils\"\n\nconst computeState = (\n  analized$: Observable<AnalyzedBlock>,\n  blocks$: Observable<PinnedBlocks>,\n) =>\n  new Observable<\n    | {\n        found: true\n        hash: string\n        number: number\n        index: number\n        events: any\n      }\n    | { found: false; validity: ResultPayload<any, any> | null }\n  >((observer) => {\n    const analyzedBlocks = new Map<string, AnalyzedBlock>()\n    let pinnedBlocks: PinnedBlocks\n    let latestState:\n      | {\n          found: true\n          hash: string\n          number: number\n          index: number\n          events: any\n        }\n      | { found: false; validity: ResultPayload<any, any> | null }\n\n    const computeNextState = () => {\n      let current: string = pinnedBlocks.best\n      let analyzed: AnalyzedBlock | undefined = analyzedBlocks.get(current)\n      let analyzedNumber = pinnedBlocks.blocks.get(current)!.number\n\n      while (!analyzed) {\n        const block = pinnedBlocks.blocks.get(current)\n        if (!block) break\n        analyzed = analyzedBlocks.get((current = block.parent))\n        analyzedNumber--\n      }\n\n      if (!analyzed) return // this shouldn't happen, though\n\n      const isFinalized =\n        analyzedNumber <=\n        pinnedBlocks.blocks.get(pinnedBlocks.finalized)!.number\n\n      const found = analyzed.found.type\n      if (found && latestState?.found && latestState.hash === analyzed.hash) {\n        if (isFinalized) observer.complete()\n        return\n      }\n\n      observer.next(\n        (latestState = analyzed.found.type\n          ? {\n              found: found as true,\n              hash: analyzed.hash,\n              number: analyzedNumber,\n              index: analyzed.found.index,\n              events: analyzed.found.events,\n            }\n          : {\n              found: found as false,\n              validity: analyzed.found.validity,\n            }),\n      )\n\n      if (isFinalized) {\n        if (found) observer.complete()\n        else if (analyzed.found.validity?.success === false)\n          observer.error(new InvalidTxError(analyzed.found.validity.value))\n      }\n    }\n\n    const subscription = blocks$\n      .pipe(\n        distinctUntilChanged(\n          (a, b) => a.finalized === b.finalized && a.best === b.best,\n        ),\n      )\n      .subscribe({\n        next: (pinned: PinnedBlocks) => {\n          pinnedBlocks = pinned\n          if (analyzedBlocks.size === 0) return\n          computeNextState()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      })\n\n    subscription.add(\n      analized$.subscribe({\n        next: (block) => {\n          analyzedBlocks.set(block.hash, block)\n          computeNextState()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      }),\n    )\n\n    return subscription\n  }).pipe(distinctUntilChanged((a, b) => a === b))\n\nconst getTxSuccessFromSystemEvents = (\n  systemEvents: Array<SystemEvent>,\n  txIdx: number,\n): Omit<TxEventsPayload, \"block\"> => {\n  const events = systemEvents\n    .filter((x) => x.phase.type === \"ApplyExtrinsic\" && x.phase.value === txIdx)\n    .map((x) => ({ ...x.event, topics: x.topics }))\n\n  const lastEvent = events[events.length - 1]\n  if (\n    lastEvent.type === \"System\" &&\n    lastEvent.value.type === \"ExtrinsicFailed\"\n  ) {\n    return {\n      ok: false,\n      events,\n      dispatchError: lastEvent.value.value.dispatch_error,\n    }\n  }\n\n  return { ok: true, events }\n}\n\n/*\ntype TransactionValidityError = Enum<{\n  Invalid: Enum<{\n    Call: undefined\n    Payment: undefined\n    Future: undefined\n    Stale: undefined\n    BadProof: undefined\n    AncientBirthBlock: undefined\n    ExhaustsResources: undefined\n    Custom: number\n    BadMandatory: undefined\n    MandatoryValidation: undefined\n    BadSigner: undefined\n  }>\n  Unknown: Enum<{\n    CannotLookup: undefined\n    NoUnsignedValidator: undefined\n    Custom: number\n  }>\n}>\n*/\nexport class InvalidTxError extends Error {\n  error: any // likely to be a `TransactionValidityError`\n  constructor(e: any) {\n    super(\n      JSON.stringify(\n        e,\n        (_, value) => {\n          if (typeof value === \"bigint\") return value.toString()\n          return value instanceof Binary ? value.asHex() : value\n        },\n        2,\n      ),\n    )\n    this.name = \"InvalidTxError\"\n    this.error = e\n  }\n}\n\nexport const submit$ = (\n  chainHead: ChainHead$,\n  broadcastTx$: (tx: string) => Observable<never>,\n  tx: HexString,\n  emitSign = false,\n): Observable<TxEvent> =>\n  chainHead.hasher$.pipe(\n    mergeMap((hasher) => {\n      const txHash = toHex(hasher(fromHex(tx)))\n      const getTxEvent = <\n        Type extends TxEvent[\"type\"],\n        Rest extends Omit<TxEvent & { type: Type }, \"type\" | \"txHash\">,\n      >(\n        type: Type,\n        rest: Rest,\n      ): TxEvent & { type: Type } =>\n        ({\n          type,\n          txHash,\n          ...rest,\n        }) as any\n\n      const pinnedBlocks = chainHead.pinnedBlocks$.state\n      const getHeightFromMortality = (\n        mortality:\n          | {\n              mortal: false\n            }\n          | {\n              mortal: true\n              period: number\n              phase: number\n            },\n      ) => {\n        if (!mortality.mortal) return 0\n        const { phase, period } = mortality\n        const topNumber = pinnedBlocks.blocks.get(pinnedBlocks.best)!.number\n        return (\n          Math.floor((Math.max(topNumber, phase) - phase) / period) * period +\n          phase\n        )\n      }\n\n      const getTipsFromHeight = (height: number): BlockInfo[] => {\n        let tips: BlockInfo[] = [...pinnedBlocks.blocks.values()].filter(\n          (block) => !block.unpinnable && !block.children.size,\n        )\n        const higherTip = Math.max(...tips.map(({ number }) => number))\n        // take only tips \"with chance to become canonical\"\n        tips = tips.filter(({ number }) => number >= higherTip - 1)\n\n        const finalized = pinnedBlocks.blocks.get(pinnedBlocks.finalized)!\n        tips = finalized.children ? [finalized, ...tips] : tips\n\n        return tips.filter((x) => x.number >= height)\n      }\n\n      const validateTxAt$ = ({ hash }: BlockInfo) =>\n        chainHead.validateTx$(hash, tx)\n      const validate$: Observable<never> = defer(() =>\n        pinnedBlocks.finalizedRuntime.runtime.pipe(\n          map((r) => r.getMortalityFromTx(tx)),\n          map(getHeightFromMortality),\n          map(getTipsFromHeight),\n          mergeMap((blocksToValidate) => {\n            let err: InvalidTxError\n            return merge(\n              ...blocksToValidate.map((b) =>\n                race(\n                  validateTxAt$(b),\n                  chainHead.finalized$.pipe(\n                    takeWhile((finalized) => {\n                      if (finalized.number < b.number) return true\n                      let curr = finalized\n                      while (curr.number > b.number) {\n                        const parent = pinnedBlocks.blocks.get(curr.parent)\n                        if (!parent) return false\n                        curr = parent\n                      }\n                      return curr.hash === finalized.hash\n                    }),\n                    ignoreElements(),\n                    endWith({ success: null }),\n                  ),\n                ),\n              ),\n            ).pipe(\n              filter((v, idx) => {\n                // save first error\n                if (v.success === false) err ??= new InvalidTxError(v.value)\n\n                if (v.success) return true\n                if (idx === blocksToValidate.length - 1 && err) throw err\n                return false\n              }),\n              take(1),\n            )\n          }),\n          ignoreElements(),\n        ),\n      )\n\n      const track$ = new Observable<AnalyzedBlock>((observer) => {\n        const subscription = chainHead.trackTx$(tx).subscribe(observer)\n        subscription.add(\n          broadcastTx$(tx).subscribe({\n            error(e) {\n              observer.error(e)\n            },\n          }),\n        )\n        return subscription\n      })\n\n      const bestBlockState$ = computeState(\n        track$,\n        chainHead.pinnedBlocks$,\n      ).pipe(\n        map((x) => {\n          if (!x.found)\n            return getTxEvent(\"txBestBlocksState\", {\n              found: false,\n              isValid: x.validity?.success !== false,\n            })\n\n          return getTxEvent(\"txBestBlocksState\", {\n            found: true,\n            block: {\n              index: x.index,\n              number: x.number,\n              hash: x.hash,\n            },\n            ...getTxSuccessFromSystemEvents(x.events, x.index),\n          })\n        }),\n      )\n\n      return concat(\n        emitSign ? of(getTxEvent(\"signed\", {})) : EMPTY,\n        validate$,\n        of(getTxEvent(\"broadcasted\", {})),\n        bestBlockState$.pipe(\n          continueWith(({ found, type, ...rest }) =>\n            found ? of(getTxEvent(\"finalized\", rest as any)) : EMPTY,\n          ),\n        ),\n      )\n    }),\n  )\n\nexport const submit = async (\n  chainHead: ChainHead$,\n  broadcastTx$: (tx: string) => Observable<never>,\n  transaction: HexString,\n  _at?: HexString,\n): Promise<TxFinalizedPayload> =>\n  lastValueFrom(submit$(chainHead, broadcastTx$, transaction)).then((x) => {\n    if (x.type !== \"finalized\") throw null\n    const result: TxFinalizedPayload = { ...x }\n    delete (result as any).type\n    return result\n  })\n"],"names":[],"mappings":"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"}