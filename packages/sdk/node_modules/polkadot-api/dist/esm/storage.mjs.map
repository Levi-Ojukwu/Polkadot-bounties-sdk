{"version":3,"file":"storage.mjs","sources":["../../src/storage.ts"],"sourcesContent":["import {\n  firstValueFromWithSignal,\n  isOptionalArg,\n  lossLessExhaustMap,\n} from \"@/utils\"\nimport { CompatibilityLevel } from \"@polkadot-api/metadata-compatibility\"\nimport {\n  BlockInfo,\n  BlockNotPinnedError,\n  ChainHead$,\n  RuntimeContext,\n} from \"@polkadot-api/observable-client\"\nimport { FixedSizeBinary, HexString } from \"@polkadot-api/substrate-bindings\"\nimport { StorageItemInput, StorageResult } from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  OperatorFunction,\n  catchError,\n  combineLatestWith,\n  distinctUntilChanged,\n  filter,\n  from,\n  identity,\n  map,\n  mergeMap,\n  pipe,\n  shareReplay,\n  take,\n} from \"rxjs\"\nimport {\n  CompatibilityFunctions,\n  CompatibilityHelper,\n  CompatibilityToken,\n  getCompatibilityApi,\n  minCompatLevel,\n  RuntimeToken,\n} from \"./compatibility\"\nimport { createWatchEntries } from \"./watch-entries\"\nimport { PullOptions } from \"./types\"\n\ntype WithCallOptions<Args extends Array<any>> = [\n  ...args: Args,\n  options?: PullOptions,\n]\n\ntype WithWatchOptions<Args extends Array<any>> = [\n  ...args: Args,\n  options?: { at: \"best\" },\n]\n\ntype PossibleParents<A extends Array<any>> = A extends [...infer Left, any]\n  ? Left | PossibleParents<Left>\n  : ArrayPossibleParents<A>\n\ntype AllPermutations<A extends Array<any>> = PossibleParents<A> | A\n\n// Fixed-size arrays values can't be extracted one-by-one, so that's a specific case\ntype ArrayPossibleParents<\n  A extends Array<any>,\n  Count extends Array<any> = [],\n  R = [],\n> = A extends Array<infer T> & { length: infer L }\n  ? number extends L\n    ? Array<T> // Case variable-size array it's an unknown amount of entries\n    : L extends Count[\"length\"]\n      ? R\n      : ArrayPossibleParents<A, [...Count, T], R | Count>\n  : never\n\ntype GetKey<Args extends Array<any>, Unsafe> = Unsafe extends true\n  ? {\n      /**\n       * Get the storage-key for this storage entry.\n       *\n       * @param args  All keys needed for that storage entry.\n       * @returns Promise that will resolve the hexadecimal value of the\n       *          storage key.\n       */\n      (...args: AllPermutations<Args>): Promise<HexString>\n      /**\n       * Get the storage-key for this storage entry.\n       *\n       * @param ...args       All keys needed for that storage entry.\n       * @param runtimeToken  Token from got with `await\n       *                      typedApi.runtimeToken`\n       * @returns Synchronously returns the hexadecimal value of the\n       *          storage key.\n       */\n      (\n        ...args: [...AllPermutations<Args>, runtimeToken: RuntimeToken]\n      ): HexString\n    }\n  : {\n      /**\n       * Get the storage-key for this storage entry.\n       *\n       * @param args  All keys needed for that storage entry.\n       * @returns Promise that will resolve the hexadecimal value of the\n       *          storage key.\n       */\n      (...args: AllPermutations<Args>): Promise<HexString>\n      /**\n       * Get the storage-key for this storage entry.\n       *\n       * @param ...args             All keys needed for that storage entry.\n       * @param compatibilityToken  Token from got with `await\n       *                            typedApi.compatibilityToken`\n       * @returns Synchronously returns the hexadecimal value of the\n       *          storage key.\n       */\n      (\n        ...args: [\n          ...AllPermutations<Args>,\n          compatibilityToken: CompatibilityToken,\n        ]\n      ): HexString\n    }\n\ntype StorageEntryWithoutKeys<Unsafe, D, Payload> = {\n  /**\n   * Get `Payload` (Promise-based) for the storage entry.\n   *\n   * @param options  Optionally set which block to target (latest known\n   *                 finalized is the default) and an AbortSignal.\n   */\n  getValue: (options?: PullOptions) => Promise<Payload>\n  /**\n   * Watch changes in `Payload` (observable-based) for the storage entry.\n   *\n   * @param bestOrFinalized  Optionally choose which block to query and watch\n   *                         changes, `best` or `finalized` (default)\n   */\n  watchValue: (bestOrFinalized?: \"best\" | \"finalized\") => Observable<Payload>\n  getKey: GetKey<[], Unsafe>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nexport type StorageEntryWithKeys<\n  Unsafe,\n  D,\n  Args extends Array<any>,\n  Payload,\n  ArgsOut extends Array<any>,\n> = {\n  /**\n   * Get `Payload` (Promise-based) for the storage entry with a specific set of\n   * `Args`.\n   *\n   * @param args  All keys needed for that storage entry.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   */\n  getValue: (...args: [...WithCallOptions<Args>]) => Promise<Payload>\n  /**\n   * Watch changes in `Payload` (observable-based) for the storage entry.\n   *\n   * @param args  All keys needed for that storage entry.\n   *              At the end, optionally choose which block to query and\n   *              watch changes, `best` or `finalized` (default)\n   */\n  watchValue: (\n    ...args: [...Args, bestOrFinalized?: \"best\" | \"finalized\"]\n  ) => Observable<Payload>\n  /**\n   * Get an Array of `Payload` (Promise-based) for the storage entry with\n   * several sets of `Args`.\n   *\n   * @param keys     Array of sets of keys needed for the storage entry.\n   * @param options  Optionally set which block to target (latest known\n   *                 finalized is the default) and an AbortSignal.\n   */\n  getValues: (\n    keys: Array<[...Args]>,\n    options?: PullOptions,\n  ) => Promise<Array<Payload>>\n  /**\n   * Get an Array of `Payload` (Promise-based) for the storage entry with a\n   * subset of `Args`.\n   *\n   * @param args  Subset of keys needed for the storage entry.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   * @example\n   *\n   *   // this is a query with 3 keys\n   *   typedApi.query.Pallet.Query.getEntries({ at: \"best\" }) // no keys\n   *   typedApi.query.Pallet.Query.getEntries(arg1, { at: \"finalized\" }) // 1/3 keys\n   *   typedApi.query.Pallet.Query.getEntries(arg1, arg2, { at: \"0x12345678\" }) // 2/3 keys\n   *\n   */\n  getEntries: (\n    ...args: WithCallOptions<PossibleParents<Args>>\n  ) => Promise<Array<{ keyArgs: ArgsOut; value: NonNullable<Payload> }>>\n  /**\n   * Watch changes (Observable-based) for the storage entries with a subset of\n   * `Args`.\n   *\n   * @param args  Subset of keys needed for the storage entry.\n   *              At the end, optionally set whether to watch against the\n   *              `best` block.\n   *              By default watches changes against the finalized block.\n   *              When watching changes against the \"best\" block, this API\n   *              gratiously handles the re-orgs and provides the deltas\n   *              based on the latest emission.\n   *              The observed value contains the following properties:\n   *              - `block`: the block in where the `deltas` took place -\n   *              `deltas`: `null` indicates that nothing has changed from\n   *              the latest emission.\n   *              If the value is not `null` then the `deleted` and `upsrted`\n   *              properties indicate the entries that have changed.\n   *              - `entries`: it's an immutable data-structure with the\n   *              latest entries.\n   * @example\n   *\n   *   typedApi.query.Staking.Nominators.watchEntries()\n   *   typedApi.query.Staking.Nominators.watchEntries({ at: \"best\" })\n   *\n   */\n  watchEntries: (\n    ...args: WithWatchOptions<PossibleParents<Args>>\n  ) => Observable<{\n    block: BlockInfo\n    deltas: null | {\n      deleted: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n      upserted: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n    }\n    entries: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n  }>\n\n  getKey: GetKey<Args, Unsafe>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nexport type StorageEntry<\n  Unsafe,\n  D,\n  Args extends Array<any>,\n  ArgsOut extends Array<any>,\n  Payload,\n> = Args extends []\n  ? StorageEntryWithoutKeys<Unsafe, D, Payload>\n  : StorageEntryWithKeys<Unsafe, D, Args, Payload, ArgsOut>\n\nexport type Storage$ = <Type extends StorageItemInput[\"type\"]>(\n  hash: string | null,\n  type: Type,\n  key: string,\n  childTrie: string | null,\n) => Observable<StorageResult<Type>>\n\nconst toMapped = map(<T>(x: { mapped: T }) => x.mapped)\nexport const createStorageEntry = (\n  pallet: string,\n  name: string,\n  chainHead: ChainHead$,\n  getWatchEntries: ReturnType<typeof createWatchEntries>,\n  {\n    isCompatible,\n    getCompatibilityLevel,\n    getCompatibilityLevels,\n    descriptors: descriptorsPromise,\n    argsAreCompatible,\n    valuesAreCompatible,\n  }: CompatibilityHelper,\n): StorageEntry<any, any, any, any, any> => {\n  const isSystemNumber = pallet === \"System\" && name === \"Number\"\n  const isBlockHash = pallet === \"System\" && name === \"BlockHash\"\n  const sysNumberMapper$ = chainHead.runtime$.pipe(\n    filter(Boolean),\n    take(1),\n    map(({ dynamicBuilder }) =>\n      typeof dynamicBuilder\n        .buildStorage(\"System\", \"Number\")\n        .value.dec(new Uint8Array(32)) === \"bigint\"\n        ? BigInt\n        : identity,\n    ),\n    shareReplay(),\n  )\n  const bigIntOrNumber: OperatorFunction<number, number | bigint> = pipe(\n    combineLatestWith(sysNumberMapper$),\n    map(([input, mapper]) => mapper(input)),\n  )\n\n  const incompatibleError = () =>\n    new Error(`Incompatible runtime entry Storage(${pallet}.${name})`)\n  const invalidArgs = (args: Array<any>) =>\n    new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`)\n\n  const getCodec = (ctx: RuntimeContext) => {\n    try {\n      return ctx.dynamicBuilder.buildStorage(pallet, name)\n    } catch (e: any) {\n      throw new Error(`Runtime entry Storage(${pallet}.${name}) not found`)\n    }\n  }\n\n  const watchValue = (...args: Array<any>) => {\n    const target = args[args.length - 1]\n    const isBest = target === \"best\"\n    const actualArgs =\n      isBest || target === \"finalized\" ? args.slice(0, -1) : args\n\n    return chainHead[isBest ? \"best$\" : \"finalized$\"].pipe(\n      lossLessExhaustMap(() =>\n        getRawValue$(...actualArgs, isBest ? { at: \"best\" } : {}),\n      ),\n      distinctUntilChanged((a, b) => a.raw === b.raw),\n      toMapped,\n    )\n  }\n\n  const getRawValue$ = (\n    ...args: Array<any>\n  ): Observable<{ raw: string | null; mapped: any }> => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { at: _at }: PullOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = from(descriptorsPromise).pipe(\n      mergeMap((descriptors) =>\n        chainHead.storage$(\n          at,\n          \"value\",\n          (ctx) => {\n            const codecs = getCodec(ctx)\n            const actualArgs =\n              args.length === codecs.len ? args : args.slice(0, -1)\n            if (args !== actualArgs && !isLastArgOptional)\n              throw invalidArgs(args)\n            if (!argsAreCompatible(descriptors, ctx, actualArgs))\n              throw incompatibleError()\n            return codecs.keys.enc(...actualArgs)\n          },\n          null,\n          (data, ctx) => {\n            const codecs = getCodec(ctx)\n            const mapped =\n              data === null ? codecs.fallback : codecs.value.dec(data)\n            if (!valuesAreCompatible(descriptors, ctx, mapped))\n              throw incompatibleError()\n            return { raw: data, mapped }\n          },\n        ),\n      ),\n      chainHead.withHodl(at),\n    )\n\n    if (isSystemNumber)\n      return chainHead.pinnedBlocks$.pipe(\n        map((blocks) => {\n          const hash =\n            at === \"finalized\" || !at\n              ? blocks.finalized\n              : at === \"best\"\n                ? blocks.best\n                : at\n          const block = blocks.blocks.get(hash)\n          if (!block) {\n            throw new BlockNotPinnedError(hash, \"System.Number\")\n          }\n          return block.number\n        }),\n        distinctUntilChanged(),\n        bigIntOrNumber,\n        map((mapped) => ({ raw: mapped.toString(), mapped })),\n        catchError((e) => {\n          if (e instanceof BlockNotPinnedError) return result$\n          throw e\n        }),\n      )\n\n    return isBlockHash && Number(args[0]) === 0\n      ? chainHead.genesis$.pipe(\n          map((raw) => ({ raw, mapped: FixedSizeBinary.fromHex(raw) })),\n        )\n      : result$\n  }\n\n  const getValue = async (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal }: PullOptions = isLastArgOptional ? lastArg : {}\n\n    return firstValueFromWithSignal(\n      getRawValue$(...args).pipe(toMapped),\n      signal,\n    )\n  }\n\n  const getEntries = async (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: PullOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = from(descriptorsPromise).pipe(\n      mergeMap((descriptors) =>\n        chainHead.storage$(\n          at,\n          \"descendantsValues\",\n          (ctx) => {\n            const codecs = getCodec(ctx)\n            // TODO partial compatibility check for args that become optional\n            if (\n              minCompatLevel(getCompatibilityLevels(descriptors, ctx)) ===\n              CompatibilityLevel.Incompatible\n            )\n              throw incompatibleError()\n\n            if (args.length > codecs.len) throw invalidArgs(args)\n            const actualArgs =\n              args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args\n            if (args.length === codecs.len && actualArgs === args)\n              throw invalidArgs(args)\n            return codecs.keys.enc(...actualArgs)\n          },\n          null,\n          (values, ctx) => {\n            const codecs = getCodec(ctx)\n            const decodedValues = values.map(({ key, value }) => ({\n              keyArgs: codecs.keys.dec(key),\n              value: codecs.value.dec(value),\n            }))\n            if (\n              decodedValues.some(\n                ({ value }) => !valuesAreCompatible(descriptors, ctx, value),\n              )\n            )\n              throw incompatibleError()\n            return decodedValues\n          },\n        ),\n      ),\n      chainHead.withHodl(at),\n    )\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  const getValues = (keyArgs: Array<Array<any>>, options?: PullOptions) =>\n    Promise.all(\n      keyArgs.map((args) => getValue(...(options ? [...args, options] : args))),\n    )\n\n  const watchEntries: any = (...args: Array<any>) => {\n    const lastArg = args.at(-1)\n    const isLastArgOptional = isOptionalArg(lastArg)\n\n    return getWatchEntries(\n      pallet,\n      name,\n      isLastArgOptional ? args.slice(0, -1) : args,\n      isLastArgOptional && lastArg.at === \"best\",\n    )\n  }\n\n  const getKey = (...args: Array<any>): Promise<string> | string => {\n    const token = args.at(-1)\n    if (token instanceof CompatibilityToken || token instanceof RuntimeToken) {\n      const actualArgs = args.slice(0, -1)\n      const ctx = getCompatibilityApi(token).runtime()\n      if (!argsAreCompatible(token, ctx, actualArgs)) throw incompatibleError()\n      return getCodec(ctx).keys.enc(...actualArgs)\n    }\n    return descriptorsPromise.then((x) => getKey(...args, x))\n  }\n\n  return {\n    isCompatible,\n    getCompatibilityLevel,\n    getKey: getKey as GetKey<any, any>,\n    getValue,\n    getValues,\n    getEntries,\n    watchValue,\n    watchEntries,\n  }\n}\n"],"names":[],"mappings":"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"}