{"version":3,"file":"index.js","sources":["../src/lookups.ts","../src/with-cache.ts","../src/lookup-codec-builder.ts","../src/dynamic-builder.ts","../src/lookup-graph.ts","../src/checksum-builder.ts"],"sourcesContent":["import type {\n  StringRecord,\n  UnifiedMetadata,\n  V14Lookup,\n} from \"@polkadot-api/substrate-bindings\"\n\nexport type SignedPrimitive = \"i8\" | \"i16\" | \"i32\" | \"i64\" | \"i128\" | \"i256\"\nexport type UnsignedPrimitive = \"u8\" | \"u16\" | \"u32\" | \"u64\" | \"u128\" | \"u256\"\nexport type MetadataPrimitives =\n  | \"bool\"\n  | \"char\"\n  | \"str\"\n  | SignedPrimitive\n  | UnsignedPrimitive\n\nexport type PrimitiveVar = {\n  type: \"primitive\"\n  value: MetadataPrimitives\n}\n\nexport type VoidVar = { type: \"void\" }\nexport type CompactVar = {\n  type: \"compact\"\n  isBig: boolean\n  size: UnsignedPrimitive\n}\nexport type BitSequenceVar = {\n  type: \"bitSequence\"\n  isLSB: boolean\n}\nexport type AccountId32 = { type: \"AccountId32\" }\nexport type AccountId20 = { type: \"AccountId20\" }\nexport type TerminalVar =\n  | PrimitiveVar\n  | VoidVar\n  | CompactVar\n  | BitSequenceVar\n  | AccountId32\n  | AccountId20\n\n/* Array-like vars:\n * - TupleVar: Mixed types, fixed length\n * - Sequence: One type, arbitrary length\n * - Array: One type, fixed length\n */\nexport type TupleVar = {\n  type: \"tuple\"\n  value: LookupEntry[]\n  innerDocs: Array<string[]>\n}\nexport type StructVar = {\n  type: \"struct\"\n  value: StringRecord<LookupEntry>\n  innerDocs: StringRecord<string[]>\n}\nexport type EnumVar = {\n  type: \"enum\"\n  value: StringRecord<\n    (\n      | { type: \"lookupEntry\"; value: LookupEntry }\n      | VoidVar\n      | TupleVar\n      | StructVar\n      | ArrayVar\n    ) & { idx: number }\n  >\n  innerDocs: StringRecord<string[]>\n  byteLength?: number\n}\nexport type OptionVar = {\n  type: \"option\"\n  value: LookupEntry\n}\nexport type ResultVar = {\n  type: \"result\"\n  value: { ok: LookupEntry; ko: LookupEntry }\n}\nexport type SequenceVar = {\n  type: \"sequence\"\n  value: LookupEntry\n}\nexport type ArrayVar = {\n  type: \"array\"\n  value: LookupEntry\n  len: number\n}\n\nexport type ComposedVar =\n  | TupleVar\n  | StructVar\n  | SequenceVar\n  | ArrayVar\n  | OptionVar\n  | ResultVar\n  | EnumVar\n\nexport type Var = TerminalVar | ComposedVar\n\nexport type LookupEntry = {\n  id: number\n} & Var\n\nconst isBytes = (value: LookupEntry, nBytes: number) =>\n  value.type === \"array\" &&\n  value.len === nBytes &&\n  value.value.type === \"primitive\" &&\n  value.value.value === \"u8\"\n\nconst _void: VoidVar = { type: \"void\" }\n\nexport interface MetadataLookup {\n  (id: number): LookupEntry\n  metadata: UnifiedMetadata\n  call: number | null\n}\n\nconst _denormalizeLookup = (\n  lookupData: V14Lookup,\n  customMap: (value: V14Lookup[number]) => Var | null = () => null,\n): ((id: number) => LookupEntry) => {\n  const lookups = new Map<number, LookupEntry>()\n  const from = new Set<number>()\n\n  const withCache = (\n    fn: (id: number) => Var,\n  ): ((id: number) => LookupEntry) => {\n    return (id) => {\n      let entry = lookups.get(id)\n\n      if (entry) return entry\n\n      if (from.has(id)) {\n        const entry = {\n          id,\n        } as LookupEntry\n\n        lookups.set(id, entry)\n        return entry\n      }\n\n      from.add(id)\n      const value = fn(id)\n      entry = lookups.get(id)\n\n      if (entry) {\n        Object.assign(entry, value)\n      } else {\n        entry = {\n          id,\n          ...value,\n        }\n        lookups.set(id, entry!)\n      }\n      from.delete(id)\n      return entry\n    }\n  }\n\n  let isAccountId32SearchOn = true\n  let isAccountId20SearchOn = true\n  const getLookupEntryDef = withCache((id): Var => {\n    const custom = customMap(lookupData[id])\n    if (custom) return custom\n\n    const { def, path, params } = lookupData[id]\n\n    if (def.tag === \"composite\") {\n      if (def.value.length === 0) return _void\n\n      // used to be a \"pointer\"\n      if (def.value.length === 1) {\n        const inner = getLookupEntryDef(def.value[0].type as number)\n\n        if (\n          isAccountId32SearchOn &&\n          path.at(-1) === \"AccountId32\" &&\n          isBytes(inner, 32)\n        ) {\n          isAccountId32SearchOn = false\n          return { type: \"AccountId32\" }\n        }\n\n        if (\n          isAccountId20SearchOn &&\n          path.at(-1) === \"AccountId20\" &&\n          isBytes(inner, 20)\n        ) {\n          isAccountId20SearchOn = false\n          return { type: \"AccountId20\" }\n        }\n\n        return inner\n      }\n\n      return getComplexVar(def.value)\n    }\n\n    if (def.tag === \"variant\") {\n      if (\n        path.length === 1 &&\n        path[0] === \"Option\" &&\n        params.length === 1 &&\n        params[0].name === \"T\"\n      ) {\n        const value = getLookupEntryDef(params[0].type!)\n        return value.type === \"void\"\n          ? // Option<void> would return a Codec<undefined> which makes no sense\n            // Therefore, we better treat it as a bool\n            { type: \"primitive\", value: \"bool\" }\n          : {\n              type: \"option\",\n              value,\n            }\n      }\n\n      if (\n        path.length === 1 &&\n        path[0] === \"Result\" &&\n        params.length === 2 &&\n        params[0].name === \"T\" &&\n        params[1].name === \"E\"\n      ) {\n        return {\n          type: \"result\",\n          value: {\n            ok: getLookupEntryDef(params[0].type as number),\n            ko: getLookupEntryDef(params[1].type as number),\n          },\n        }\n      }\n      if (def.value.length === 0) return _void\n\n      const enumValue: StringRecord<EnumVar[\"value\"][keyof EnumVar[\"value\"]]> =\n        {}\n      const enumDocs: StringRecord<string[]> = {}\n\n      def.value.forEach((x) => {\n        const key = x.name\n        enumDocs[key] = x.docs\n\n        if (x.fields.length === 0) {\n          enumValue[key] = { ..._void, idx: x.index }\n          return\n        }\n\n        if (x.fields.length === 1 && !x.fields[0].name) {\n          enumValue[key] = {\n            type: \"lookupEntry\",\n            value: getLookupEntryDef(x.fields[0].type),\n            idx: x.index,\n          }\n          return\n        }\n\n        enumValue[key] = { ...getComplexVar(x.fields), idx: x.index }\n      })\n\n      return {\n        type: \"enum\",\n        value: enumValue,\n        innerDocs: enumDocs,\n      }\n    }\n\n    if (def.tag === \"sequence\")\n      return {\n        type: \"sequence\",\n        value: getLookupEntryDef(def.value as number),\n      }\n\n    if (def.tag === \"array\") {\n      const { len } = def.value\n      const value = getLookupEntryDef(def.value.type)\n\n      return !len || value.type === \"void\"\n        ? _void\n        : len > 1\n          ? {\n              type: \"array\",\n              value,\n              len: def.value.len,\n            }\n          : value\n    }\n\n    if (def.tag === \"tuple\") {\n      if (def.value.length === 0) return _void\n\n      return def.value.length > 1\n        ? getArrayOrTuple(\n            def.value.map((x) => getLookupEntryDef(x as number)),\n            def.value.map((x) => lookupData[x].docs),\n          )\n        : getLookupEntryDef(def.value[0] as number) // use to be a \"pointer\"\n    }\n\n    if (def.tag === \"primitive\") {\n      return {\n        type: \"primitive\",\n        value: def.value.tag,\n      }\n    }\n\n    if (def.tag === \"compact\") {\n      const translated = getLookupEntryDef(def.value) as PrimitiveVar | VoidVar\n      if (translated.type === \"void\") return _void\n\n      const isBig = Number(translated.value.slice(1)) > 32\n\n      return {\n        type: \"compact\",\n        isBig,\n        size: translated.value as UnsignedPrimitive,\n      }\n    }\n\n    // bitSequence\n    return {\n      type: def.tag,\n      isLSB: (lookupData[def.value.bitOrderType].path.at(-1) ?? \"LSB\")\n        .toUpperCase()\n        .startsWith(\"LSB\"),\n    }\n  })\n\n  const getComplexVar = (\n    input: Array<{ type: number; name?: string; docs: string[] }>,\n  ): TupleVar | StructVar | ArrayVar | VoidVar => {\n    let allKey = true\n\n    const values: Record<string | number, LookupEntry> = {}\n    const innerDocs: Record<string | number, string[]> = {}\n\n    input.forEach((x, idx) => {\n      allKey = allKey && !!x.name\n      const key = x.name || idx\n      const value = getLookupEntryDef(x.type as number)\n      if (value.type !== \"void\") {\n        values[key] = value\n        innerDocs[key] = x.docs\n      }\n    })\n    return allKey\n      ? {\n          type: \"struct\",\n          value: values as StringRecord<LookupEntry>,\n          innerDocs: innerDocs as StringRecord<string[]>,\n        }\n      : getArrayOrTuple(Object.values(values), Object.values(innerDocs))\n  }\n\n  const getArrayOrTuple = (\n    values: Array<LookupEntry>,\n    innerDocs: Array<string[]>,\n  ): TupleVar | ArrayVar | VoidVar => {\n    if (\n      values.every((v) => v.id === values[0].id) &&\n      innerDocs.every((doc) => !doc.length)\n    ) {\n      const [value] = values\n      return value.type === \"void\"\n        ? _void\n        : {\n            type: \"array\",\n            value: values[0],\n            len: values.length,\n          }\n    }\n    return {\n      type: \"tuple\",\n      value: values,\n      innerDocs: innerDocs,\n    }\n  }\n\n  return getLookupEntryDef\n}\n\nexport const denormalizeLookup = (lookupData: V14Lookup) =>\n  _denormalizeLookup(lookupData)\n\nexport const getLookupFn = (metadata: UnifiedMetadata): MetadataLookup => {\n  const getLookupEntryDef = _denormalizeLookup(metadata.lookup, ({ def }) => {\n    if (def.tag === \"composite\") {\n      const moduleErrorLength = getModuleErrorLength(def)\n      if (moduleErrorLength) {\n        return {\n          type: \"enum\",\n          innerDocs: {},\n          value: Object.fromEntries(\n            metadata.pallets.map((p) => [\n              p.name,\n              p.errors == null\n                ? { ..._void, idx: p.index }\n                : {\n                    type: \"lookupEntry\" as const,\n                    value: getLookupEntryDef(p.errors.type),\n                    idx: p.index,\n                  },\n            ]),\n          ) as StringRecord<\n            (\n              | VoidVar\n              | {\n                  type: \"lookupEntry\"\n                  value: LookupEntry\n                }\n            ) & { idx: number }\n          >,\n          byteLength: moduleErrorLength,\n        }\n      }\n    }\n    return null\n  })\n\n  function getModuleErrorLength(def: {\n    tag: \"composite\"\n    value: {\n      name: string | undefined\n      type: number\n      typeName: string | undefined\n      docs: string[]\n    }[]\n  }) {\n    const preChecks =\n      def.value.length === 2 &&\n      def.value[0].name === \"index\" &&\n      def.value[1].name === \"error\"\n    if (!preChecks) return null\n\n    const index = getLookupEntryDef(def.value[0].type)\n    const error = getLookupEntryDef(def.value[1].type)\n\n    return index.type === \"primitive\" &&\n      index.value === \"u8\" &&\n      error.type === \"array\" &&\n      error.value.type === \"primitive\" &&\n      error.value.value === \"u8\"\n      ? 1 + error.len\n      : null\n  }\n\n  const getCall = () => {\n    if (\"call\" in metadata.extrinsic) {\n      return metadata.extrinsic.call\n    }\n\n    const extrinsic = metadata.lookup[metadata.extrinsic.type]\n    const call = extrinsic?.params.find((p) => p.name === \"Call\")\n\n    return call?.type ?? null\n  }\n\n  return Object.assign(getLookupEntryDef, { metadata, call: getCall() })\n}\n","import { LookupEntry } from \"./lookups\"\n\ntype FnWithStack<Other extends Array<any>, T> = (\n  input: LookupEntry,\n  cache: Map<number, T>,\n  stack: Set<number>,\n  ...rest: Other\n) => T\n\nexport const withCache =\n  <Other extends Array<any>, T>(\n    fn: FnWithStack<Other, T>,\n    onEnterCircular: (\n      cacheGetter: () => T,\n      circular: LookupEntry,\n      ...rest: Other\n    ) => T,\n    onExitCircular: (\n      outter: T,\n      inner: T,\n      circular: LookupEntry,\n      ...rest: Other\n    ) => T,\n  ): FnWithStack<Other, T> =>\n  (input, cache, stack, ...rest) => {\n    const { id } = input\n    if (cache.has(id)) return cache.get(id)!\n\n    if (stack.has(id)) {\n      const res = onEnterCircular(() => cache.get(id)!, input, ...rest)\n      cache.set(id, res)\n      return res\n    }\n\n    stack.add(id)\n    let result = fn(input, cache, stack, ...rest)\n    stack.delete(id)\n\n    if (cache.has(id))\n      result = onExitCircular(result, cache.get(id)!, input, ...rest)\n\n    cache.set(id, result)\n    return result\n  }\n","import type { Codec, StringRecord } from \"@polkadot-api/substrate-bindings\"\nimport * as scale from \"@polkadot-api/substrate-bindings\"\nimport type { LookupEntry } from \"./lookups\"\nimport { withCache } from \"./with-cache\"\n\nconst _bytes = scale.Bin()\n\nconst _buildCodec = (\n  input: LookupEntry,\n  cache: Map<number, Codec<any>>,\n  stack: Set<number>,\n  _accountId: Codec<scale.SS58String>,\n): Codec<any> => {\n  if (input.type === \"primitive\") return scale[input.value]\n  if (input.type === \"void\") return scale._void\n  if (input.type === \"AccountId32\") return _accountId\n  if (input.type === \"AccountId20\") return scale.ethAccount\n  if (input.type === \"compact\")\n    return input.isBig ? scale.compactBn : scale.compactNumber\n  if (input.type === \"bitSequence\") return scale.BitSeq(input.isLSB)\n\n  const buildNextCodec = (nextInput: LookupEntry): Codec<any> =>\n    buildCodec(nextInput, cache, stack, _accountId)\n\n  const buildVector = (inner: LookupEntry, len?: number) => {\n    const innerCodec = buildNextCodec(inner)\n    return len ? scale.Vector(innerCodec, len) : scale.Vector(innerCodec)\n  }\n\n  const buildTuple = (value: LookupEntry[]) =>\n    scale.Tuple(...value.map(buildNextCodec))\n\n  const buildStruct = (value: StringRecord<LookupEntry>) => {\n    const inner = Object.fromEntries(\n      Object.entries(value).map(([key, value]) => [key, buildNextCodec(value)]),\n    ) as StringRecord<Codec<any>>\n    return scale.Struct(inner)\n  }\n\n  if (\n    input.type === \"sequence\" &&\n    input.value.type === \"primitive\" &&\n    input.value.value === \"u8\"\n  ) {\n    return _bytes\n  }\n\n  if (input.type === \"array\") {\n    // Bytes case\n    if (input.value.type === \"primitive\" && input.value.value === \"u8\")\n      return scale.Bin(input.len)\n\n    return buildVector(input.value, input.len)\n  }\n\n  if (input.type === \"sequence\") return buildVector(input.value)\n  if (input.type === \"tuple\") return buildTuple(input.value)\n  if (input.type === \"struct\") return buildStruct(input.value)\n\n  if (input.type === \"option\") return scale.Option(buildNextCodec(input.value))\n\n  if (input.type === \"result\")\n    return scale.Result(\n      buildNextCodec(input.value.ok),\n      buildNextCodec(input.value.ko),\n    )\n\n  // it has to be an enum by now\n  const dependencies = Object.values(input.value).map((v) => {\n    switch (v.type) {\n      case \"void\":\n        return scale._void\n      case \"lookupEntry\":\n        return buildNextCodec(v.value)\n      case \"tuple\":\n        return buildTuple(v.value)\n      case \"struct\":\n        return buildStruct(v.value)\n      case \"array\":\n        return buildVector(v.value, v.len)\n    }\n  })\n\n  const inner = Object.fromEntries(\n    Object.keys(input.value).map((key, idx) => {\n      return [key, dependencies[idx]]\n    }),\n  ) as StringRecord<Codec<any>>\n\n  const indexes = Object.values(input.value).map((x) => x.idx)\n  const areIndexesSorted = indexes.every((idx, i) => idx === i)\n\n  const variantCodec = areIndexesSorted\n    ? scale.Variant(inner)\n    : scale.Variant(inner, indexes as any)\n  return input.byteLength\n    ? fixedSizeCodec(variantCodec, input.byteLength)\n    : variantCodec\n}\nconst buildCodec = withCache(_buildCodec, scale.Self, (res) => res)\n\nexport const getLookupCodecBuilder = (\n  lookup: (id: number) => LookupEntry,\n  accountId = scale.AccountId(),\n) => {\n  const cache = new Map()\n  const buildDefinition = (id: number) =>\n    buildCodec(lookup(id), cache, new Set(), accountId)\n\n  return (id: number) => buildDefinition(id)\n}\n\nconst fixedSizeCodec = <T>(codec: Codec<T>, size: number): Codec<T> => {\n  const allBytes = scale.Bytes(size)\n  return scale.createCodec<T>(\n    (value: T) => allBytes.enc(codec.enc(value)),\n    (data) => codec.dec(allBytes.dec(data)),\n  )\n}\n","import type { Codec, StringRecord } from \"@polkadot-api/substrate-bindings\"\nimport * as scale from \"@polkadot-api/substrate-bindings\"\nimport { mapObject } from \"@polkadot-api/utils\"\nimport type { EnumVar, MetadataLookup } from \"./lookups\"\nimport { getLookupCodecBuilder } from \"./lookup-codec-builder\"\n\nconst nullCodec = scale.enhanceCodec(\n  scale._void,\n  () => undefined,\n  () => null,\n)\n\nexport const getDynamicBuilder = (getLookupEntryDef: MetadataLookup) => {\n  const { metadata } = getLookupEntryDef\n  let buildDefinition = getLookupCodecBuilder(getLookupEntryDef)\n\n  const prefix = metadata.pallets\n    .find((x) => x.name === \"System\")\n    ?.constants.find((x) => x.name === \"SS58Prefix\")\n\n  let ss58Prefix: number | undefined\n  if (prefix) {\n    try {\n      const prefixVal = buildDefinition(prefix.type).dec(prefix.value)\n      if (typeof prefixVal === \"number\") {\n        ss58Prefix = prefixVal\n        buildDefinition = getLookupCodecBuilder(\n          getLookupEntryDef,\n          scale.AccountId(prefixVal),\n        )\n      }\n    } catch (_) {}\n  }\n\n  const storagePallets = new Map<string, ReturnType<typeof scale.Storage>>()\n\n  const buildStorage = (pallet: string, entry: string) => {\n    let storagePallet = storagePallets.get(pallet)\n    if (!storagePallet)\n      storagePallets.set(pallet, (storagePallet = scale.Storage(pallet)))\n\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .storage!.items.find((s) => s.name === entry)!\n\n    // if val is `void` it decodes to `undefined`, making it impossible\n    // to differentiate from a non-existant key\n    // therefore, if the key exists => null, if it doesn't => undefined\n    const withNullVoid = (codec: Codec<any>) =>\n      codec === scale._void ? nullCodec : codec\n\n    const storageWithFallback = (\n      len: number,\n      value: Codec<any>,\n      ...args: Parameters<ReturnType<typeof scale.Storage>>\n    ) => {\n      const keys = storagePallet!(...args)\n      const [, ...encodersWithHash] = args\n      return {\n        args: scale.Tuple(...encodersWithHash.map(([codec]) => codec)),\n        keys,\n        value,\n        len,\n        fallback:\n          storageEntry.modifier === 1\n            ? value.dec(storageEntry.fallback)\n            : undefined,\n      }\n    }\n\n    if (storageEntry.type.tag === \"plain\")\n      return storageWithFallback(\n        0,\n        withNullVoid(buildDefinition(storageEntry.type.value)),\n        entry,\n      )\n\n    const { key, value, hashers } = storageEntry.type.value\n    const val = withNullVoid(buildDefinition(value))\n    const hashes = hashers.map((x) => scale[x.tag])\n\n    const hashArgs: scale.EncoderWithHash<unknown>[] = (() => {\n      if (hashes.length === 1) {\n        return [[buildDefinition(key), hashes[0]]]\n      }\n\n      const keyDef = getLookupEntryDef(key)\n\n      switch (keyDef.type) {\n        case \"array\":\n          return hashes.map((hash) => [buildDefinition(keyDef.value.id), hash])\n        case \"tuple\":\n          return keyDef.value.map((x, idx) => [\n            buildDefinition(x.id),\n            hashes[idx],\n          ])\n        default:\n          throw new Error(\"Invalid key type\")\n      }\n    })()\n\n    return storageWithFallback(hashes.length, val, entry, ...hashArgs)\n  }\n\n  const buildEnumEntry = (\n    entry: EnumVar[\"value\"][keyof EnumVar[\"value\"]],\n  ): Codec<any> => {\n    switch (entry.type) {\n      case \"void\":\n        return scale._void\n      case \"lookupEntry\":\n        return buildDefinition(entry.value.id)\n      case \"tuple\":\n        return scale.Tuple(\n          ...Object.values(entry.value).map((l) => buildDefinition(l.id)),\n        )\n      case \"struct\":\n        return scale.Struct(\n          mapObject(entry.value, (x) => buildDefinition(x.id)) as StringRecord<\n            Codec<any>\n          >,\n        )\n      case \"array\":\n        return scale.Vector(buildDefinition(entry.value.id), entry.len)\n    }\n  }\n\n  const buildConstant = (pallet: string, constantName: string) => {\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .constants!.find((s) => s.name === constantName)!\n\n    return buildDefinition(storageEntry.type as number)\n  }\n\n  const buildVariant =\n    (type: \"errors\" | \"events\" | \"calls\") =>\n    (\n      pallet: string,\n      name: string,\n    ): {\n      codec: Codec<any>\n      location: [number, number]\n    } => {\n      const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n      const lookup = getLookupEntryDef(palletEntry[type]!.type)\n      if (lookup.type !== \"enum\") throw null\n      const entry = lookup.value[name]\n\n      return {\n        location: [palletEntry.index, entry.idx],\n        codec: buildEnumEntry(lookup.value[name]),\n      }\n    }\n\n  const buildViewFn = (pallet: string, entry: string) => {\n    const fn = metadata.pallets\n      .find((x) => x.name === pallet)\n      ?.viewFns.find((x) => x.name === entry)\n    if (!fn) throw null\n\n    return {\n      args: scale.Tuple(...fn.inputs.map((x) => buildDefinition(x.type))),\n      value: buildDefinition(fn.output),\n    }\n  }\n\n  const buildRuntimeCall = (api: string, method: string) => {\n    const entry = metadata.apis\n      .find((x) => x.name === api)\n      ?.methods.find((x) => x.name === method)\n    if (!entry) throw null\n\n    return {\n      args: scale.Tuple(...entry.inputs.map((x) => buildDefinition(x.type))),\n      value: buildDefinition(entry.output),\n    }\n  }\n\n  return {\n    buildDefinition,\n    buildStorage,\n    buildEvent: buildVariant(\"events\"),\n    buildError: buildVariant(\"errors\"),\n    buildViewFn,\n    buildRuntimeCall,\n    buildCall: buildVariant(\"calls\"),\n    buildConstant,\n    ss58Prefix,\n  }\n}\n","import { LookupEntry } from \"./lookups\"\n\nexport type LookupGraph = Map<\n  number,\n  { entry: LookupEntry; backRefs: Set<number>; refs: Set<number> }\n>\n\nexport function buildLookupGraph(\n  lookupFn: (id: number) => LookupEntry,\n  lookupLength: number,\n): LookupGraph {\n  const result: LookupGraph = new Map()\n  const visited = new Set<number>()\n\n  const addEdge = (from: number, to: number) => {\n    if (!result.has(from))\n      result.set(from, {\n        entry: lookupFn(from),\n        backRefs: new Set(),\n        refs: new Set(),\n      })\n    if (!result.has(to))\n      result.set(to, {\n        entry: lookupFn(to),\n        backRefs: new Set(),\n        refs: new Set(),\n      })\n    result.get(from)!.refs.add(to)\n    result.get(to)!.backRefs.add(from)\n  }\n\n  for (let i = 0; i < lookupLength; i++) {\n    const entry = lookupFn(i)\n    if (i !== entry.id) {\n      // Lookup solved a pointer, but we still need to add that node into our\n      // graph in case someone access it from there.\n      addEdge(i, entry.id)\n    }\n    if (visited.has(entry.id)) continue\n    visited.add(entry.id)\n\n    switch (entry.type) {\n      case \"array\":\n      case \"option\":\n      case \"sequence\":\n        addEdge(entry.id, entry.value.id)\n        break\n      case \"enum\":\n        Object.values(entry.value).forEach((enumEntry) => {\n          switch (enumEntry.type) {\n            case \"array\":\n            case \"lookupEntry\":\n              addEdge(entry.id, enumEntry.value.id)\n              break\n            case \"struct\":\n            case \"tuple\":\n              Object.values(enumEntry.value).forEach((v) =>\n                addEdge(entry.id, v.id),\n              )\n              break\n          }\n        })\n        break\n      case \"result\":\n        addEdge(entry.id, entry.value.ok.id)\n        addEdge(entry.id, entry.value.ko.id)\n        break\n      case \"struct\":\n      case \"tuple\":\n        Object.values(entry.value).forEach((v) => addEdge(entry.id, v.id))\n        break\n    }\n\n    // It could be that this node is not being referenced by any other type\n    // nor it references anything. We still have to add it into the graph.\n    if (!result.has(entry.id)) {\n      result.set(entry.id, {\n        backRefs: new Set(),\n        refs: new Set(),\n        entry,\n      })\n    }\n  }\n\n  return result\n}\n\nconst subgraphCache = new WeakMap<LookupGraph, Map<number, LookupGraph>>()\nfunction _getSubgraph(\n  id: number,\n  graph: LookupGraph,\n  result: LookupGraph,\n  cache: Map<number, LookupGraph>,\n) {\n  if (result.has(id)) return\n  const node = graph.get(id)!\n  result.set(id, node)\n  cache.set(id, result)\n\n  node.refs.forEach((ref) => _getSubgraph(ref, graph, result, cache))\n  node.backRefs.forEach((ref) => _getSubgraph(ref, graph, result, cache))\n}\n\nexport function getSubgraph(id: number, graph: LookupGraph) {\n  if (!subgraphCache.has(graph)) {\n    subgraphCache.set(graph, new Map())\n  }\n  const cache = subgraphCache.get(graph)!\n  if (cache.has(id)) return cache.get(id)!\n\n  const result: LookupGraph = new Map()\n  _getSubgraph(id, graph, result, cache)\n  return result\n}\n\nexport function getStronglyConnectedComponents(graph: LookupGraph) {\n  // Tarjan's strongly connected components\n  const tarjanState = new Map<\n    number,\n    {\n      index: number\n      lowLink: number\n      onStack: boolean\n    }\n  >()\n  let index = 0\n  const stack: number[] = []\n  const result: Array<Set<number>> = []\n\n  function strongConnect(v: number): void {\n    const state = {\n      index: index,\n      lowLink: index,\n      onStack: true,\n    }\n    tarjanState.set(v, state)\n    index++\n    stack.push(v)\n\n    const edges = graph.get(v)!.refs\n    for (let w of edges) {\n      const edgeState = tarjanState.get(w)\n      if (!edgeState) {\n        strongConnect(w)\n        state.lowLink = Math.min(state.lowLink, tarjanState.get(w)!.lowLink)\n      } else if (edgeState.onStack) {\n        state.lowLink = Math.min(state.lowLink, edgeState.index)\n      }\n    }\n\n    if (state.lowLink === state.index) {\n      const component = new Set<number>()\n\n      let poppedNode = -1\n      do {\n        poppedNode = stack.pop()!\n        tarjanState.get(poppedNode)!.onStack = false\n        component.add(poppedNode)\n      } while (poppedNode !== v)\n\n      result.push(component)\n    }\n  }\n\n  for (const node of graph.keys()) {\n    if (!tarjanState.has(node)) {\n      strongConnect(node)\n    }\n  }\n\n  return result\n}\n\nexport function mergeSCCsWithCommonNodes(\n  stronglyConnectedComponents: Array<Set<number>>,\n) {\n  /**\n   * For Nodes that are shared between two sets of SCCs, we need to calculate\n   * the checksum for the both of them, which wouldn't work (it would give\n   * different checksums).\n   * So we merge the SCCs that are using shared nodes into one group.\n   */\n  const scc = stronglyConnectedComponents\n  const ungroupedCycles = new Set(scc.map((_, i) => i))\n  const edges = new Map(scc.map((_, i) => [i, new Set<number>()]))\n  scc.forEach((cycle, i) => {\n    scc.slice(i + 1).forEach((otherCycle, _j) => {\n      const j = _j + i + 1\n      const combined = new Set([...cycle, ...otherCycle])\n      if (combined.size !== cycle.size + otherCycle.size) {\n        edges.get(i)!.add(j)\n        edges.get(j)!.add(i)\n      }\n    })\n  })\n  const groups: Array<Set<number>> = []\n\n  while (ungroupedCycles.size) {\n    const group = new Set<number>()\n    const toVisit = [ungroupedCycles.values().next().value!]\n    while (toVisit.length) {\n      const idx = toVisit.pop()!\n      if (!ungroupedCycles.has(idx)) continue\n      ungroupedCycles.delete(idx)\n\n      const cycle = scc[idx]\n      cycle.forEach((v) => group.add(Number(v)))\n      edges.get(idx)!.forEach((n) => toVisit.push(n))\n    }\n    groups.push(group)\n  }\n\n  return groups\n}\n","import type { StringRecord } from \"@polkadot-api/substrate-bindings\"\nimport { h64 } from \"@polkadot-api/substrate-bindings\"\nimport {\n  LookupGraph,\n  buildLookupGraph,\n  getStronglyConnectedComponents,\n  getSubgraph,\n  mergeSCCsWithCommonNodes,\n} from \"./lookup-graph\"\nimport {\n  ArrayVar,\n  LookupEntry,\n  MetadataLookup,\n  MetadataPrimitives,\n  StructVar,\n  TupleVar,\n  VoidVar,\n} from \"./lookups\"\n\nconst textEncoder = new TextEncoder()\nconst encodeText = textEncoder.encode.bind(textEncoder)\n\nconst getChecksum = (values: Array<bigint>) => {\n  const res = new Uint8Array(values.length * 8)\n  const dv = new DataView(res.buffer)\n\n  for (let i = 0; i < values.length; i++) dv.setBigUint64(i * 8, values[i])\n\n  return h64(res)\n}\nconst getStringChecksum = (values: Array<string>) =>\n  getChecksum(values.map((v) => h64(encodeText(v))))\n\ntype Shape =\n  | \"primitive\"\n  | \"void\"\n  | \"vector\"\n  | \"tuple\"\n  | \"struct\"\n  | \"option\"\n  | \"result\"\n  | \"enum\"\nconst shapeIds: Record<Shape, bigint> = {\n  primitive: 0n,\n  vector: 1n,\n  tuple: 2n,\n  struct: 3n,\n  option: 4n,\n  result: 5n,\n  enum: 6n,\n  void: 7n,\n}\n\ntype RuntimePrimitives =\n  | \"undefined\"\n  | \"number\"\n  | \"string\"\n  | \"bigint\"\n  | \"boolean\"\n  | \"bitSequence\"\n  | \"byteSequence\"\n  | \"accountId32\"\n  | \"accountId20\"\n\nconst runtimePrimitiveIds: Record<RuntimePrimitives, bigint> = {\n  undefined: 0n,\n  number: 1n,\n  string: 2n,\n  bigint: 3n,\n  boolean: 4n,\n  bitSequence: 5n, // {bitsLen: number, bytes: Uint8Array}\n  byteSequence: 6n, // Binary\n  accountId32: 7n, // SS58String\n  accountId20: 8n, // EthAccount\n}\n\nconst metadataPrimitiveIds: Record<MetadataPrimitives, bigint> = {\n  bool: runtimePrimitiveIds.boolean,\n  char: runtimePrimitiveIds.string,\n  str: runtimePrimitiveIds.string,\n  u8: runtimePrimitiveIds.number,\n  u16: runtimePrimitiveIds.number,\n  u32: runtimePrimitiveIds.number,\n  u64: runtimePrimitiveIds.bigint,\n  u128: runtimePrimitiveIds.bigint,\n  u256: runtimePrimitiveIds.bigint,\n  i8: runtimePrimitiveIds.number,\n  i16: runtimePrimitiveIds.number,\n  i32: runtimePrimitiveIds.number,\n  i64: runtimePrimitiveIds.bigint,\n  i128: runtimePrimitiveIds.bigint,\n  i256: runtimePrimitiveIds.bigint,\n}\n\nconst structLikeBuilder = <T>(\n  shapeId: bigint,\n  input: StringRecord<T>,\n  innerChecksum: (value: T) => bigint,\n) => {\n  const sortedEntries = Object.entries(input).sort(([a], [b]) =>\n    a.localeCompare(b),\n  )\n  const keysChecksum = getStringChecksum(sortedEntries.map(([key]) => key))\n  const valuesChecksum = getChecksum(\n    sortedEntries.map(([, entry]) => innerChecksum(entry)),\n  )\n\n  return getChecksum([shapeId, keysChecksum, valuesChecksum])\n}\n\nconst _buildChecksum = (\n  input: LookupEntry,\n  buildNextChecksum: (entry: LookupEntry) => bigint,\n): bigint => {\n  if (input.type === \"primitive\")\n    return getChecksum([shapeIds.primitive, metadataPrimitiveIds[input.value]])\n\n  if (input.type === \"void\") return getChecksum([shapeIds.void])\n\n  if (input.type === \"compact\")\n    return getChecksum([\n      shapeIds.primitive,\n      runtimePrimitiveIds[input.isBig ? \"bigint\" : \"number\"],\n    ])\n\n  if (input.type === \"bitSequence\")\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.bitSequence])\n\n  if (input.type === \"AccountId32\") {\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.accountId32])\n  }\n\n  if (input.type === \"AccountId20\") {\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.accountId20])\n  }\n\n  const buildVector = (entry: LookupEntry, length?: number) => {\n    const innerChecksum = buildNextChecksum(entry)\n    return getChecksum(\n      length !== undefined\n        ? [shapeIds.vector, innerChecksum, BigInt(length)]\n        : [shapeIds.vector, innerChecksum],\n    )\n  }\n\n  if (input.type === \"array\") {\n    const innerValue = input.value\n    if (innerValue.type === \"primitive\" && innerValue.value === \"u8\") {\n      return getChecksum([\n        shapeIds.primitive,\n        runtimePrimitiveIds.byteSequence,\n        BigInt(input.len),\n      ])\n    }\n    return buildVector(innerValue, input.len)\n  }\n\n  if (input.type === \"sequence\") {\n    const innerValue = input.value\n    if (innerValue.type === \"primitive\" && innerValue.value === \"u8\") {\n      return getChecksum([shapeIds.primitive, runtimePrimitiveIds.byteSequence])\n    }\n    return buildVector(innerValue)\n  }\n\n  const buildTuple = (entries: LookupEntry[]) =>\n    getChecksum([shapeIds.tuple, ...entries.map(buildNextChecksum)])\n\n  const buildStruct = (entries: StringRecord<LookupEntry>) =>\n    structLikeBuilder(shapeIds.struct, entries, buildNextChecksum)\n\n  if (input.type === \"tuple\") return buildTuple(input.value)\n\n  if (input.type === \"struct\") return buildStruct(input.value)\n\n  if (input.type === \"option\")\n    return getChecksum([shapeIds.option, buildNextChecksum(input.value)])\n\n  if (input.type === \"result\")\n    return getChecksum([\n      shapeIds.result,\n      buildNextChecksum(input.value.ok),\n      buildNextChecksum(input.value.ko),\n    ])\n\n  return structLikeBuilder(shapeIds.enum, input.value, (entry) => {\n    if (entry.type === \"lookupEntry\") return buildNextChecksum(entry.value)\n    switch (entry.type) {\n      case \"void\":\n        return getChecksum([shapeIds.void])\n      case \"tuple\":\n        return buildTuple(entry.value)\n      case \"struct\":\n        return buildStruct(entry.value)\n      case \"array\":\n        return buildVector(entry.value, entry.len)\n    }\n  })\n}\n\nconst sortCyclicGroups = (groups: Array<Set<number>>, graph: LookupGraph) => {\n  const getReachableNodes = (group: Set<number>) => {\n    const result = new Set<number>()\n    const toVisit = Array.from(group)\n    while (toVisit.length) {\n      const id = toVisit.pop()!\n      if (result.has(id)) continue\n      result.add(id)\n\n      graph.get(id)?.refs.forEach((id) => toVisit.push(id))\n    }\n\n    return Array.from(result)\n  }\n\n  const result: Array<Set<number>> = new Array()\n\n  function dependentsFirst(group: Set<number>) {\n    if (result.includes(group)) return\n    const dependents = groups.filter(\n      (candidate) =>\n        candidate !== group &&\n        getReachableNodes(group).some((node) => candidate.has(node)),\n    )\n    dependents.forEach((group) => dependentsFirst(group))\n    if (result.includes(group)) return\n    result.push(group)\n  }\n\n  groups.forEach((group) => dependentsFirst(group))\n  return result\n}\n\nfunction iterateChecksums(\n  group: Set<number>,\n  iterations: number,\n  cache: Map<number, bigint>,\n  graph: LookupGraph,\n) {\n  // Keep the values that are getting changed on each iteration in a separate\n  // cache, because two nodes referencing the same one should read the same\n  // previous iteration checksum for that node.\n  const groupReadCache = new Map([...group].map((id) => [id, 0n]))\n  const groupWriteCache = new Map<number, bigint>()\n\n  const recursiveBuildChecksum = (\n    entry: LookupEntry,\n    // The first call has to skip the cache, otherwise it would return the\n    // previous iteration result.\n    skipCache = true,\n  ): bigint => {\n    if (!skipCache && (groupReadCache.has(entry.id) || cache.has(entry.id))) {\n      return groupReadCache.get(entry.id) ?? cache.get(entry.id)!\n    }\n    const result = _buildChecksum(entry, (nextEntry) =>\n      recursiveBuildChecksum(nextEntry, false),\n    )\n    if (group.has(entry.id)) {\n      groupWriteCache.set(entry.id, result)\n    } else {\n      cache.set(entry.id, result)\n    }\n    return result\n  }\n\n  for (let i = 0; i < iterations; i++) {\n    group.forEach((id) => recursiveBuildChecksum(graph.get(id)!.entry))\n\n    group.forEach((id) => groupReadCache.set(id, groupWriteCache.get(id)!))\n  }\n\n  return groupReadCache\n}\n\nfunction getMirroredNodes(\n  cyclicGroups: Array<Set<number>>,\n  graph: LookupGraph,\n) {\n  const maxSize = cyclicGroups.reduce(\n    (acc, group) => Math.max(acc, group.size),\n    0,\n  )\n  const allEntries = new Set([...graph.values()].map((v) => v.entry.id))\n\n  const resultingChecksums = iterateChecksums(\n    allEntries,\n    maxSize,\n    // Cache won't be used, since it's using the internal one for every node.\n    new Map(),\n    graph,\n  )\n\n  const checksumToNodes = new Map<bigint, number[]>()\n  for (const id of allEntries) {\n    const checksum = resultingChecksums.get(id)\n    if (checksum == undefined) throw new Error(\"Unreachable\")\n    if (!checksumToNodes.has(checksum)) {\n      checksumToNodes.set(checksum, [])\n    }\n    checksumToNodes.get(checksum)!.push(id)\n  }\n\n  const checksumsWithDuplicates = [...checksumToNodes.entries()].filter(\n    ([, nodes]) => nodes.length > 1,\n  )\n\n  const duplicatesMap: Record<number, number[]> = {}\n  checksumsWithDuplicates.forEach(([, nodes]) => {\n    nodes.forEach((n) => (duplicatesMap[n] = nodes))\n  })\n\n  return duplicatesMap\n}\n\nconst buildChecksum = (\n  entry: LookupEntry,\n  cache: Map<number, bigint>,\n  graph: LookupGraph,\n) => {\n  if (cache.has(entry.id)) return cache.get(entry.id)!\n\n  const subGraph = getSubgraph(entry.id, graph)\n\n  const cycles = getStronglyConnectedComponents(subGraph).filter(\n    // SCCs can be of length=1, but for those we're only interested with those that are circular with themselves\n    (group) => group.size > 1 || isSelfCircular(group, subGraph),\n  )\n  const cyclicGroups = mergeSCCsWithCommonNodes(cycles).filter((group) => {\n    // Exclude groups that were previously calculated\n    return !cache.has(group.values().next().value!)\n  })\n  const mirrored = getMirroredNodes(cyclicGroups, subGraph)\n  const sortedCyclicGroups = sortCyclicGroups(cyclicGroups, subGraph)\n\n  sortedCyclicGroups.forEach((group) => {\n    if (cache.has(group.values().next().value!)) {\n      // exclude mirrored groups\n      return\n    }\n\n    const result = iterateChecksums(group, group.size, cache, graph)\n    group.forEach((id) => {\n      const checksum = result.get(id)!\n      if (id in mirrored) {\n        mirrored[id].forEach((id) => cache.set(id, checksum))\n      } else {\n        cache.set(id, checksum)\n      }\n    })\n  })\n\n  const getChecksum = (entry: LookupEntry) => {\n    if (cache.has(entry.id)) return cache.get(entry.id)!\n    return _buildChecksum(entry, getChecksum)\n  }\n\n  return getChecksum(entry)\n}\n\nconst isSelfCircular = (group: Set<number>, graph: LookupGraph) => {\n  if (group.size !== 1) return false\n  const [id] = group\n\n  return graph.get(id)!.refs.has(id)\n}\n\nexport const getChecksumBuilder = (getLookupEntryDef: MetadataLookup) => {\n  const { metadata } = getLookupEntryDef\n  const graph = buildLookupGraph(getLookupEntryDef, metadata.lookup.length)\n\n  const cache = new Map<number, bigint>()\n\n  const buildDefinition = (id: number): bigint =>\n    buildChecksum(getLookupEntryDef(id), cache, graph)\n\n  const buildStorage = (pallet: string, entry: string): bigint | null => {\n    try {\n      const storageEntry = metadata.pallets\n        .find((x) => x.name === pallet)!\n        .storage!.items.find((s) => s.name === entry)!\n\n      if (storageEntry.type.tag === \"plain\")\n        return buildDefinition(storageEntry.type.value)\n\n      const { key, value } = storageEntry.type.value\n      const val = buildDefinition(value)\n      const returnKey = buildDefinition(key)\n      return getChecksum([val, returnKey])\n    } catch (_) {\n      return null\n    }\n  }\n\n  const buildViewFns = (pallet: string, entry: string): bigint | null => {\n    try {\n      const viewFn = metadata.pallets\n        .find((x) => x.name === pallet)\n        ?.viewFns.find((x) => x.name === entry)\n      if (!viewFn) throw null\n\n      const argNamesChecksum = getStringChecksum(\n        viewFn.inputs.map((x) => x.name),\n      )\n      const argValuesChecksum = getChecksum(\n        viewFn.inputs.map((x) => buildDefinition(x.type)),\n      )\n      const outputChecksum = buildDefinition(viewFn.output)\n\n      return getChecksum([argNamesChecksum, argValuesChecksum, outputChecksum])\n    } catch (_) {\n      return null\n    }\n  }\n\n  const buildRuntimeCall = (api: string, method: string): bigint | null => {\n    try {\n      const entry = metadata.apis\n        .find((x) => x.name === api)\n        ?.methods.find((x) => x.name === method)\n      if (!entry) throw null\n\n      const argNamesChecksum = getStringChecksum(\n        entry.inputs.map((x) => x.name),\n      )\n      const argValuesChecksum = getChecksum(\n        entry.inputs.map((x) => buildDefinition(x.type)),\n      )\n      const outputChecksum = buildDefinition(entry.output)\n\n      return getChecksum([argNamesChecksum, argValuesChecksum, outputChecksum])\n    } catch (_) {\n      return null\n    }\n  }\n\n  const buildComposite = (\n    input: TupleVar | StructVar | VoidVar | ArrayVar,\n  ): bigint => {\n    if (input.type === \"void\") return getChecksum([0n])\n\n    if (input.type === \"tuple\") {\n      const values = Object.values(input.value).map((entry) =>\n        buildDefinition(entry.id),\n      )\n\n      return getChecksum([shapeIds.tuple, ...values])\n    }\n\n    if (input.type === \"array\") {\n      return getChecksum([\n        shapeIds.vector,\n        buildDefinition(input.value.id),\n        BigInt(input.len),\n      ])\n    }\n\n    // Otherwise struct\n    return structLikeBuilder(shapeIds.struct, input.value, (entry) =>\n      buildDefinition(entry.id),\n    )\n  }\n\n  const buildNamedTuple = (input: StructVar): bigint => {\n    return structLikeBuilder(shapeIds.tuple, input.value, (entry) =>\n      buildDefinition(entry.id),\n    )\n  }\n\n  const variantShapeId = {\n    errors: 1n,\n    events: 2n,\n    calls: 3n,\n  }\n  const buildVariant =\n    (variantType: \"errors\" | \"events\" | \"calls\") =>\n    (pallet: string, name: string): bigint | null => {\n      try {\n        const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n        const enumLookup = getLookupEntryDef(palletEntry[variantType]!.type)\n        buildDefinition(enumLookup.id)\n\n        if (enumLookup.type !== \"enum\") throw null\n        const entry = enumLookup.value[name]\n        const valueChecksum =\n          entry.type === \"lookupEntry\"\n            ? buildDefinition(entry.value.id)\n            : buildComposite(entry)\n        return getChecksum([variantShapeId[variantType], valueChecksum])\n      } catch (_) {\n        return null\n      }\n    }\n\n  const buildConstant = (\n    pallet: string,\n    constantName: string,\n  ): bigint | null => {\n    try {\n      const storageEntry = metadata.pallets\n        .find((x) => x.name === pallet)!\n        .constants!.find((s) => s.name === constantName)!\n\n      return buildDefinition(storageEntry.type)\n    } catch (_) {\n      return null\n    }\n  }\n\n  const toStringEnhancer =\n    <Args extends Array<any>>(\n      fn: (...args: Args) => bigint | null,\n    ): ((...args: Args) => string | null) =>\n    (...args) =>\n      fn(...args)?.toString(32) ?? null\n\n  return {\n    buildDefinition: toStringEnhancer(buildDefinition),\n    buildRuntimeCall: toStringEnhancer(buildRuntimeCall),\n    buildStorage: toStringEnhancer(buildStorage),\n    buildViewFns: toStringEnhancer(buildViewFns),\n    buildCall: toStringEnhancer(buildVariant(\"calls\")),\n    buildEvent: toStringEnhancer(buildVariant(\"events\")),\n    buildError: toStringEnhancer(buildVariant(\"errors\")),\n    buildConstant: toStringEnhancer(buildConstant),\n    buildComposite: toStringEnhancer(buildComposite),\n    buildNamedTuple: toStringEnhancer(buildNamedTuple),\n    getAllGeneratedChecksums: () =>\n      Array.from(cache.values()).map((v) => v.toString(32)),\n  }\n}\n"],"names":["entry","scale","inner","value","mapObject","h64","result","id","group","getChecksum"],"mappings":"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"}