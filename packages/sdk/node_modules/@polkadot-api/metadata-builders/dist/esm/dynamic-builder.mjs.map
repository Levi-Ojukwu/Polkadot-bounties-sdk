{"version":3,"file":"dynamic-builder.mjs","sources":["../../src/dynamic-builder.ts"],"sourcesContent":["import type { Codec, StringRecord } from \"@polkadot-api/substrate-bindings\"\nimport * as scale from \"@polkadot-api/substrate-bindings\"\nimport { mapObject } from \"@polkadot-api/utils\"\nimport type { EnumVar, MetadataLookup } from \"./lookups\"\nimport { getLookupCodecBuilder } from \"./lookup-codec-builder\"\n\nconst nullCodec = scale.enhanceCodec(\n  scale._void,\n  () => undefined,\n  () => null,\n)\n\nexport const getDynamicBuilder = (getLookupEntryDef: MetadataLookup) => {\n  const { metadata } = getLookupEntryDef\n  let buildDefinition = getLookupCodecBuilder(getLookupEntryDef)\n\n  const prefix = metadata.pallets\n    .find((x) => x.name === \"System\")\n    ?.constants.find((x) => x.name === \"SS58Prefix\")\n\n  let ss58Prefix: number | undefined\n  if (prefix) {\n    try {\n      const prefixVal = buildDefinition(prefix.type).dec(prefix.value)\n      if (typeof prefixVal === \"number\") {\n        ss58Prefix = prefixVal\n        buildDefinition = getLookupCodecBuilder(\n          getLookupEntryDef,\n          scale.AccountId(prefixVal),\n        )\n      }\n    } catch (_) {}\n  }\n\n  const storagePallets = new Map<string, ReturnType<typeof scale.Storage>>()\n\n  const buildStorage = (pallet: string, entry: string) => {\n    let storagePallet = storagePallets.get(pallet)\n    if (!storagePallet)\n      storagePallets.set(pallet, (storagePallet = scale.Storage(pallet)))\n\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .storage!.items.find((s) => s.name === entry)!\n\n    // if val is `void` it decodes to `undefined`, making it impossible\n    // to differentiate from a non-existant key\n    // therefore, if the key exists => null, if it doesn't => undefined\n    const withNullVoid = (codec: Codec<any>) =>\n      codec === scale._void ? nullCodec : codec\n\n    const storageWithFallback = (\n      len: number,\n      value: Codec<any>,\n      ...args: Parameters<ReturnType<typeof scale.Storage>>\n    ) => {\n      const keys = storagePallet!(...args)\n      const [, ...encodersWithHash] = args\n      return {\n        args: scale.Tuple(...encodersWithHash.map(([codec]) => codec)),\n        keys,\n        value,\n        len,\n        fallback:\n          storageEntry.modifier === 1\n            ? value.dec(storageEntry.fallback)\n            : undefined,\n      }\n    }\n\n    if (storageEntry.type.tag === \"plain\")\n      return storageWithFallback(\n        0,\n        withNullVoid(buildDefinition(storageEntry.type.value)),\n        entry,\n      )\n\n    const { key, value, hashers } = storageEntry.type.value\n    const val = withNullVoid(buildDefinition(value))\n    const hashes = hashers.map((x) => scale[x.tag])\n\n    const hashArgs: scale.EncoderWithHash<unknown>[] = (() => {\n      if (hashes.length === 1) {\n        return [[buildDefinition(key), hashes[0]]]\n      }\n\n      const keyDef = getLookupEntryDef(key)\n\n      switch (keyDef.type) {\n        case \"array\":\n          return hashes.map((hash) => [buildDefinition(keyDef.value.id), hash])\n        case \"tuple\":\n          return keyDef.value.map((x, idx) => [\n            buildDefinition(x.id),\n            hashes[idx],\n          ])\n        default:\n          throw new Error(\"Invalid key type\")\n      }\n    })()\n\n    return storageWithFallback(hashes.length, val, entry, ...hashArgs)\n  }\n\n  const buildEnumEntry = (\n    entry: EnumVar[\"value\"][keyof EnumVar[\"value\"]],\n  ): Codec<any> => {\n    switch (entry.type) {\n      case \"void\":\n        return scale._void\n      case \"lookupEntry\":\n        return buildDefinition(entry.value.id)\n      case \"tuple\":\n        return scale.Tuple(\n          ...Object.values(entry.value).map((l) => buildDefinition(l.id)),\n        )\n      case \"struct\":\n        return scale.Struct(\n          mapObject(entry.value, (x) => buildDefinition(x.id)) as StringRecord<\n            Codec<any>\n          >,\n        )\n      case \"array\":\n        return scale.Vector(buildDefinition(entry.value.id), entry.len)\n    }\n  }\n\n  const buildConstant = (pallet: string, constantName: string) => {\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .constants!.find((s) => s.name === constantName)!\n\n    return buildDefinition(storageEntry.type as number)\n  }\n\n  const buildVariant =\n    (type: \"errors\" | \"events\" | \"calls\") =>\n    (\n      pallet: string,\n      name: string,\n    ): {\n      codec: Codec<any>\n      location: [number, number]\n    } => {\n      const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n      const lookup = getLookupEntryDef(palletEntry[type]!.type)\n      if (lookup.type !== \"enum\") throw null\n      const entry = lookup.value[name]\n\n      return {\n        location: [palletEntry.index, entry.idx],\n        codec: buildEnumEntry(lookup.value[name]),\n      }\n    }\n\n  const buildViewFn = (pallet: string, entry: string) => {\n    const fn = metadata.pallets\n      .find((x) => x.name === pallet)\n      ?.viewFns.find((x) => x.name === entry)\n    if (!fn) throw null\n\n    return {\n      args: scale.Tuple(...fn.inputs.map((x) => buildDefinition(x.type))),\n      value: buildDefinition(fn.output),\n    }\n  }\n\n  const buildRuntimeCall = (api: string, method: string) => {\n    const entry = metadata.apis\n      .find((x) => x.name === api)\n      ?.methods.find((x) => x.name === method)\n    if (!entry) throw null\n\n    return {\n      args: scale.Tuple(...entry.inputs.map((x) => buildDefinition(x.type))),\n      value: buildDefinition(entry.output),\n    }\n  }\n\n  return {\n    buildDefinition,\n    buildStorage,\n    buildEvent: buildVariant(\"events\"),\n    buildError: buildVariant(\"errors\"),\n    buildViewFn,\n    buildRuntimeCall,\n    buildCall: buildVariant(\"calls\"),\n    buildConstant,\n    ss58Prefix,\n  }\n}\n"],"names":["value"],"mappings":";;;;AAMA,MAAM,YAAY,KAAA,CAAM,YAAA;AAAA,EACtB,KAAA,CAAM,KAAA;AAAA,EACN,MAAM,MAAA;AAAA,EACN,MAAM;AACR,CAAA;AAEO,MAAM,iBAAA,GAAoB,CAAC,iBAAA,KAAsC;AACtE,EAAA,MAAM,EAAE,UAAS,GAAI,iBAAA;AACrB,EAAA,IAAI,eAAA,GAAkB,sBAAsB,iBAAiB,CAAA;AAE7D,EAAA,MAAM,SAAS,QAAA,CAAS,OAAA,CACrB,IAAA,CAAK,CAAC,MAAM,CAAA,CAAE,IAAA,KAAS,QAAQ,CAAA,EAC9B,UAAU,IAAA,CAAK,CAAC,CAAA,KAAM,CAAA,CAAE,SAAS,YAAY,CAAA;AAEjD,EAAA,IAAI,UAAA;AACJ,EAAA,IAAI,MAAA,EAAQ;AACV,IAAA,IAAI;AACF,MAAA,MAAM,YAAY,eAAA,CAAgB,MAAA,CAAO,IAAI,CAAA,CAAE,GAAA,CAAI,OAAO,KAAK,CAAA;AAC/D,MAAA,IAAI,OAAO,cAAc,QAAA,EAAU;AACjC,QAAA,UAAA,GAAa,SAAA;AACb,QAAA,eAAA,GAAkB,qBAAA;AAAA,UAChB,iBAAA;AAAA,UACA,KAAA,CAAM,UAAU,SAAS;AAAA,SAC3B;AAAA,MACF;AAAA,IACF,SAAS,CAAA,EAAG;AAAA,IAAC;AAAA,EACf;AAEA,EAAA,MAAM,cAAA,uBAAqB,GAAA,EAA8C;AAEzE,EAAA,MAAM,YAAA,GAAe,CAAC,MAAA,EAAgB,KAAA,KAAkB;AACtD,IAAA,IAAI,aAAA,GAAgB,cAAA,CAAe,GAAA,CAAI,MAAM,CAAA;AAC7C,IAAA,IAAI,CAAC,aAAA;AACH,MAAA,cAAA,CAAe,IAAI,MAAA,EAAS,aAAA,GAAgB,KAAA,CAAM,OAAA,CAAQ,MAAM,CAAE,CAAA;AAEpE,IAAA,MAAM,eAAe,QAAA,CAAS,OAAA,CAC3B,IAAA,CAAK,CAAC,MAAM,CAAA,CAAE,IAAA,KAAS,MAAM,CAAA,CAC7B,QAAS,KAAA,CAAM,IAAA,CAAK,CAAC,CAAA,KAAM,CAAA,CAAE,SAAS,KAAK,CAAA;AAK9C,IAAA,MAAM,eAAe,CAAC,KAAA,KACpB,KAAA,KAAU,KAAA,CAAM,QAAQ,SAAA,GAAY,KAAA;AAEtC,IAAA,MAAM,mBAAA,GAAsB,CAC1B,GAAA,EACAA,MAAAA,EAAAA,GACG,IAAA,KACA;AACH,MAAA,MAAM,IAAA,GAAO,aAAA,CAAe,GAAG,IAAI,CAAA;AACnC,MAAA,MAAM,GAAG,GAAG,gBAAgB,CAAA,GAAI,IAAA;AAChC,MAAA,OAAO;AAAA,QACL,IAAA,EAAM,KAAA,CAAM,KAAA,CAAM,GAAG,gBAAA,CAAiB,GAAA,CAAI,CAAC,CAAC,KAAK,CAAA,KAAM,KAAK,CAAC,CAAA;AAAA,QAC7D,IAAA;AAAA,QACA,KAAA,EAAAA,MAAAA;AAAA,QACA,GAAA;AAAA,QACA,QAAA,EACE,aAAa,QAAA,KAAa,CAAA,GACtBA,OAAM,GAAA,CAAI,YAAA,CAAa,QAAQ,CAAA,GAC/B;AAAA,OACR;AAAA,IACF,CAAA;AAEA,IAAA,IAAI,YAAA,CAAa,KAAK,GAAA,KAAQ,OAAA;AAC5B,MAAA,OAAO,mBAAA;AAAA,QACL,CAAA;AAAA,QACA,YAAA,CAAa,eAAA,CAAgB,YAAA,CAAa,IAAA,CAAK,KAAK,CAAC,CAAA;AAAA,QACrD;AAAA,OACF;AAEF,IAAA,MAAM,EAAE,GAAA,EAAK,KAAA,EAAO,OAAA,EAAQ,GAAI,aAAa,IAAA,CAAK,KAAA;AAClD,IAAA,MAAM,GAAA,GAAM,YAAA,CAAa,eAAA,CAAgB,KAAK,CAAC,CAAA;AAC/C,IAAA,MAAM,MAAA,GAAS,QAAQ,GAAA,CAAI,CAAC,MAAM,KAAA,CAAM,CAAA,CAAE,GAAG,CAAC,CAAA;AAE9C,IAAA,MAAM,YAA8C,MAAM;AACxD,MAAA,IAAI,MAAA,CAAO,WAAW,CAAA,EAAG;AACvB,QAAA,OAAO,CAAC,CAAC,eAAA,CAAgB,GAAG,GAAG,MAAA,CAAO,CAAC,CAAC,CAAC,CAAA;AAAA,MAC3C;AAEA,MAAA,MAAM,MAAA,GAAS,kBAAkB,GAAG,CAAA;AAEpC,MAAA,QAAQ,OAAO,IAAA;AAAM,QACnB,KAAK,OAAA;AACH,UAAA,OAAO,MAAA,CAAO,GAAA,CAAI,CAAC,IAAA,KAAS,CAAC,eAAA,CAAgB,MAAA,CAAO,KAAA,CAAM,EAAE,CAAA,EAAG,IAAI,CAAC,CAAA;AAAA,QACtE,KAAK,OAAA;AACH,UAAA,OAAO,MAAA,CAAO,KAAA,CAAM,GAAA,CAAI,CAAC,GAAG,GAAA,KAAQ;AAAA,YAClC,eAAA,CAAgB,EAAE,EAAE,CAAA;AAAA,YACpB,OAAO,GAAG;AAAA,WACX,CAAA;AAAA,QACH;AACE,UAAA,MAAM,IAAI,MAAM,kBAAkB,CAAA;AAAA;AACtC,IACF,CAAA,GAAG;AAEH,IAAA,OAAO,oBAAoB,MAAA,CAAO,MAAA,EAAQ,GAAA,EAAK,KAAA,EAAO,GAAG,QAAQ,CAAA;AAAA,EACnE,CAAA;AAEA,EAAA,MAAM,cAAA,GAAiB,CACrB,KAAA,KACe;AACf,IAAA,QAAQ,MAAM,IAAA;AAAM,MAClB,KAAK,MAAA;AACH,QAAA,OAAO,KAAA,CAAM,KAAA;AAAA,MACf,KAAK,aAAA;AACH,QAAA,OAAO,eAAA,CAAgB,KAAA,CAAM,KAAA,CAAM,EAAE,CAAA;AAAA,MACvC,KAAK,OAAA;AACH,QAAA,OAAO,KAAA,CAAM,KAAA;AAAA,UACX,GAAG,MAAA,CAAO,MAAA,CAAO,KAAA,CAAM,KAAK,CAAA,CAAE,GAAA,CAAI,CAAC,CAAA,KAAM,eAAA,CAAgB,CAAA,CAAE,EAAE,CAAC;AAAA,SAChE;AAAA,MACF,KAAK,QAAA;AACH,QAAA,OAAO,KAAA,CAAM,MAAA;AAAA,UACX,SAAA,CAAU,MAAM,KAAA,EAAO,CAAC,MAAM,eAAA,CAAgB,CAAA,CAAE,EAAE,CAAC;AAAA,SAGrD;AAAA,MACF,KAAK,OAAA;AACH,QAAA,OAAO,KAAA,CAAM,OAAO,eAAA,CAAgB,KAAA,CAAM,MAAM,EAAE,CAAA,EAAG,MAAM,GAAG,CAAA;AAAA;AAClE,EACF,CAAA;AAEA,EAAA,MAAM,aAAA,GAAgB,CAAC,MAAA,EAAgB,YAAA,KAAyB;AAC9D,IAAA,MAAM,eAAe,QAAA,CAAS,OAAA,CAC3B,IAAA,CAAK,CAAC,MAAM,CAAA,CAAE,IAAA,KAAS,MAAM,CAAA,CAC7B,UAAW,IAAA,CAAK,CAAC,CAAA,KAAM,CAAA,CAAE,SAAS,YAAY,CAAA;AAEjD,IAAA,OAAO,eAAA,CAAgB,aAAa,IAAc,CAAA;AAAA,EACpD,CAAA;AAEA,EAAA,MAAM,YAAA,GACJ,CAAC,IAAA,KACD,CACE,QACA,IAAA,KAIG;AACH,IAAA,MAAM,WAAA,GAAc,SAAS,OAAA,CAAQ,IAAA,CAAK,CAAC,CAAA,KAAM,CAAA,CAAE,SAAS,MAAM,CAAA;AAClE,IAAA,MAAM,MAAA,GAAS,iBAAA,CAAkB,WAAA,CAAY,IAAI,EAAG,IAAI,CAAA;AACxD,IAAA,IAAI,MAAA,CAAO,IAAA,KAAS,MAAA,EAAQ,MAAM,IAAA;AAClC,IAAA,MAAM,KAAA,GAAQ,MAAA,CAAO,KAAA,CAAM,IAAI,CAAA;AAE/B,IAAA,OAAO;AAAA,MACL,QAAA,EAAU,CAAC,WAAA,CAAY,KAAA,EAAO,MAAM,GAAG,CAAA;AAAA,MACvC,KAAA,EAAO,cAAA,CAAe,MAAA,CAAO,KAAA,CAAM,IAAI,CAAC;AAAA,KAC1C;AAAA,EACF,CAAA;AAEF,EAAA,MAAM,WAAA,GAAc,CAAC,MAAA,EAAgB,KAAA,KAAkB;AACrD,IAAA,MAAM,KAAK,QAAA,CAAS,OAAA,CACjB,IAAA,CAAK,CAAC,MAAM,CAAA,CAAE,IAAA,KAAS,MAAM,CAAA,EAC5B,QAAQ,IAAA,CAAK,CAAC,CAAA,KAAM,CAAA,CAAE,SAAS,KAAK,CAAA;AACxC,IAAA,IAAI,CAAC,IAAI,MAAM,IAAA;AAEf,IAAA,OAAO;AAAA,MACL,IAAA,EAAM,KAAA,CAAM,KAAA,CAAM,GAAG,EAAA,CAAG,MAAA,CAAO,GAAA,CAAI,CAAC,CAAA,KAAM,eAAA,CAAgB,CAAA,CAAE,IAAI,CAAC,CAAC,CAAA;AAAA,MAClE,KAAA,EAAO,eAAA,CAAgB,EAAA,CAAG,MAAM;AAAA,KAClC;AAAA,EACF,CAAA;AAEA,EAAA,MAAM,gBAAA,GAAmB,CAAC,GAAA,EAAa,MAAA,KAAmB;AACxD,IAAA,MAAM,QAAQ,QAAA,CAAS,IAAA,CACpB,IAAA,CAAK,CAAC,MAAM,CAAA,CAAE,IAAA,KAAS,GAAG,CAAA,EACzB,QAAQ,IAAA,CAAK,CAAC,CAAA,KAAM,CAAA,CAAE,SAAS,MAAM,CAAA;AACzC,IAAA,IAAI,CAAC,OAAO,MAAM,IAAA;AAElB,IAAA,OAAO;AAAA,MACL,IAAA,EAAM,KAAA,CAAM,KAAA,CAAM,GAAG,KAAA,CAAM,MAAA,CAAO,GAAA,CAAI,CAAC,CAAA,KAAM,eAAA,CAAgB,CAAA,CAAE,IAAI,CAAC,CAAC,CAAA;AAAA,MACrE,KAAA,EAAO,eAAA,CAAgB,KAAA,CAAM,MAAM;AAAA,KACrC;AAAA,EACF,CAAA;AAEA,EAAA,OAAO;AAAA,IACL,eAAA;AAAA,IACA,YAAA;AAAA,IACA,UAAA,EAAY,aAAa,QAAQ,CAAA;AAAA,IACjC,UAAA,EAAY,aAAa,QAAQ,CAAA;AAAA,IACjC,WAAA;AAAA,IACA,gBAAA;AAAA,IACA,SAAA,EAAW,aAAa,OAAO,CAAA;AAAA,IAC/B,aAAA;AAAA,IACA;AAAA,GACF;AACF;;;;"}