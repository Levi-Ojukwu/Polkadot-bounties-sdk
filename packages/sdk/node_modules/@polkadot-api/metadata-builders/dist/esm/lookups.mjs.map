{"version":3,"file":"lookups.mjs","sources":["../../src/lookups.ts"],"sourcesContent":["import type {\n  StringRecord,\n  UnifiedMetadata,\n  V14Lookup,\n} from \"@polkadot-api/substrate-bindings\"\n\nexport type SignedPrimitive = \"i8\" | \"i16\" | \"i32\" | \"i64\" | \"i128\" | \"i256\"\nexport type UnsignedPrimitive = \"u8\" | \"u16\" | \"u32\" | \"u64\" | \"u128\" | \"u256\"\nexport type MetadataPrimitives =\n  | \"bool\"\n  | \"char\"\n  | \"str\"\n  | SignedPrimitive\n  | UnsignedPrimitive\n\nexport type PrimitiveVar = {\n  type: \"primitive\"\n  value: MetadataPrimitives\n}\n\nexport type VoidVar = { type: \"void\" }\nexport type CompactVar = {\n  type: \"compact\"\n  isBig: boolean\n  size: UnsignedPrimitive\n}\nexport type BitSequenceVar = {\n  type: \"bitSequence\"\n  isLSB: boolean\n}\nexport type AccountId32 = { type: \"AccountId32\" }\nexport type AccountId20 = { type: \"AccountId20\" }\nexport type TerminalVar =\n  | PrimitiveVar\n  | VoidVar\n  | CompactVar\n  | BitSequenceVar\n  | AccountId32\n  | AccountId20\n\n/* Array-like vars:\n * - TupleVar: Mixed types, fixed length\n * - Sequence: One type, arbitrary length\n * - Array: One type, fixed length\n */\nexport type TupleVar = {\n  type: \"tuple\"\n  value: LookupEntry[]\n  innerDocs: Array<string[]>\n}\nexport type StructVar = {\n  type: \"struct\"\n  value: StringRecord<LookupEntry>\n  innerDocs: StringRecord<string[]>\n}\nexport type EnumVar = {\n  type: \"enum\"\n  value: StringRecord<\n    (\n      | { type: \"lookupEntry\"; value: LookupEntry }\n      | VoidVar\n      | TupleVar\n      | StructVar\n      | ArrayVar\n    ) & { idx: number }\n  >\n  innerDocs: StringRecord<string[]>\n  byteLength?: number\n}\nexport type OptionVar = {\n  type: \"option\"\n  value: LookupEntry\n}\nexport type ResultVar = {\n  type: \"result\"\n  value: { ok: LookupEntry; ko: LookupEntry }\n}\nexport type SequenceVar = {\n  type: \"sequence\"\n  value: LookupEntry\n}\nexport type ArrayVar = {\n  type: \"array\"\n  value: LookupEntry\n  len: number\n}\n\nexport type ComposedVar =\n  | TupleVar\n  | StructVar\n  | SequenceVar\n  | ArrayVar\n  | OptionVar\n  | ResultVar\n  | EnumVar\n\nexport type Var = TerminalVar | ComposedVar\n\nexport type LookupEntry = {\n  id: number\n} & Var\n\nconst isBytes = (value: LookupEntry, nBytes: number) =>\n  value.type === \"array\" &&\n  value.len === nBytes &&\n  value.value.type === \"primitive\" &&\n  value.value.value === \"u8\"\n\nconst _void: VoidVar = { type: \"void\" }\n\nexport interface MetadataLookup {\n  (id: number): LookupEntry\n  metadata: UnifiedMetadata\n  call: number | null\n}\n\nconst _denormalizeLookup = (\n  lookupData: V14Lookup,\n  customMap: (value: V14Lookup[number]) => Var | null = () => null,\n): ((id: number) => LookupEntry) => {\n  const lookups = new Map<number, LookupEntry>()\n  const from = new Set<number>()\n\n  const withCache = (\n    fn: (id: number) => Var,\n  ): ((id: number) => LookupEntry) => {\n    return (id) => {\n      let entry = lookups.get(id)\n\n      if (entry) return entry\n\n      if (from.has(id)) {\n        const entry = {\n          id,\n        } as LookupEntry\n\n        lookups.set(id, entry)\n        return entry\n      }\n\n      from.add(id)\n      const value = fn(id)\n      entry = lookups.get(id)\n\n      if (entry) {\n        Object.assign(entry, value)\n      } else {\n        entry = {\n          id,\n          ...value,\n        }\n        lookups.set(id, entry!)\n      }\n      from.delete(id)\n      return entry\n    }\n  }\n\n  let isAccountId32SearchOn = true\n  let isAccountId20SearchOn = true\n  const getLookupEntryDef = withCache((id): Var => {\n    const custom = customMap(lookupData[id])\n    if (custom) return custom\n\n    const { def, path, params } = lookupData[id]\n\n    if (def.tag === \"composite\") {\n      if (def.value.length === 0) return _void\n\n      // used to be a \"pointer\"\n      if (def.value.length === 1) {\n        const inner = getLookupEntryDef(def.value[0].type as number)\n\n        if (\n          isAccountId32SearchOn &&\n          path.at(-1) === \"AccountId32\" &&\n          isBytes(inner, 32)\n        ) {\n          isAccountId32SearchOn = false\n          return { type: \"AccountId32\" }\n        }\n\n        if (\n          isAccountId20SearchOn &&\n          path.at(-1) === \"AccountId20\" &&\n          isBytes(inner, 20)\n        ) {\n          isAccountId20SearchOn = false\n          return { type: \"AccountId20\" }\n        }\n\n        return inner\n      }\n\n      return getComplexVar(def.value)\n    }\n\n    if (def.tag === \"variant\") {\n      if (\n        path.length === 1 &&\n        path[0] === \"Option\" &&\n        params.length === 1 &&\n        params[0].name === \"T\"\n      ) {\n        const value = getLookupEntryDef(params[0].type!)\n        return value.type === \"void\"\n          ? // Option<void> would return a Codec<undefined> which makes no sense\n            // Therefore, we better treat it as a bool\n            { type: \"primitive\", value: \"bool\" }\n          : {\n              type: \"option\",\n              value,\n            }\n      }\n\n      if (\n        path.length === 1 &&\n        path[0] === \"Result\" &&\n        params.length === 2 &&\n        params[0].name === \"T\" &&\n        params[1].name === \"E\"\n      ) {\n        return {\n          type: \"result\",\n          value: {\n            ok: getLookupEntryDef(params[0].type as number),\n            ko: getLookupEntryDef(params[1].type as number),\n          },\n        }\n      }\n      if (def.value.length === 0) return _void\n\n      const enumValue: StringRecord<EnumVar[\"value\"][keyof EnumVar[\"value\"]]> =\n        {}\n      const enumDocs: StringRecord<string[]> = {}\n\n      def.value.forEach((x) => {\n        const key = x.name\n        enumDocs[key] = x.docs\n\n        if (x.fields.length === 0) {\n          enumValue[key] = { ..._void, idx: x.index }\n          return\n        }\n\n        if (x.fields.length === 1 && !x.fields[0].name) {\n          enumValue[key] = {\n            type: \"lookupEntry\",\n            value: getLookupEntryDef(x.fields[0].type),\n            idx: x.index,\n          }\n          return\n        }\n\n        enumValue[key] = { ...getComplexVar(x.fields), idx: x.index }\n      })\n\n      return {\n        type: \"enum\",\n        value: enumValue,\n        innerDocs: enumDocs,\n      }\n    }\n\n    if (def.tag === \"sequence\")\n      return {\n        type: \"sequence\",\n        value: getLookupEntryDef(def.value as number),\n      }\n\n    if (def.tag === \"array\") {\n      const { len } = def.value\n      const value = getLookupEntryDef(def.value.type)\n\n      return !len || value.type === \"void\"\n        ? _void\n        : len > 1\n          ? {\n              type: \"array\",\n              value,\n              len: def.value.len,\n            }\n          : value\n    }\n\n    if (def.tag === \"tuple\") {\n      if (def.value.length === 0) return _void\n\n      return def.value.length > 1\n        ? getArrayOrTuple(\n            def.value.map((x) => getLookupEntryDef(x as number)),\n            def.value.map((x) => lookupData[x].docs),\n          )\n        : getLookupEntryDef(def.value[0] as number) // use to be a \"pointer\"\n    }\n\n    if (def.tag === \"primitive\") {\n      return {\n        type: \"primitive\",\n        value: def.value.tag,\n      }\n    }\n\n    if (def.tag === \"compact\") {\n      const translated = getLookupEntryDef(def.value) as PrimitiveVar | VoidVar\n      if (translated.type === \"void\") return _void\n\n      const isBig = Number(translated.value.slice(1)) > 32\n\n      return {\n        type: \"compact\",\n        isBig,\n        size: translated.value as UnsignedPrimitive,\n      }\n    }\n\n    // bitSequence\n    return {\n      type: def.tag,\n      isLSB: (lookupData[def.value.bitOrderType].path.at(-1) ?? \"LSB\")\n        .toUpperCase()\n        .startsWith(\"LSB\"),\n    }\n  })\n\n  const getComplexVar = (\n    input: Array<{ type: number; name?: string; docs: string[] }>,\n  ): TupleVar | StructVar | ArrayVar | VoidVar => {\n    let allKey = true\n\n    const values: Record<string | number, LookupEntry> = {}\n    const innerDocs: Record<string | number, string[]> = {}\n\n    input.forEach((x, idx) => {\n      allKey = allKey && !!x.name\n      const key = x.name || idx\n      const value = getLookupEntryDef(x.type as number)\n      if (value.type !== \"void\") {\n        values[key] = value\n        innerDocs[key] = x.docs\n      }\n    })\n    return allKey\n      ? {\n          type: \"struct\",\n          value: values as StringRecord<LookupEntry>,\n          innerDocs: innerDocs as StringRecord<string[]>,\n        }\n      : getArrayOrTuple(Object.values(values), Object.values(innerDocs))\n  }\n\n  const getArrayOrTuple = (\n    values: Array<LookupEntry>,\n    innerDocs: Array<string[]>,\n  ): TupleVar | ArrayVar | VoidVar => {\n    if (\n      values.every((v) => v.id === values[0].id) &&\n      innerDocs.every((doc) => !doc.length)\n    ) {\n      const [value] = values\n      return value.type === \"void\"\n        ? _void\n        : {\n            type: \"array\",\n            value: values[0],\n            len: values.length,\n          }\n    }\n    return {\n      type: \"tuple\",\n      value: values,\n      innerDocs: innerDocs,\n    }\n  }\n\n  return getLookupEntryDef\n}\n\nexport const denormalizeLookup = (lookupData: V14Lookup) =>\n  _denormalizeLookup(lookupData)\n\nexport const getLookupFn = (metadata: UnifiedMetadata): MetadataLookup => {\n  const getLookupEntryDef = _denormalizeLookup(metadata.lookup, ({ def }) => {\n    if (def.tag === \"composite\") {\n      const moduleErrorLength = getModuleErrorLength(def)\n      if (moduleErrorLength) {\n        return {\n          type: \"enum\",\n          innerDocs: {},\n          value: Object.fromEntries(\n            metadata.pallets.map((p) => [\n              p.name,\n              p.errors == null\n                ? { ..._void, idx: p.index }\n                : {\n                    type: \"lookupEntry\" as const,\n                    value: getLookupEntryDef(p.errors.type),\n                    idx: p.index,\n                  },\n            ]),\n          ) as StringRecord<\n            (\n              | VoidVar\n              | {\n                  type: \"lookupEntry\"\n                  value: LookupEntry\n                }\n            ) & { idx: number }\n          >,\n          byteLength: moduleErrorLength,\n        }\n      }\n    }\n    return null\n  })\n\n  function getModuleErrorLength(def: {\n    tag: \"composite\"\n    value: {\n      name: string | undefined\n      type: number\n      typeName: string | undefined\n      docs: string[]\n    }[]\n  }) {\n    const preChecks =\n      def.value.length === 2 &&\n      def.value[0].name === \"index\" &&\n      def.value[1].name === \"error\"\n    if (!preChecks) return null\n\n    const index = getLookupEntryDef(def.value[0].type)\n    const error = getLookupEntryDef(def.value[1].type)\n\n    return index.type === \"primitive\" &&\n      index.value === \"u8\" &&\n      error.type === \"array\" &&\n      error.value.type === \"primitive\" &&\n      error.value.value === \"u8\"\n      ? 1 + error.len\n      : null\n  }\n\n  const getCall = () => {\n    if (\"call\" in metadata.extrinsic) {\n      return metadata.extrinsic.call\n    }\n\n    const extrinsic = metadata.lookup[metadata.extrinsic.type]\n    const call = extrinsic?.params.find((p) => p.name === \"Call\")\n\n    return call?.type ?? null\n  }\n\n  return Object.assign(getLookupEntryDef, { metadata, call: getCall() })\n}\n"],"names":["entry"],"mappings":"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"}