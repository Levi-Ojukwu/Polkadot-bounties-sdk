{"version":3,"file":"lookup-graph.mjs","sources":["../../src/lookup-graph.ts"],"sourcesContent":["import { LookupEntry } from \"./lookups\"\n\nexport type LookupGraph = Map<\n  number,\n  { entry: LookupEntry; backRefs: Set<number>; refs: Set<number> }\n>\n\nexport function buildLookupGraph(\n  lookupFn: (id: number) => LookupEntry,\n  lookupLength: number,\n): LookupGraph {\n  const result: LookupGraph = new Map()\n  const visited = new Set<number>()\n\n  const addEdge = (from: number, to: number) => {\n    if (!result.has(from))\n      result.set(from, {\n        entry: lookupFn(from),\n        backRefs: new Set(),\n        refs: new Set(),\n      })\n    if (!result.has(to))\n      result.set(to, {\n        entry: lookupFn(to),\n        backRefs: new Set(),\n        refs: new Set(),\n      })\n    result.get(from)!.refs.add(to)\n    result.get(to)!.backRefs.add(from)\n  }\n\n  for (let i = 0; i < lookupLength; i++) {\n    const entry = lookupFn(i)\n    if (i !== entry.id) {\n      // Lookup solved a pointer, but we still need to add that node into our\n      // graph in case someone access it from there.\n      addEdge(i, entry.id)\n    }\n    if (visited.has(entry.id)) continue\n    visited.add(entry.id)\n\n    switch (entry.type) {\n      case \"array\":\n      case \"option\":\n      case \"sequence\":\n        addEdge(entry.id, entry.value.id)\n        break\n      case \"enum\":\n        Object.values(entry.value).forEach((enumEntry) => {\n          switch (enumEntry.type) {\n            case \"array\":\n            case \"lookupEntry\":\n              addEdge(entry.id, enumEntry.value.id)\n              break\n            case \"struct\":\n            case \"tuple\":\n              Object.values(enumEntry.value).forEach((v) =>\n                addEdge(entry.id, v.id),\n              )\n              break\n          }\n        })\n        break\n      case \"result\":\n        addEdge(entry.id, entry.value.ok.id)\n        addEdge(entry.id, entry.value.ko.id)\n        break\n      case \"struct\":\n      case \"tuple\":\n        Object.values(entry.value).forEach((v) => addEdge(entry.id, v.id))\n        break\n    }\n\n    // It could be that this node is not being referenced by any other type\n    // nor it references anything. We still have to add it into the graph.\n    if (!result.has(entry.id)) {\n      result.set(entry.id, {\n        backRefs: new Set(),\n        refs: new Set(),\n        entry,\n      })\n    }\n  }\n\n  return result\n}\n\nconst subgraphCache = new WeakMap<LookupGraph, Map<number, LookupGraph>>()\nfunction _getSubgraph(\n  id: number,\n  graph: LookupGraph,\n  result: LookupGraph,\n  cache: Map<number, LookupGraph>,\n) {\n  if (result.has(id)) return\n  const node = graph.get(id)!\n  result.set(id, node)\n  cache.set(id, result)\n\n  node.refs.forEach((ref) => _getSubgraph(ref, graph, result, cache))\n  node.backRefs.forEach((ref) => _getSubgraph(ref, graph, result, cache))\n}\n\nexport function getSubgraph(id: number, graph: LookupGraph) {\n  if (!subgraphCache.has(graph)) {\n    subgraphCache.set(graph, new Map())\n  }\n  const cache = subgraphCache.get(graph)!\n  if (cache.has(id)) return cache.get(id)!\n\n  const result: LookupGraph = new Map()\n  _getSubgraph(id, graph, result, cache)\n  return result\n}\n\nexport function getStronglyConnectedComponents(graph: LookupGraph) {\n  // Tarjan's strongly connected components\n  const tarjanState = new Map<\n    number,\n    {\n      index: number\n      lowLink: number\n      onStack: boolean\n    }\n  >()\n  let index = 0\n  const stack: number[] = []\n  const result: Array<Set<number>> = []\n\n  function strongConnect(v: number): void {\n    const state = {\n      index: index,\n      lowLink: index,\n      onStack: true,\n    }\n    tarjanState.set(v, state)\n    index++\n    stack.push(v)\n\n    const edges = graph.get(v)!.refs\n    for (let w of edges) {\n      const edgeState = tarjanState.get(w)\n      if (!edgeState) {\n        strongConnect(w)\n        state.lowLink = Math.min(state.lowLink, tarjanState.get(w)!.lowLink)\n      } else if (edgeState.onStack) {\n        state.lowLink = Math.min(state.lowLink, edgeState.index)\n      }\n    }\n\n    if (state.lowLink === state.index) {\n      const component = new Set<number>()\n\n      let poppedNode = -1\n      do {\n        poppedNode = stack.pop()!\n        tarjanState.get(poppedNode)!.onStack = false\n        component.add(poppedNode)\n      } while (poppedNode !== v)\n\n      result.push(component)\n    }\n  }\n\n  for (const node of graph.keys()) {\n    if (!tarjanState.has(node)) {\n      strongConnect(node)\n    }\n  }\n\n  return result\n}\n\nexport function mergeSCCsWithCommonNodes(\n  stronglyConnectedComponents: Array<Set<number>>,\n) {\n  /**\n   * For Nodes that are shared between two sets of SCCs, we need to calculate\n   * the checksum for the both of them, which wouldn't work (it would give\n   * different checksums).\n   * So we merge the SCCs that are using shared nodes into one group.\n   */\n  const scc = stronglyConnectedComponents\n  const ungroupedCycles = new Set(scc.map((_, i) => i))\n  const edges = new Map(scc.map((_, i) => [i, new Set<number>()]))\n  scc.forEach((cycle, i) => {\n    scc.slice(i + 1).forEach((otherCycle, _j) => {\n      const j = _j + i + 1\n      const combined = new Set([...cycle, ...otherCycle])\n      if (combined.size !== cycle.size + otherCycle.size) {\n        edges.get(i)!.add(j)\n        edges.get(j)!.add(i)\n      }\n    })\n  })\n  const groups: Array<Set<number>> = []\n\n  while (ungroupedCycles.size) {\n    const group = new Set<number>()\n    const toVisit = [ungroupedCycles.values().next().value!]\n    while (toVisit.length) {\n      const idx = toVisit.pop()!\n      if (!ungroupedCycles.has(idx)) continue\n      ungroupedCycles.delete(idx)\n\n      const cycle = scc[idx]\n      cycle.forEach((v) => group.add(Number(v)))\n      edges.get(idx)!.forEach((n) => toVisit.push(n))\n    }\n    groups.push(group)\n  }\n\n  return groups\n}\n"],"names":[],"mappings":"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"}