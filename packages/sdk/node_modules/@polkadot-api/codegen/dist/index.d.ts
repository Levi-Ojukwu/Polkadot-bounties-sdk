import { MetadataLookup, getChecksumBuilder } from '@polkadot-api/metadata-builders';
import { V14Lookup, UnifiedMetadata, HexString } from '@polkadot-api/substrate-bindings';
import { TypedefNode, EntryPoint } from '@polkadot-api/metadata-compatibility';
import { InkMetadataLookup } from '@polkadot-api/ink-contracts';

interface CodegenOutput {
    code: string;
    imports: Record<string, Set<string>>;
}

type KnownTypes = Record<string, {
    name: string;
    priority: number;
}>;
type RepositoryEntry = string | {
    name: string;
    paths?: string[];
    type?: string;
    chains?: string;
    priority?: number;
};
declare const knownTypesRepository: Record<string, RepositoryEntry>;
declare const knownTypes: KnownTypes;

interface Variable {
    name: string;
    checksum: string;
    type: string;
}
interface CodeDeclarations {
    imports: Set<string>;
    variables: Map<string, Variable>;
    takenNames: Set<string>;
}
declare const defaultDeclarations: () => CodeDeclarations;
declare const getTypesBuilder: (declarations: CodeDeclarations, getLookupEntryDef: MetadataLookup, knownTypes: KnownTypes, checksumBuilder: ReturnType<typeof getChecksumBuilder>) => {
    buildTypeDefinition: (id: number) => string;
    buildDefinition: (id: number) => CodegenOutput;
    buildStorage: (pallet: string, entry: string) => {
        key: string;
        val: string;
        opaque: string;
    };
    buildEvent: (pallet: string, name: string) => string;
    buildError: (pallet: string, name: string) => string;
    buildCall: (pallet: string, name: string) => string;
    buildViewFn: (pallet: string, entry: string) => {
        args: string;
        value: string;
    };
    buildRuntimeCall: (api: string, method: string) => {
        args: string;
        value: string;
    };
    buildConstant: (pallet: string, constantName: string) => string;
    getTypeFileImports: () => string[];
    getClientFileImports: () => string[];
};
declare const getDocsTypesBuilder: (getLookupEntryDef: MetadataLookup, knownTypes: KnownTypes, checksumBuilder: ReturnType<typeof getChecksumBuilder>) => {
    buildStorage: (pallet: string, entry: string) => {
        opaque: string;
        args: string;
        payload: string;
    };
    buildRuntimeCall: (api: string, method: string) => {
        args: string;
        value: string;
    };
    buildEvent: (pallet: string, name: string) => string;
    buildError: (pallet: string, name: string) => string;
    buildCall: (pallet: string, name: string) => string;
    buildConstant: (pallet: string, constantName: string) => string;
    buildViewFn: (pallet: string, entry: string) => {
        args: string;
        value: string;
    };
    declarations: CodeDeclarations;
    recordTypeFileImports: () => string[];
    getClientFileImports: () => string[];
    getDescriptorsTypes: () => Variable[];
};

declare const getNewTypes: (lookup: MetadataLookup, knownTypes: KnownTypes, getTypeName: (data: V14Lookup[number]) => string | null) => {
    [k: string]: {
        name: string;
        checksum: string;
        type: string;
        path: string[];
    };
};

declare const customStringifyObject: (input: string | Record<string, any> | Array<any>) => string;
type DescriptorValues = Record<"storage" | "tx" | "events" | "constants" | "apis" | "viewFns", Record<string, Record<string, number>>>;
declare function capitalize(value: string): string;
declare const generateDescriptors: (lookupFn: MetadataLookup, checksumToIdx: Map<string, number>, typesBuilder: ReturnType<typeof getTypesBuilder>, checksumBuilder: ReturnType<typeof getChecksumBuilder>, key: string, paths: {
    client: string;
    metadataTypes: string;
    types: string;
    descriptorValues: string;
    common: string;
}, genesis?: string) => {
    descriptorTypes: string;
    descriptorValues: DescriptorValues;
    exports: string[];
    commonTypeImports: string[];
};
declare function getAssetId(lookup: MetadataLookup): number | undefined;
declare function getDispatchErrorId(lookup: MetadataLookup): number | undefined;

declare const generateMultipleDescriptors: (chains: Array<{
    key: string;
    metadata: UnifiedMetadata;
    knownTypes: KnownTypes;
    genesis?: HexString;
}>, paths: {
    client: string;
    metadataTypes: string;
    types: string;
    descriptorValues: string;
    common: string;
}, options?: {
    whitelist?: string[];
}) => {
    commonFileContent: string;
    descriptorsFileContent: string;
    metadataTypes: {
        typedefs: TypedefNode[];
        entryPoints: EntryPoint[];
        checksumToIdx: Map<string, number>;
    };
    descriptorTypesFiles: {
        content: string;
        exports: string[];
    }[];
    typesFileContent: string;
    publicTypes: string[];
};

type FileTree = {
    [key: string]: string | FileTree;
};
declare function generateDocsDescriptors(key: string, metadata: UnifiedMetadata): Promise<FileTree>;

declare function generateInkTypes(lookup: InkMetadataLookup): string;

type AbiPrimitive = `uint${number}` | `uint` | `int${number}` | `int` | "address" | "bool" | `fixed${number}x${number}` | `ufixed${number}x${number}` | "fixed" | "ufixed" | `bytes${number}` | "function" | "bytes" | "string";
type AbiType = AbiPrimitive | `${AbiPrimitive}[${number}]` | `${AbiPrimitive}[]` | `tuple`;
type TypedVariable = {
    name: string;
    type: AbiType;
    components: TypedVariable[];
};
type FunctionAbi = {
    type: "function" | "constructor" | "receive" | "fallback";
    name?: string;
    inputs?: Array<TypedVariable>;
    outputs?: Array<TypedVariable>;
    stateMutability: "pure" | "view" | "nonpayable" | "payable";
};
type EventAbi = {
    type: "event";
    name: string;
    inputs: Array<TypedVariable>;
    anonymous?: boolean;
};
type ErrorAbi = {
    type: "error";
    name: string;
    inputs: Array<TypedVariable>;
};
type Abi = Array<FunctionAbi | EventAbi | ErrorAbi>;
declare function generateSolTypes(abi: Abi): string;

export { capitalize, customStringifyObject, defaultDeclarations, generateDescriptors, generateDocsDescriptors, generateInkTypes, generateMultipleDescriptors, generateSolTypes, getAssetId, getDispatchErrorId, getDocsTypesBuilder, getNewTypes, getTypesBuilder, knownTypes, knownTypesRepository };
export type { CodeDeclarations, DescriptorValues, FileTree, KnownTypes, Variable };
