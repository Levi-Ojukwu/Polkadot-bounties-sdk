{"version":3,"file":"reused-nodes.mjs","sources":["../../../src/internal-types/reused-nodes.ts"],"sourcesContent":["import { isPrimitive, LookupTypeNode, TypeNode } from \"./type-representation\"\n\n/**\n * Given a list of starting points, returns those nodes that are being shared by\n * multiple paths.\n *\n * This can be used to avoid generating intermediate types which are being used\n * from just one single point.\n *\n * `exclude` is a set of ids to stop exploring. E.g. known types.\n * It might be a good idea to also have the excluded types as part of the entry\n * points.\n *\n * It might return types in the `start` or `exclude` set if those are being\n * referenced from more than one path.\n */\nexport function getReusedNodes(\n  start: (TypeNode | LookupTypeNode)[],\n  exclude: Set<number>,\n) {\n  const reused = new Set<number>()\n  const visited = new Set<number>()\n  let heads = [...start]\n\n  while (heads.length) {\n    const head = heads.pop()!\n    if (\"id\" in head) {\n      if (visited.has(head.id)) {\n        reused.add(head.id)\n        continue\n      }\n      visited.add(head.id)\n      if (exclude.has(head.id)) {\n        continue\n      }\n    }\n\n    heads = [...heads, ...getEdges(head)]\n  }\n\n  return reused\n}\n\nconst unique = <T>(arr: T[]) => [...new Set(arr)]\n\nfunction getEdges(node: TypeNode): LookupTypeNode[] {\n  const lookupEdge = (node: TypeNode | LookupTypeNode): LookupTypeNode[] =>\n    \"id\" in node ? [node] : getEdges(node)\n\n  if (isPrimitive(node)) return []\n\n  switch (node.type) {\n    case \"array\":\n      return lookupEdge(node.value.value)\n    case \"enum\":\n      // enum entries can be undefined => []\n      // enum entries can be lookupEntries => [lookupEntry]\n      // enum entries can be inline array/structs/etc => getEdges(_)\n      return unique(\n        node.value.flatMap((v) => (v.value ? lookupEdge(v.value) : [])),\n      )\n    case \"option\":\n      return lookupEdge(node.value)\n    case \"result\":\n      return [node.value.ok, node.value.ko]\n    case \"struct\":\n    case \"tuple\":\n      return unique(node.value.flatMap((v) => lookupEdge(v.value)))\n    case \"union\":\n      return unique(node.value.flatMap(lookupEdge))\n  }\n}\n"],"names":["node"],"mappings":";;AAgBO,SAAS,cAAA,CACd,OACA,OAAA,EACA;AACA,EAAA,MAAM,MAAA,uBAAa,GAAA,EAAY;AAC/B,EAAA,MAAM,OAAA,uBAAc,GAAA,EAAY;AAChC,EAAA,IAAI,KAAA,GAAQ,CAAC,GAAG,KAAK,CAAA;AAErB,EAAA,OAAO,MAAM,MAAA,EAAQ;AACnB,IAAA,MAAM,IAAA,GAAO,MAAM,GAAA,EAAI;AACvB,IAAA,IAAI,QAAQ,IAAA,EAAM;AAChB,MAAA,IAAI,OAAA,CAAQ,GAAA,CAAI,IAAA,CAAK,EAAE,CAAA,EAAG;AACxB,QAAA,MAAA,CAAO,GAAA,CAAI,KAAK,EAAE,CAAA;AAClB,QAAA;AAAA,MACF;AACA,MAAA,OAAA,CAAQ,GAAA,CAAI,KAAK,EAAE,CAAA;AACnB,MAAA,IAAI,OAAA,CAAQ,GAAA,CAAI,IAAA,CAAK,EAAE,CAAA,EAAG;AACxB,QAAA;AAAA,MACF;AAAA,IACF;AAEA,IAAA,KAAA,GAAQ,CAAC,GAAG,KAAA,EAAO,GAAG,QAAA,CAAS,IAAI,CAAC,CAAA;AAAA,EACtC;AAEA,EAAA,OAAO,MAAA;AACT;AAEA,MAAM,MAAA,GAAS,CAAI,GAAA,KAAa,CAAC,GAAG,IAAI,GAAA,CAAI,GAAG,CAAC,CAAA;AAEhD,SAAS,SAAS,IAAA,EAAkC;AAClD,EAAA,MAAM,UAAA,GAAa,CAACA,KAAAA,KAClB,IAAA,IAAQA,QAAO,CAACA,KAAI,CAAA,GAAI,QAAA,CAASA,KAAI,CAAA;AAEvC,EAAA,IAAI,WAAA,CAAY,IAAI,CAAA,EAAG,OAAO,EAAC;AAE/B,EAAA,QAAQ,KAAK,IAAA;AAAM,IACjB,KAAK,OAAA;AACH,MAAA,OAAO,UAAA,CAAW,IAAA,CAAK,KAAA,CAAM,KAAK,CAAA;AAAA,IACpC,KAAK,MAAA;AAIH,MAAA,OAAO,MAAA;AAAA,QACL,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ,CAAC,CAAA,KAAO,CAAA,CAAE,KAAA,GAAQ,UAAA,CAAW,CAAA,CAAE,KAAK,CAAA,GAAI,EAAG;AAAA,OAChE;AAAA,IACF,KAAK,QAAA;AACH,MAAA,OAAO,UAAA,CAAW,KAAK,KAAK,CAAA;AAAA,IAC9B,KAAK,QAAA;AACH,MAAA,OAAO,CAAC,IAAA,CAAK,KAAA,CAAM,EAAA,EAAI,IAAA,CAAK,MAAM,EAAE,CAAA;AAAA,IACtC,KAAK,QAAA;AAAA,IACL,KAAK,OAAA;AACH,MAAA,OAAO,MAAA,CAAO,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ,CAAC,MAAM,UAAA,CAAW,CAAA,CAAE,KAAK,CAAC,CAAC,CAAA;AAAA,IAC9D,KAAK,OAAA;AACH,MAAA,OAAO,MAAA,CAAO,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ,UAAU,CAAC,CAAA;AAAA;AAElD;;;;"}