{"version":3,"file":"generate-typescript.mjs","sources":["../../../src/internal-types/generate-typescript.ts"],"sourcesContent":["import {\n  EnumVariant,\n  LookupTypeNode,\n  StructField,\n  TypeNode,\n} from \"./type-representation\"\n\nexport interface CodegenOutput {\n  code: string\n  imports: Record<string, Set<string>>\n}\n\nexport type NodeCodeGenerator = (\n  innerNode: TypeNode | LookupTypeNode,\n  next: (node: TypeNode) => CodegenOutput,\n  level: number,\n) => CodegenOutput\n\n/**\n * This function is chain-type agnostic. It will try its best to generate all\n * types, but will fail for non-native types (e.g. Binary)\n * This can be enhanced through composition.\n */\nexport const nativeNodeCodegen = (\n  node: TypeNode,\n  next: (node: TypeNode) => CodegenOutput,\n): CodegenOutput => {\n  if (node.type === \"primitive\" || node.type === \"inline\")\n    return onlyCode(node.value)\n  if (node.type === \"chainPrimitive\")\n    throw new Error(\"Can't generate chain primitive type \" + node.value)\n  if (\n    node.type === \"result\" ||\n    node.type === \"enum\" ||\n    node.type === \"fixedSizeBinary\"\n  )\n    throw new Error(\"Can't generate chain primitive type \" + node.type)\n  if (node.type === \"array\") {\n    const { code, imports } = next(node.value.value)\n    return { code: `Array<${code}>`, imports }\n  }\n\n  if (node.type === \"struct\") {\n    return generateObjectCode(node.value, next)\n  }\n  if (node.type === \"tuple\") {\n    const tupleResults = node.value.map(({ value }) => next(value))\n    // docs seem to have no effect on tuples (VSCode)\n    return {\n      code: `[${tupleResults.map(({ code }) => code).join(\", \")}]`,\n      imports: mergeImports(tupleResults.map(({ imports }) => imports)),\n    }\n  }\n  if (node.type === \"union\") {\n    if (node.value.length === 1) return next(node.value[0])\n\n    const partResults = node.value.map(next)\n    return {\n      code: partResults.map(({ code }) => `(${code})`).join(\" | \"),\n      imports: mergeImports(partResults.map(({ imports }) => imports)),\n    }\n  }\n\n  // Must be an option\n  const optionResult = next(node.value)\n  return {\n    code: `(${optionResult.code}) | undefined`,\n    imports: optionResult.imports,\n  }\n}\n\nexport function generateTypescript(\n  node: TypeNode,\n  getNodeCode: NodeCodeGenerator,\n): CodegenOutput {\n  const next = (node: TypeNode, level: number): CodegenOutput =>\n    getNodeCode(node, (v) => next(v, level + 1), level)\n  return next(node, 0)\n}\n\nexport function processPapiPrimitives(\n  node: TypeNode,\n  getCode: (node: TypeNode) => CodegenOutput,\n  isKnown?: boolean,\n): CodegenOutput | null {\n  const clientImport = (value: string) => ({ client: new Set([value]) })\n\n  if (node.type === \"chainPrimitive\") {\n    return node.value === \"BitSequence\"\n      ? onlyCode(`Array<0 | 1>`)\n      : {\n          code: node.value,\n          imports: {\n            client: new Set([node.value]),\n          },\n        }\n  }\n\n  if (node.type === \"result\") {\n    const okResult = getCode(node.value.ok)\n    const koResult = getCode(node.value.ko)\n\n    return {\n      code: `ResultPayload<${okResult.code}, ${koResult.code}>`,\n      imports: mergeImports([\n        okResult.imports,\n        koResult.imports,\n        clientImport(\"ResultPayload\"),\n      ]),\n    }\n  }\n\n  if (node.type === \"enum\") {\n    const innerCode = generateObjectCode(node.value, getCode)\n\n    if (!isKnown) {\n      return {\n        code: `AnonymousEnum<${innerCode.code}>`,\n        imports: innerCode.imports,\n      }\n    }\n    return {\n      code: `Enum<${innerCode.code}>`,\n      imports: mergeImports([innerCode.imports, clientImport(\"Enum\")]),\n    }\n  }\n\n  if (node.type === \"fixedSizeBinary\") {\n    return {\n      code: `FixedSizeBinary<${node.value}>`,\n      imports: clientImport(\"FixedSizeBinary\"),\n    }\n  }\n\n  if (node.type === \"array\" && node.value.len) {\n    const { code, imports } = getCode(node.value.value)\n    return {\n      code: `FixedSizeArray<${node.value.len}, ${code}>`,\n      imports: mergeImports([imports, clientImport(\"FixedSizeArray\")]),\n    }\n  }\n\n  return null\n}\n\nexport const generateObjectCode = (\n  fields: (StructField | EnumVariant)[],\n  next: (node: TypeNode) => CodegenOutput,\n): CodegenOutput => {\n  const innerValues = fields.map((field) => ({\n    ...field,\n    result: field.value ? next(field.value) : null,\n  }))\n\n  return {\n    code: `{${innerValues\n      .map(({ label, docs, value, result }) => {\n        const docsPrefix = docs.length\n          ? `\\n/**\\n${docs.map((doc) => ` * ${doc.trim()}`).join(\"\\n\")}\\n */\\n`\n          : \"\"\n        if (result === null)\n          return docsPrefix + `${JSON.stringify(label)}: undefined`\n\n        const isOptional = value?.type === \"option\"\n        const key = JSON.stringify(label) + (isOptional ? \"?\" : \"\")\n        return docsPrefix + `${key}: ${result.code}`\n      })\n      .join(\", \")}}`,\n    imports: mergeImports(innerValues.map((v) => v.result?.imports ?? {})),\n  }\n}\n\nexport const mergeImports = (\n  imports: Array<CodegenOutput[\"imports\"]>,\n): CodegenOutput[\"imports\"] => {\n  if (!imports.length) return {}\n  const result = { ...imports[0] }\n  for (let i = 1; i < imports.length; i++) {\n    Object.entries(imports[i]).forEach(\n      ([type, value]) =>\n        (result[type] = new Set([...(result[type] ?? []), ...value])),\n    )\n  }\n  return result\n}\n\nexport const onlyCode = (code: string): CodegenOutput => ({ code, imports: {} })\n"],"names":["node"],"mappings":"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"}