{"version":3,"file":"internal-types-builder.mjs","sources":["../../../src/internal-types/internal-types-builder.ts"],"sourcesContent":["import {\n  ArrayVar,\n  EnumVar,\n  LookupEntry,\n  MetadataPrimitives,\n  StructVar,\n  TupleVar,\n} from \"@polkadot-api/metadata-builders\"\nimport {\n  ArrayType,\n  EnumVariant,\n  FixedSizeBinary,\n  LookupTypeNode,\n  NativeType,\n  StructType,\n  TupleType,\n  TypeNode,\n} from \"./type-representation\"\nimport { withCache } from \"./with-cache\"\n\nexport const primitiveTypes: Record<\n  MetadataPrimitives | \"compactNumber\" | \"compactBn\",\n  NativeType\n> = {\n  bool: \"boolean\",\n  char: \"string\",\n  str: \"string\",\n  u8: \"number\",\n  u16: \"number\",\n  u32: \"number\",\n  u64: \"bigint\",\n  u128: \"bigint\",\n  u256: \"bigint\",\n  i8: \"number\",\n  i16: \"number\",\n  i32: \"number\",\n  i64: \"bigint\",\n  i128: \"bigint\",\n  i256: \"bigint\",\n  compactNumber: \"number\",\n  compactBn: \"bigint\",\n}\n\nconst buildType = withCache(\n  (\n    input: LookupEntry,\n    cache: Map<number, LookupTypeNode>,\n    stack: Set<number>,\n  ): LookupTypeNode => {\n    const buildNextType = (nextInput: LookupEntry) =>\n      buildType(nextInput, cache, stack)\n\n    const ltn = <T extends TypeNode[\"type\"]>(\n      type: T,\n      value: (TypeNode & { type: T })[\"value\"],\n    ): LookupTypeNode =>\n      ({\n        id: input.id,\n        type,\n        value,\n      }) as LookupTypeNode\n\n    if (input.type === \"primitive\")\n      return ltn(\"primitive\", primitiveTypes[input.value])\n    if (input.type === \"void\") return ltn(\"primitive\", \"undefined\")\n    if (input.type === \"AccountId20\") return ltn(\"chainPrimitive\", \"HexString\")\n    if (input.type === \"AccountId32\") return ltn(\"chainPrimitive\", \"SS58String\")\n    if (input.type === \"compact\") {\n      const value: TypeNode[] = []\n      value.push({\n        type: \"primitive\",\n        value: input.isBig ? \"bigint\" : \"number\",\n      })\n\n      return ltn(\"union\", value)\n    }\n    if (input.type === \"bitSequence\")\n      return ltn(\"chainPrimitive\", \"BitSequence\")\n\n    if (\n      input.type === \"sequence\" &&\n      input.value.type === \"primitive\" &&\n      input.value.value === \"u8\"\n    )\n      return ltn(\"chainPrimitive\", \"Binary\")\n\n    const buildArray = (array: ArrayVar): ArrayType | FixedSizeBinary => {\n      const { value, len } = array\n      if (value.type === \"primitive\" && value.value === \"u8\") {\n        return { type: \"fixedSizeBinary\", value: len }\n      }\n      return {\n        type: \"array\",\n        value: { value: buildNextType(value), len },\n        original: array,\n      }\n    }\n    const buildTuple = (tuple: TupleVar): TupleType => {\n      const { value, innerDocs } = tuple\n\n      return {\n        type: \"tuple\",\n        value: value.map((v, i) => ({\n          value: buildNextType(v),\n          docs: innerDocs[i] ?? [],\n        })),\n        original: tuple,\n      }\n    }\n    const buildStruct = (struct: StructVar): StructType => {\n      const { value, innerDocs } = struct\n      return {\n        type: \"struct\",\n        value: Object.entries(value).map(([label, value]) => ({\n          label,\n          docs: innerDocs[label] ?? [],\n          value: buildNextType(value),\n        })),\n        original: struct,\n      }\n    }\n\n    if (input.type === \"array\") return { id: input.id, ...buildArray(input) }\n    if (input.type === \"sequence\")\n      return ltn(\"array\", { value: buildNextType(input.value) })\n    if (input.type === \"tuple\") return { id: input.id, ...buildTuple(input) }\n    if (input.type === \"struct\") return { id: input.id, ...buildStruct(input) }\n\n    if (input.type === \"option\")\n      return ltn(\"option\", buildNextType(input.value))\n\n    if (input.type === \"result\")\n      return ltn(\"result\", {\n        ok: buildNextType(input.value.ok),\n        ko: buildNextType(input.value.ko),\n      })\n\n    // it has to be an enum by now\n    const buildInnerType = (\n      value: EnumVar[\"value\"][string],\n    ):\n      | LookupTypeNode\n      | TupleType\n      | StructType\n      | ArrayType\n      | FixedSizeBinary\n      | undefined => {\n      switch (value.type) {\n        case \"lookupEntry\":\n          return buildNextType(value.value)\n        case \"void\":\n          return undefined\n        case \"array\":\n          return buildArray(value)\n        case \"struct\":\n          return buildStruct(value)\n        case \"tuple\":\n          return buildTuple(value)\n      }\n    }\n\n    const variants = Object.entries(input.value).map(\n      ([label, value]): EnumVariant => ({\n        docs: input.innerDocs[label] ?? [],\n        label: label,\n        value: buildInnerType(value),\n      }),\n    )\n    return ltn(\"enum\", variants)\n  },\n  (_, circular) => ({\n    id: circular.id,\n    optional: circular.type === \"option\",\n    type: \"primitive\" as const,\n    value: \"undefined\" as const,\n  }),\n  (result, tmp) => Object.assign(tmp, result),\n)\n\nexport const getInternalTypesBuilder = (\n  lookup: (id: number) => LookupEntry,\n) => {\n  const cache = new Map<number, LookupTypeNode>()\n\n  return (id: number): LookupTypeNode => buildType(lookup(id), cache, new Set())\n}\n"],"names":["value"],"mappings":"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"}