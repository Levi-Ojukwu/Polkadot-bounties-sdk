{"version":3,"file":"isStaticCompatible.mjs","sources":["../../src/isStaticCompatible.ts"],"sourcesContent":["import { DoubleSet } from \"./doubleSet\"\nimport type {\n  ArrayNode,\n  BinaryNode,\n  EnumNode,\n  OptionNode,\n  ResultNode,\n  StructNode,\n  TerminalNode,\n  TupleNode,\n  TypedefNode,\n} from \"./typedef\"\n\nexport enum CompatibilityLevel {\n  // No possible value from origin will be compatible with dest\n  Incompatible = 0,\n  // Some values of origin will be compatible with dest\n  Partial,\n  // Every value from origin will be compatible with dest\n  BackwardsCompatible,\n  // Types are identical\n  Identical,\n}\n\n/*\n * We have to be careful with circular references and early returns with the cache.\n *\n * For early returns, the resulting level could be even lower when exploring other branches.\n * This means that we can't store early returns in the cache. For simplicity, the\n * initial implementation will not have early returns.\n * It should be possible to store in the cache what was the CompatibilityLevel that\n * caused the early return, so that if the same call is done with the same CompatibilityLevel\n * we could still leverage the cache.\n *\n * For circular references, the simplest solution is to assume that the circular\n * node is fully-compatible (Identical). But then any node that is reading from it\n * can't be cached because its result will be doing the assumption that the circular\n * node is `Identical`.\n * Only once the whole cycle has completed, then the circular node can actually\n * cache its own result (TODO check this assumption is fine), and then any other\n * node that referenced it can also safely cache.\n * We have to think cases where there could be two cycles:\n *         F ← E\n *         ↓   ↑\n * A → B → C → D\n *     ↑       ↓\n *     I ← H ← G\n *\n * B = 4 => B = 1\n * B = 1 => B = 0\n *\n * As we're going depth-first, when we reach C from F, we will return a \"temporary\"\n * `Identical`. This means that F, E or D can't be cached. But then we continue\n * depth-first into G-H-I-B, then detect the cycle and return a \"temporary\" `Identical`.\n * Then I, H, G and C can't be cached because they actually depend on the temporary result of B.\n * B on the other hand will be able to cache its own result, and so does A.\n *\n * If a new call enters the cycle from D, then the branch G-H-I-B will be cached.\n * But the cycle D-E-F-C will make E-F-C not to cache their result yet.\n *\n *\n * => Maybe instead of having two separate [originNode, destNode] we can first merge\n * both trees into one, and then run the search? This would simplify the double-map/set stuff.\n * Can it be done lazily though? In a way that we don't need to go through the whole tree?\n */\n\nexport type Change = {\n  path: string\n  id: [number | null, number | null]\n  level: CompatibilityLevel\n}\nexport type StaticCompatibleResult = {\n  level: CompatibilityLevel\n  // paths causing the compatibility level. Doesn't return `Identical` paths.\n  changes: Array<Change>\n  // set of nodes that are assumed \"Identical\" (used with circular references)\n  assumptions: DoubleSet<TypedefNode>\n}\nexport type CompatibilityCache = Map<\n  TypedefNode,\n  Map<TypedefNode, { level: CompatibilityLevel; changes: Array<Change> } | null>\n>\nexport function isStaticCompatible(\n  originNode: TypedefNode | undefined,\n  getOriginNode: (id: number) => TypedefNode,\n  destNode: TypedefNode | undefined,\n  getDestNode: (id: number) => TypedefNode,\n  cache: CompatibilityCache,\n  deep = false,\n): StaticCompatibleResult {\n  if (!destNode && !originNode) {\n    return unconditional(CompatibilityLevel.Identical, [])\n  }\n  if (!destNode)\n    return unconditional(CompatibilityLevel.BackwardsCompatible, [])\n  if (!originNode)\n    return unconditional(\n      destNode.type === \"option\"\n        ? CompatibilityLevel.BackwardsCompatible\n        : CompatibilityLevel.Incompatible,\n      [],\n    )\n\n  if (!cache.has(destNode)) {\n    cache.set(destNode, new Map())\n  }\n  const destNodeCache = cache.get(destNode)!\n  if (destNodeCache.has(originNode)) {\n    const result = destNodeCache.get(originNode)\n    if (result == null) {\n      // Circular reference hit, return Identical with assumption\n      return {\n        level: CompatibilityLevel.Identical,\n        changes: [],\n        assumptions: new DoubleSet([[originNode, destNode]]),\n      }\n    }\n    return unconditional(result.level, result.changes)\n  }\n\n  // Initialize to null for detecting circular references\n  destNodeCache.set(originNode, null)\n\n  const result = getIsStaticCompatible(\n    originNode,\n    destNode,\n    (originNode, destNode) =>\n      isStaticCompatible(\n        typeof originNode === \"number\" ? getOriginNode(originNode) : originNode,\n        getOriginNode,\n        typeof destNode === \"number\" ? getDestNode(destNode) : destNode,\n        getDestNode,\n        cache,\n      ),\n    deep,\n  )\n\n  result.assumptions.delete(originNode, destNode)\n  if (\n    result.assumptions.isEmpty() ||\n    result.level === CompatibilityLevel.Incompatible\n  ) {\n    destNodeCache.set(originNode, result)\n  } else {\n    // Remove the temporary `null` value from the cache\n    destNodeCache.delete(originNode)\n  }\n  return result\n}\n\nfunction getIsStaticCompatible(\n  originNode: TypedefNode,\n  destNode: TypedefNode,\n  next: (\n    originNode: TypedefNode | number | undefined,\n    destNode: TypedefNode | number | undefined,\n  ) => StaticCompatibleResult,\n  deep: boolean,\n): StaticCompatibleResult {\n  const nextCall = (\n    originNode: TypedefNode | number | undefined,\n    destNode: TypedefNode | number | undefined,\n    path: string,\n  ): StaticCompatibleResult => {\n    const result = next(originNode, destNode)\n    return {\n      ...result,\n      changes:\n        result.level < CompatibilityLevel.Identical\n          ? [\n              {\n                id: [\n                  typeof originNode === \"number\" ? originNode : null,\n                  typeof destNode === \"number\" ? destNode : null,\n                ],\n                level: result.level,\n                path,\n              },\n            ]\n          : [],\n    }\n  }\n\n  if (originNode.type !== destNode.type) {\n    if (destNode.type === \"option\") {\n      return withMaxLevel(\n        nextCall(originNode, destNode.value, \"some\"),\n        CompatibilityLevel.BackwardsCompatible,\n      )\n    }\n    if (originNode.type === \"option\") {\n      return withMaxLevel(\n        nextCall(originNode.value, destNode, \"some\"),\n        CompatibilityLevel.Partial,\n      )\n    }\n    return unconditional(CompatibilityLevel.Incompatible, [])\n  }\n\n  switch (destNode.type) {\n    case \"terminal\":\n      return unconditional(\n        destNode.value.type === (originNode as TerminalNode).value.type\n          ? CompatibilityLevel.Identical\n          : CompatibilityLevel.Incompatible,\n        [],\n      )\n    case \"binary\":\n      const binaryOrigin = originNode as BinaryNode\n      return lengthChange(\n        compareOptionalLengths(binaryOrigin.value, destNode.value),\n      )\n    case \"array\":\n      const arrayOrigin = originNode as ArrayNode\n      const lengthCheck = lengthChange(\n        compareOptionalLengths(arrayOrigin.value.length, destNode.value.length),\n      )\n      return strictMerge(\n        [\n          lengthCheck,\n          () =>\n            nextCall(\n              arrayOrigin.value.typeRef,\n              destNode.value.typeRef,\n              \"value\",\n            ),\n        ],\n        deep,\n      )\n    case \"enum\": {\n      const enumOrigin = originNode as EnumNode\n      const destVariants = Object.fromEntries(\n        destNode.value.map(([key, value]) => [key, value.value]),\n      )\n\n      // check whether every possible `origin` value is compatible with dest\n      let enumResults = mergeResults(\n        enumOrigin.value.map(\n          ([type, value]) =>\n            () =>\n              type in destVariants\n                ? nextCall(value.value, destVariants[type], type)\n                : unconditional(CompatibilityLevel.Incompatible, [\n                    {\n                      id: [\n                        typeof value.value === \"number\" ? value.value : null,\n                        null,\n                      ],\n                      level: CompatibilityLevel.Incompatible,\n                      path: type,\n                    },\n                  ]),\n        ),\n      )\n      if (enumOrigin.value.length === destNode.value.length) return enumResults\n      enumResults = withMaxLevel(\n        enumResults,\n        CompatibilityLevel.BackwardsCompatible,\n      )\n\n      // Then add in the missing values as incompatible changes\n      const enumOriginVariants = new Set(enumOrigin.value.map(([key]) => key))\n      enumResults.changes = [\n        ...enumResults.changes,\n        ...destNode.value\n          .filter(([key]) => !enumOriginVariants.has(key))\n          .map(\n            ([key, value]): Change => ({\n              id: [null, typeof value === \"number\" ? value : null],\n              level: CompatibilityLevel.Incompatible,\n              path: key,\n            }),\n          ),\n      ]\n      return enumResults\n    }\n    case \"option\":\n      return withMinLevel(\n        nextCall((originNode as OptionNode).value, destNode.value, \"some\"),\n        CompatibilityLevel.Partial,\n      )\n    case \"struct\":\n      const structOrigin = originNode as StructNode\n      const originProperties = Object.fromEntries(structOrigin.value)\n      const maxLevel =\n        structOrigin.value.length === destNode.value.length\n          ? CompatibilityLevel.Identical\n          : CompatibilityLevel.BackwardsCompatible\n\n      return withMaxLevel(\n        strictMerge(\n          destNode.value.map(\n            ([key, value]) =>\n              () =>\n                nextCall(originProperties[key], value, key),\n          ),\n          deep,\n        ),\n        maxLevel,\n      )\n    case \"tuple\": {\n      const tupleOrigin = originNode as TupleNode\n      const lengthCheck = lengthChange(\n        compareArrayLengths(tupleOrigin.value, destNode.value),\n      )\n      return strictMerge(\n        [\n          lengthCheck,\n          ...destNode.value.map(\n            (value, idx) => () =>\n              nextCall(tupleOrigin.value[idx], value, String(idx)),\n          ),\n        ],\n        deep,\n      )\n    }\n    case \"result\":\n      const resultOrigin = originNode as ResultNode\n      return mergeResults([\n        nextCall(resultOrigin.value.ok, destNode.value.ok, \"ok\"),\n        nextCall(resultOrigin.value.ko, destNode.value.ko, \"ko\"),\n      ])\n  }\n}\n\nconst withMaxLevel = (\n  result: StaticCompatibleResult,\n  level: CompatibilityLevel,\n): StaticCompatibleResult => ({\n  // Changes stay the same. Use case: Option<Incompatible>, the option should show up as Partial, but the change should indicate that the inner one is incompatible.\n  ...result,\n  // Confusing yes, but it's Math.min. If we do withMaxLevel(result, 1), we expect to get at most [1] as a result\n  level: Math.min(result.level, level),\n})\nconst withMinLevel = (\n  result: StaticCompatibleResult,\n  level: CompatibilityLevel,\n): StaticCompatibleResult => ({\n  ...result,\n  level: Math.max(result.level, level),\n})\n\nconst noAssumptions = new DoubleSet<TypedefNode>()\nconst unconditional = (\n  level: CompatibilityLevel,\n  changes: Array<Change>,\n): StaticCompatibleResult => ({\n  level,\n  changes,\n  assumptions: noAssumptions,\n})\n\n/**\n * Merges multiple results, following the most \"strict\" one, (semantically an\n * AND)\n */\nconst strictMerge = (\n  results: Array<StaticCompatibleResult | (() => StaticCompatibleResult)>,\n  deep: boolean,\n): StaticCompatibleResult => {\n  let merged = unconditional(CompatibilityLevel.Identical, [])\n\n  for (const resultFn of results) {\n    const result = typeof resultFn === \"function\" ? resultFn() : resultFn\n    // On early return we don't need to keep the other assumptions\n    if (!deep && result.level === CompatibilityLevel.Incompatible) return result\n\n    if (result.level !== CompatibilityLevel.Identical)\n      merged.changes = [...merged.changes, ...result.changes]\n    merged.assumptions.addAll(result.assumptions.values)\n    merged.level = Math.min(merged.level, result.level)\n  }\n\n  return merged\n}\n\n/**\n * Merges multiple results, going to `partially` (semantically an OR)\n */\nconst mergeResults = (\n  results: Array<StaticCompatibleResult | (() => StaticCompatibleResult)>,\n): StaticCompatibleResult => {\n  if (!results.length) return unconditional(CompatibilityLevel.Identical, [])\n\n  let hasCompatibles = false\n\n  let merged = unconditional(CompatibilityLevel.Identical, [])\n  for (const resultFn of results) {\n    const result = typeof resultFn === \"function\" ? resultFn() : resultFn\n    if (result.level !== CompatibilityLevel.Identical)\n      merged.changes = [...merged.changes, ...result.changes]\n    if (result.level === CompatibilityLevel.Incompatible) {\n      merged.level = Math.min(merged.level, CompatibilityLevel.Partial)\n      continue\n    }\n    hasCompatibles = true\n\n    merged.assumptions.addAll(result.assumptions.values)\n    merged.level = Math.min(merged.level, result.level)\n  }\n\n  return hasCompatibles\n    ? merged\n    : unconditional(CompatibilityLevel.Incompatible, merged.changes)\n}\n\nconst lengthChange = (level: CompatibilityLevel): StaticCompatibleResult => ({\n  assumptions: noAssumptions,\n  changes:\n    level === CompatibilityLevel.Identical\n      ? []\n      : [\n          {\n            id: [null, null],\n            level,\n            path: \"length\",\n          },\n        ],\n  level,\n})\n\nconst compareArrayLengths = (\n  origin: unknown[],\n  dest: unknown[],\n): CompatibilityLevel =>\n  dest.length === origin.length\n    ? CompatibilityLevel.Identical\n    : origin.length >= dest.length\n      ? CompatibilityLevel.BackwardsCompatible\n      : CompatibilityLevel.Incompatible\n\nconst compareOptionalLengths = (\n  origin: number | undefined,\n  dest: number | undefined,\n): CompatibilityLevel =>\n  dest === origin\n    ? CompatibilityLevel.Identical\n    : dest == null || origin! >= dest\n      ? CompatibilityLevel.BackwardsCompatible\n      : origin == null\n        ? CompatibilityLevel.Partial\n        : CompatibilityLevel.Incompatible\n"],"names":["CompatibilityLevel","result","originNode","destNode","lengthCheck"],"mappings":"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"}