{"version":3,"file":"isCompatible.mjs","sources":["../../src/isCompatible.ts"],"sourcesContent":["import { Binary } from \"@polkadot-api/substrate-bindings\"\nimport { Primitive, type TerminalNode, type TypedefNode } from \"./typedef\"\n\n// Descriptors: pallet + name => index (this._descriptors[opType][pallet][name])\n// index will be for both checksums and compatLookup\n\n// Dest type: describes types of the receiving end.\nexport function isCompatible(\n  value: any,\n  destNode: TypedefNode,\n  getNode: (id: number) => TypedefNode,\n): boolean {\n  if (destNode.type === \"option\" && value == null) {\n    return true\n  }\n\n  const nextCall = (value: any, destNode: TypedefNode) =>\n    isCompatible(value, destNode, getNode)\n\n  const checkTerminal = (terminal: TerminalNode) => {\n    switch (terminal.value.type) {\n      case Primitive.str:\n      case Primitive.big:\n      case Primitive.bool:\n      case Primitive.num:\n        return typeof value === terminal.value.type\n      case Primitive.bits:\n        return (\n          typeof value === \"object\" &&\n          value != null &&\n          typeof value.bitsLen === \"number\" &&\n          value.bytes instanceof Uint8Array\n        )\n      case Primitive.void:\n        // A void node is always compatible, since the codec ignores the input.\n        return true\n    }\n  }\n\n  switch (destNode.type) {\n    case \"terminal\":\n      return checkTerminal(destNode)\n    case \"binary\":\n      return (\n        value instanceof Binary &&\n        (destNode.value == null || value.asBytes().length >= destNode.value)\n      )\n    case \"array\":\n      if (!Array.isArray(value)) return false\n      const valueArr = value as Array<any>\n      if (\n        destNode.value.length != null &&\n        valueArr.length < destNode.value.length\n      ) {\n        return false\n      }\n      return valueArr\n        .slice(0, destNode.value.length)\n        .every((value) => nextCall(value, getNode(destNode.value.typeRef)))\n    case \"enum\":\n      if (!value) return false\n      const valueEnum = value as { type: string; value: any }\n      const destVariants = Object.fromEntries(destNode.value)\n      if (!(valueEnum.type in destVariants)) {\n        return false\n      }\n      const variantValue = destVariants[valueEnum.type]\n      if (variantValue == null) {\n        return true\n      }\n      return nextCall(\n        valueEnum.value,\n        variantValue.type === \"inline\"\n          ? variantValue.value\n          : getNode(variantValue.value),\n      )\n    case \"option\":\n      if (value == null) {\n        return true\n      }\n      return nextCall(value, getNode(destNode.value))\n    case \"struct\":\n      if (!value) return false\n      return destNode.value.every(([key, typeRef]) =>\n        nextCall(value[key], getNode(typeRef)),\n      )\n    case \"tuple\":\n      if (!value) return false\n      // length will be checked indirectly\n      return destNode.value.every((typeRef, idx) =>\n        nextCall(value[idx], getNode(typeRef)),\n      )\n    case \"result\":\n      if (!(\"success\" in value && \"value\" in value)) return false\n      return nextCall(\n        value.value,\n        getNode(value.success ? destNode.value.ok : destNode.value.ko),\n      )\n  }\n}\n"],"names":["value","destNode"],"mappings":"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"}