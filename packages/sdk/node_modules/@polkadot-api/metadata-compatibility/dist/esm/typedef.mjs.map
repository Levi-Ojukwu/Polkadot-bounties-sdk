{"version":3,"file":"typedef.mjs","sources":["../../src/typedef.ts"],"sourcesContent":["import type { MetadataPrimitives, Var } from \"@polkadot-api/metadata-builders\"\nimport {\n  Codec,\n  Enum,\n  Option,\n  Self,\n  StringRecord,\n  Struct,\n  Tuple,\n  Variant,\n  Vector,\n  _void,\n  compactNumber,\n  str,\n} from \"@polkadot-api/substrate-bindings\"\n\nconst smallCompact = compactNumber\nexport interface StructNode {\n  type: \"struct\"\n  value: Array<[string, number]>\n}\nconst StructCodec = Vector(Tuple(str, smallCompact))\n\nexport const Primitive = {\n  bool: \"boolean\" as const,\n  str: \"string\" as const,\n  num: \"number\" as const,\n  big: \"bigint\" as const,\n  bits: \"bitseq\" as const,\n  void: \"void\" as const,\n}\nexport type PRIMITIVES = (typeof Primitive)[keyof typeof Primitive]\n\nexport interface TerminalNode {\n  type: \"terminal\"\n  value: {\n    type: PRIMITIVES\n  }\n}\nconst TerminalCodec = Variant(\n  Object.fromEntries(\n    Object.values(Primitive).map((p) => [p, _void]),\n  ) as StringRecord<Codec<undefined>>,\n) as any as Codec<TerminalNode[\"value\"]>\n\nexport interface EnumNode {\n  type: \"enum\"\n  value: Array<[string, Enum<{ inline: TypedefNode; lookup: number }>]>\n}\nconst EnumCodec: Codec<EnumNode[\"value\"]> = Vector(\n  Tuple(\n    str,\n    Variant({\n      inline: Self(() => TypedefCodec),\n      lookup: smallCompact,\n    }),\n  ),\n)\n\nexport interface TupleNode {\n  type: \"tuple\"\n  value: number[]\n}\nconst TupleCodec = Vector(smallCompact)\n\nexport interface ArrayNode {\n  type: \"array\"\n  value: {\n    typeRef: number\n    length?: number\n  }\n}\nconst ArrayCodec = Struct({\n  typeRef: smallCompact,\n  length: Option(smallCompact),\n}) as Codec<ArrayNode[\"value\"]>\n\nexport interface BinaryNode {\n  type: \"binary\"\n  value: number | undefined\n}\nconst BinaryCodec = Option(smallCompact) as Codec<BinaryNode[\"value\"]>\n\nexport interface OptionNode {\n  type: \"option\"\n  value: number\n}\nconst OptionCodec = smallCompact\n\nexport interface ResultNode {\n  type: \"result\"\n  value: {\n    ok: number\n    ko: number\n  }\n}\nconst ResultCodec = Struct({\n  ok: smallCompact,\n  ko: smallCompact,\n})\n\nexport type TypedefNode =\n  | StructNode\n  | TerminalNode\n  | EnumNode\n  | TupleNode\n  | ArrayNode\n  | BinaryNode\n  | OptionNode\n  | ResultNode\nexport const TypedefCodec: Codec<TypedefNode> = Variant({\n  struct: StructCodec,\n  terminal: TerminalCodec,\n  enum: EnumCodec,\n  tuple: TupleCodec,\n  array: ArrayCodec,\n  binary: BinaryCodec,\n  option: OptionCodec,\n  result: ResultCodec,\n})\n\nconst primitiveToTerminal: Record<MetadataPrimitives, PRIMITIVES> = {\n  i256: Primitive.big,\n  i128: Primitive.big,\n  i64: Primitive.big,\n  i32: Primitive.num,\n  i16: Primitive.num,\n  i8: Primitive.num,\n  u256: Primitive.big,\n  u128: Primitive.big,\n  u64: Primitive.big,\n  u32: Primitive.num,\n  u16: Primitive.num,\n  u8: Primitive.num,\n  bool: Primitive.bool,\n  char: Primitive.str,\n  str: Primitive.str,\n}\n\nconst terminal = (type: PRIMITIVES): TerminalNode => ({\n  type: \"terminal\",\n  value: { type },\n})\nexport function mapLookupToTypedef(\n  entry: Var,\n  resolve: (id: number) => void = () => {},\n): TypedefNode {\n  switch (entry.type) {\n    case \"AccountId20\":\n    case \"AccountId32\":\n      return terminal(Primitive.str)\n    case \"array\":\n      if (entry.value.type === \"primitive\" && entry.value.value === \"u8\") {\n        return { type: \"binary\", value: entry.len }\n      }\n      resolve(entry.value.id)\n      return {\n        type: \"array\",\n        value: {\n          typeRef: entry.value.id,\n          length: entry.len,\n        },\n      }\n    case \"bitSequence\":\n      return terminal(Primitive.bits)\n    case \"compact\":\n      return terminal(entry.isBig ? Primitive.big : Primitive.num)\n    case \"enum\":\n      return {\n        type: \"enum\",\n        value: Object.entries(entry.value).map(\n          ([key, params]): EnumNode[\"value\"][number] => {\n            if (params.type !== \"lookupEntry\")\n              return [\n                key,\n                { type: \"inline\", value: mapLookupToTypedef(params, resolve) },\n              ]\n\n            resolve(params.value.id)\n            return [\n              key,\n              {\n                type: \"lookup\",\n                value: params.value.id,\n              },\n            ]\n          },\n        ),\n      }\n    case \"struct\": {\n      const value = Object.entries(entry.value).map(\n        ([key, prop]) => [key, prop.id] satisfies [string, number],\n      )\n      value.forEach(([, v]) => resolve(v))\n      return {\n        type: \"struct\",\n        value,\n      }\n    }\n    case \"tuple\": {\n      const value = entry.value.map((v) => v.id)\n      value.forEach(resolve)\n      return {\n        type: \"tuple\",\n        value,\n      }\n    }\n    case \"option\":\n      resolve(entry.value.id)\n      return {\n        type: \"option\",\n        value: entry.value.id,\n      }\n    case \"primitive\":\n      return terminal(primitiveToTerminal[entry.value])\n    case \"result\":\n      resolve(entry.value.ok.id)\n      resolve(entry.value.ko.id)\n      return {\n        type: \"result\",\n        value: {\n          ok: entry.value.ok.id,\n          ko: entry.value.ko.id,\n        },\n      }\n    case \"sequence\":\n      if (entry.value.type === \"primitive\" && entry.value.value === \"u8\") {\n        return { type: \"binary\", value: undefined }\n      }\n      resolve(entry.value.id)\n      return {\n        type: \"array\",\n        value: { typeRef: entry.value.id },\n      }\n    case \"void\":\n      return terminal(Primitive.void)\n  }\n}\n\nexport function mapReferences(\n  node: TypedefNode,\n  mapFn: (id: number) => number,\n): TypedefNode {\n  switch (node.type) {\n    case \"array\":\n      return {\n        ...node,\n        value: {\n          ...node.value,\n          typeRef: mapFn(node.value.typeRef),\n        },\n      }\n    case \"option\":\n      return { ...node, value: mapFn(node.value) }\n    case \"result\":\n      return {\n        ...node,\n        value: { ok: mapFn(node.value.ok), ko: mapFn(node.value.ko) },\n      }\n    case \"tuple\":\n      return { ...node, value: node.value.map(mapFn) }\n    case \"struct\":\n      return {\n        ...node,\n        value: node.value.map(([k, v]) => [k, mapFn(v)] as [string, number]),\n      }\n    case \"enum\": {\n      return {\n        ...node,\n        value: node.value.map(([k, { type, value }]): EnumNode[\"value\"][0] => [\n          k,\n          type === \"lookup\"\n            ? { type, value: mapFn(value) }\n            : { type, value: mapReferences(value, mapFn) },\n        ]),\n      }\n    }\n\n    case \"binary\":\n    case \"terminal\":\n      return node\n  }\n}\n"],"names":[],"mappings":"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"}