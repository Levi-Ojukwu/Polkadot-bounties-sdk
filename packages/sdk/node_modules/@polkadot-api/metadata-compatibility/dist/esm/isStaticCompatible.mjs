import { DoubleSet } from './doubleSet.mjs';

var CompatibilityLevel = /* @__PURE__ */ ((CompatibilityLevel2) => {
  CompatibilityLevel2[CompatibilityLevel2["Incompatible"] = 0] = "Incompatible";
  CompatibilityLevel2[CompatibilityLevel2["Partial"] = 1] = "Partial";
  CompatibilityLevel2[CompatibilityLevel2["BackwardsCompatible"] = 2] = "BackwardsCompatible";
  CompatibilityLevel2[CompatibilityLevel2["Identical"] = 3] = "Identical";
  return CompatibilityLevel2;
})(CompatibilityLevel || {});
function isStaticCompatible(originNode, getOriginNode, destNode, getDestNode, cache, deep = false) {
  if (!destNode && !originNode) {
    return unconditional(3 /* Identical */, []);
  }
  if (!destNode)
    return unconditional(2 /* BackwardsCompatible */, []);
  if (!originNode)
    return unconditional(
      destNode.type === "option" ? 2 /* BackwardsCompatible */ : 0 /* Incompatible */,
      []
    );
  if (!cache.has(destNode)) {
    cache.set(destNode, /* @__PURE__ */ new Map());
  }
  const destNodeCache = cache.get(destNode);
  if (destNodeCache.has(originNode)) {
    const result2 = destNodeCache.get(originNode);
    if (result2 == null) {
      return {
        level: 3 /* Identical */,
        changes: [],
        assumptions: new DoubleSet([[originNode, destNode]])
      };
    }
    return unconditional(result2.level, result2.changes);
  }
  destNodeCache.set(originNode, null);
  const result = getIsStaticCompatible(
    originNode,
    destNode,
    (originNode2, destNode2) => isStaticCompatible(
      typeof originNode2 === "number" ? getOriginNode(originNode2) : originNode2,
      getOriginNode,
      typeof destNode2 === "number" ? getDestNode(destNode2) : destNode2,
      getDestNode,
      cache
    ),
    deep
  );
  result.assumptions.delete(originNode, destNode);
  if (result.assumptions.isEmpty() || result.level === 0 /* Incompatible */) {
    destNodeCache.set(originNode, result);
  } else {
    destNodeCache.delete(originNode);
  }
  return result;
}
function getIsStaticCompatible(originNode, destNode, next, deep) {
  const nextCall = (originNode2, destNode2, path) => {
    const result = next(originNode2, destNode2);
    return {
      ...result,
      changes: result.level < 3 /* Identical */ ? [
        {
          id: [
            typeof originNode2 === "number" ? originNode2 : null,
            typeof destNode2 === "number" ? destNode2 : null
          ],
          level: result.level,
          path
        }
      ] : []
    };
  };
  if (originNode.type !== destNode.type) {
    if (destNode.type === "option") {
      return withMaxLevel(
        nextCall(originNode, destNode.value, "some"),
        2 /* BackwardsCompatible */
      );
    }
    if (originNode.type === "option") {
      return withMaxLevel(
        nextCall(originNode.value, destNode, "some"),
        1 /* Partial */
      );
    }
    return unconditional(0 /* Incompatible */, []);
  }
  switch (destNode.type) {
    case "terminal":
      return unconditional(
        destNode.value.type === originNode.value.type ? 3 /* Identical */ : 0 /* Incompatible */,
        []
      );
    case "binary":
      const binaryOrigin = originNode;
      return lengthChange(
        compareOptionalLengths(binaryOrigin.value, destNode.value)
      );
    case "array":
      const arrayOrigin = originNode;
      const lengthCheck = lengthChange(
        compareOptionalLengths(arrayOrigin.value.length, destNode.value.length)
      );
      return strictMerge(
        [
          lengthCheck,
          () => nextCall(
            arrayOrigin.value.typeRef,
            destNode.value.typeRef,
            "value"
          )
        ],
        deep
      );
    case "enum": {
      const enumOrigin = originNode;
      const destVariants = Object.fromEntries(
        destNode.value.map(([key, value]) => [key, value.value])
      );
      let enumResults = mergeResults(
        enumOrigin.value.map(
          ([type, value]) => () => type in destVariants ? nextCall(value.value, destVariants[type], type) : unconditional(0 /* Incompatible */, [
            {
              id: [
                typeof value.value === "number" ? value.value : null,
                null
              ],
              level: 0 /* Incompatible */,
              path: type
            }
          ])
        )
      );
      if (enumOrigin.value.length === destNode.value.length) return enumResults;
      enumResults = withMaxLevel(
        enumResults,
        2 /* BackwardsCompatible */
      );
      const enumOriginVariants = new Set(enumOrigin.value.map(([key]) => key));
      enumResults.changes = [
        ...enumResults.changes,
        ...destNode.value.filter(([key]) => !enumOriginVariants.has(key)).map(
          ([key, value]) => ({
            id: [null, typeof value === "number" ? value : null],
            level: 0 /* Incompatible */,
            path: key
          })
        )
      ];
      return enumResults;
    }
    case "option":
      return withMinLevel(
        nextCall(originNode.value, destNode.value, "some"),
        1 /* Partial */
      );
    case "struct":
      const structOrigin = originNode;
      const originProperties = Object.fromEntries(structOrigin.value);
      const maxLevel = structOrigin.value.length === destNode.value.length ? 3 /* Identical */ : 2 /* BackwardsCompatible */;
      return withMaxLevel(
        strictMerge(
          destNode.value.map(
            ([key, value]) => () => nextCall(originProperties[key], value, key)
          ),
          deep
        ),
        maxLevel
      );
    case "tuple": {
      const tupleOrigin = originNode;
      const lengthCheck2 = lengthChange(
        compareArrayLengths(tupleOrigin.value, destNode.value)
      );
      return strictMerge(
        [
          lengthCheck2,
          ...destNode.value.map(
            (value, idx) => () => nextCall(tupleOrigin.value[idx], value, String(idx))
          )
        ],
        deep
      );
    }
    case "result":
      const resultOrigin = originNode;
      return mergeResults([
        nextCall(resultOrigin.value.ok, destNode.value.ok, "ok"),
        nextCall(resultOrigin.value.ko, destNode.value.ko, "ko")
      ]);
  }
}
const withMaxLevel = (result, level) => ({
  // Changes stay the same. Use case: Option<Incompatible>, the option should show up as Partial, but the change should indicate that the inner one is incompatible.
  ...result,
  // Confusing yes, but it's Math.min. If we do withMaxLevel(result, 1), we expect to get at most [1] as a result
  level: Math.min(result.level, level)
});
const withMinLevel = (result, level) => ({
  ...result,
  level: Math.max(result.level, level)
});
const noAssumptions = new DoubleSet();
const unconditional = (level, changes) => ({
  level,
  changes,
  assumptions: noAssumptions
});
const strictMerge = (results, deep) => {
  let merged = unconditional(3 /* Identical */, []);
  for (const resultFn of results) {
    const result = typeof resultFn === "function" ? resultFn() : resultFn;
    if (!deep && result.level === 0 /* Incompatible */) return result;
    if (result.level !== 3 /* Identical */)
      merged.changes = [...merged.changes, ...result.changes];
    merged.assumptions.addAll(result.assumptions.values);
    merged.level = Math.min(merged.level, result.level);
  }
  return merged;
};
const mergeResults = (results) => {
  if (!results.length) return unconditional(3 /* Identical */, []);
  let hasCompatibles = false;
  let merged = unconditional(3 /* Identical */, []);
  for (const resultFn of results) {
    const result = typeof resultFn === "function" ? resultFn() : resultFn;
    if (result.level !== 3 /* Identical */)
      merged.changes = [...merged.changes, ...result.changes];
    if (result.level === 0 /* Incompatible */) {
      merged.level = Math.min(merged.level, 1 /* Partial */);
      continue;
    }
    hasCompatibles = true;
    merged.assumptions.addAll(result.assumptions.values);
    merged.level = Math.min(merged.level, result.level);
  }
  return hasCompatibles ? merged : unconditional(0 /* Incompatible */, merged.changes);
};
const lengthChange = (level) => ({
  assumptions: noAssumptions,
  changes: level === 3 /* Identical */ ? [] : [
    {
      id: [null, null],
      level,
      path: "length"
    }
  ],
  level
});
const compareArrayLengths = (origin, dest) => dest.length === origin.length ? 3 /* Identical */ : origin.length >= dest.length ? 2 /* BackwardsCompatible */ : 0 /* Incompatible */;
const compareOptionalLengths = (origin, dest) => dest === origin ? 3 /* Identical */ : dest == null || origin >= dest ? 2 /* BackwardsCompatible */ : origin == null ? 1 /* Partial */ : 0 /* Incompatible */;

export { CompatibilityLevel, isStaticCompatible };
//# sourceMappingURL=isStaticCompatible.mjs.map
