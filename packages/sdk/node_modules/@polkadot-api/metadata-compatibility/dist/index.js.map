{"version":3,"file":"index.js","sources":["../src/typedef.ts","../src/isCompatible.ts","../src/doubleSet.ts","../src/isStaticCompatible.ts","../src/entryPoint.ts"],"sourcesContent":["import type { MetadataPrimitives, Var } from \"@polkadot-api/metadata-builders\"\nimport {\n  Codec,\n  Enum,\n  Option,\n  Self,\n  StringRecord,\n  Struct,\n  Tuple,\n  Variant,\n  Vector,\n  _void,\n  compactNumber,\n  str,\n} from \"@polkadot-api/substrate-bindings\"\n\nconst smallCompact = compactNumber\nexport interface StructNode {\n  type: \"struct\"\n  value: Array<[string, number]>\n}\nconst StructCodec = Vector(Tuple(str, smallCompact))\n\nexport const Primitive = {\n  bool: \"boolean\" as const,\n  str: \"string\" as const,\n  num: \"number\" as const,\n  big: \"bigint\" as const,\n  bits: \"bitseq\" as const,\n  void: \"void\" as const,\n}\nexport type PRIMITIVES = (typeof Primitive)[keyof typeof Primitive]\n\nexport interface TerminalNode {\n  type: \"terminal\"\n  value: {\n    type: PRIMITIVES\n  }\n}\nconst TerminalCodec = Variant(\n  Object.fromEntries(\n    Object.values(Primitive).map((p) => [p, _void]),\n  ) as StringRecord<Codec<undefined>>,\n) as any as Codec<TerminalNode[\"value\"]>\n\nexport interface EnumNode {\n  type: \"enum\"\n  value: Array<[string, Enum<{ inline: TypedefNode; lookup: number }>]>\n}\nconst EnumCodec: Codec<EnumNode[\"value\"]> = Vector(\n  Tuple(\n    str,\n    Variant({\n      inline: Self(() => TypedefCodec),\n      lookup: smallCompact,\n    }),\n  ),\n)\n\nexport interface TupleNode {\n  type: \"tuple\"\n  value: number[]\n}\nconst TupleCodec = Vector(smallCompact)\n\nexport interface ArrayNode {\n  type: \"array\"\n  value: {\n    typeRef: number\n    length?: number\n  }\n}\nconst ArrayCodec = Struct({\n  typeRef: smallCompact,\n  length: Option(smallCompact),\n}) as Codec<ArrayNode[\"value\"]>\n\nexport interface BinaryNode {\n  type: \"binary\"\n  value: number | undefined\n}\nconst BinaryCodec = Option(smallCompact) as Codec<BinaryNode[\"value\"]>\n\nexport interface OptionNode {\n  type: \"option\"\n  value: number\n}\nconst OptionCodec = smallCompact\n\nexport interface ResultNode {\n  type: \"result\"\n  value: {\n    ok: number\n    ko: number\n  }\n}\nconst ResultCodec = Struct({\n  ok: smallCompact,\n  ko: smallCompact,\n})\n\nexport type TypedefNode =\n  | StructNode\n  | TerminalNode\n  | EnumNode\n  | TupleNode\n  | ArrayNode\n  | BinaryNode\n  | OptionNode\n  | ResultNode\nexport const TypedefCodec: Codec<TypedefNode> = Variant({\n  struct: StructCodec,\n  terminal: TerminalCodec,\n  enum: EnumCodec,\n  tuple: TupleCodec,\n  array: ArrayCodec,\n  binary: BinaryCodec,\n  option: OptionCodec,\n  result: ResultCodec,\n})\n\nconst primitiveToTerminal: Record<MetadataPrimitives, PRIMITIVES> = {\n  i256: Primitive.big,\n  i128: Primitive.big,\n  i64: Primitive.big,\n  i32: Primitive.num,\n  i16: Primitive.num,\n  i8: Primitive.num,\n  u256: Primitive.big,\n  u128: Primitive.big,\n  u64: Primitive.big,\n  u32: Primitive.num,\n  u16: Primitive.num,\n  u8: Primitive.num,\n  bool: Primitive.bool,\n  char: Primitive.str,\n  str: Primitive.str,\n}\n\nconst terminal = (type: PRIMITIVES): TerminalNode => ({\n  type: \"terminal\",\n  value: { type },\n})\nexport function mapLookupToTypedef(\n  entry: Var,\n  resolve: (id: number) => void = () => {},\n): TypedefNode {\n  switch (entry.type) {\n    case \"AccountId20\":\n    case \"AccountId32\":\n      return terminal(Primitive.str)\n    case \"array\":\n      if (entry.value.type === \"primitive\" && entry.value.value === \"u8\") {\n        return { type: \"binary\", value: entry.len }\n      }\n      resolve(entry.value.id)\n      return {\n        type: \"array\",\n        value: {\n          typeRef: entry.value.id,\n          length: entry.len,\n        },\n      }\n    case \"bitSequence\":\n      return terminal(Primitive.bits)\n    case \"compact\":\n      return terminal(entry.isBig ? Primitive.big : Primitive.num)\n    case \"enum\":\n      return {\n        type: \"enum\",\n        value: Object.entries(entry.value).map(\n          ([key, params]): EnumNode[\"value\"][number] => {\n            if (params.type !== \"lookupEntry\")\n              return [\n                key,\n                { type: \"inline\", value: mapLookupToTypedef(params, resolve) },\n              ]\n\n            resolve(params.value.id)\n            return [\n              key,\n              {\n                type: \"lookup\",\n                value: params.value.id,\n              },\n            ]\n          },\n        ),\n      }\n    case \"struct\": {\n      const value = Object.entries(entry.value).map(\n        ([key, prop]) => [key, prop.id] satisfies [string, number],\n      )\n      value.forEach(([, v]) => resolve(v))\n      return {\n        type: \"struct\",\n        value,\n      }\n    }\n    case \"tuple\": {\n      const value = entry.value.map((v) => v.id)\n      value.forEach(resolve)\n      return {\n        type: \"tuple\",\n        value,\n      }\n    }\n    case \"option\":\n      resolve(entry.value.id)\n      return {\n        type: \"option\",\n        value: entry.value.id,\n      }\n    case \"primitive\":\n      return terminal(primitiveToTerminal[entry.value])\n    case \"result\":\n      resolve(entry.value.ok.id)\n      resolve(entry.value.ko.id)\n      return {\n        type: \"result\",\n        value: {\n          ok: entry.value.ok.id,\n          ko: entry.value.ko.id,\n        },\n      }\n    case \"sequence\":\n      if (entry.value.type === \"primitive\" && entry.value.value === \"u8\") {\n        return { type: \"binary\", value: undefined }\n      }\n      resolve(entry.value.id)\n      return {\n        type: \"array\",\n        value: { typeRef: entry.value.id },\n      }\n    case \"void\":\n      return terminal(Primitive.void)\n  }\n}\n\nexport function mapReferences(\n  node: TypedefNode,\n  mapFn: (id: number) => number,\n): TypedefNode {\n  switch (node.type) {\n    case \"array\":\n      return {\n        ...node,\n        value: {\n          ...node.value,\n          typeRef: mapFn(node.value.typeRef),\n        },\n      }\n    case \"option\":\n      return { ...node, value: mapFn(node.value) }\n    case \"result\":\n      return {\n        ...node,\n        value: { ok: mapFn(node.value.ok), ko: mapFn(node.value.ko) },\n      }\n    case \"tuple\":\n      return { ...node, value: node.value.map(mapFn) }\n    case \"struct\":\n      return {\n        ...node,\n        value: node.value.map(([k, v]) => [k, mapFn(v)] as [string, number]),\n      }\n    case \"enum\": {\n      return {\n        ...node,\n        value: node.value.map(([k, { type, value }]): EnumNode[\"value\"][0] => [\n          k,\n          type === \"lookup\"\n            ? { type, value: mapFn(value) }\n            : { type, value: mapReferences(value, mapFn) },\n        ]),\n      }\n    }\n\n    case \"binary\":\n    case \"terminal\":\n      return node\n  }\n}\n","import { Binary } from \"@polkadot-api/substrate-bindings\"\nimport { Primitive, type TerminalNode, type TypedefNode } from \"./typedef\"\n\n// Descriptors: pallet + name => index (this._descriptors[opType][pallet][name])\n// index will be for both checksums and compatLookup\n\n// Dest type: describes types of the receiving end.\nexport function isCompatible(\n  value: any,\n  destNode: TypedefNode,\n  getNode: (id: number) => TypedefNode,\n): boolean {\n  if (destNode.type === \"option\" && value == null) {\n    return true\n  }\n\n  const nextCall = (value: any, destNode: TypedefNode) =>\n    isCompatible(value, destNode, getNode)\n\n  const checkTerminal = (terminal: TerminalNode) => {\n    switch (terminal.value.type) {\n      case Primitive.str:\n      case Primitive.big:\n      case Primitive.bool:\n      case Primitive.num:\n        return typeof value === terminal.value.type\n      case Primitive.bits:\n        return (\n          typeof value === \"object\" &&\n          value != null &&\n          typeof value.bitsLen === \"number\" &&\n          value.bytes instanceof Uint8Array\n        )\n      case Primitive.void:\n        // A void node is always compatible, since the codec ignores the input.\n        return true\n    }\n  }\n\n  switch (destNode.type) {\n    case \"terminal\":\n      return checkTerminal(destNode)\n    case \"binary\":\n      return (\n        value instanceof Binary &&\n        (destNode.value == null || value.asBytes().length >= destNode.value)\n      )\n    case \"array\":\n      if (!Array.isArray(value)) return false\n      const valueArr = value as Array<any>\n      if (\n        destNode.value.length != null &&\n        valueArr.length < destNode.value.length\n      ) {\n        return false\n      }\n      return valueArr\n        .slice(0, destNode.value.length)\n        .every((value) => nextCall(value, getNode(destNode.value.typeRef)))\n    case \"enum\":\n      if (!value) return false\n      const valueEnum = value as { type: string; value: any }\n      const destVariants = Object.fromEntries(destNode.value)\n      if (!(valueEnum.type in destVariants)) {\n        return false\n      }\n      const variantValue = destVariants[valueEnum.type]\n      if (variantValue == null) {\n        return true\n      }\n      return nextCall(\n        valueEnum.value,\n        variantValue.type === \"inline\"\n          ? variantValue.value\n          : getNode(variantValue.value),\n      )\n    case \"option\":\n      if (value == null) {\n        return true\n      }\n      return nextCall(value, getNode(destNode.value))\n    case \"struct\":\n      if (!value) return false\n      return destNode.value.every(([key, typeRef]) =>\n        nextCall(value[key], getNode(typeRef)),\n      )\n    case \"tuple\":\n      if (!value) return false\n      // length will be checked indirectly\n      return destNode.value.every((typeRef, idx) =>\n        nextCall(value[idx], getNode(typeRef)),\n      )\n    case \"result\":\n      if (!(\"success\" in value && \"value\" in value)) return false\n      return nextCall(\n        value.value,\n        getNode(value.success ? destNode.value.ok : destNode.value.ko),\n      )\n  }\n}\n","export class DoubleSet<T> {\n  private value: Map<T, Set<T>> = new Map()\n\n  constructor(values: Array<[T, T]> = []) {\n    values.forEach(([a, b]) => this.add(a, b))\n  }\n\n  public has(a: T, b: T) {\n    return this.value.get(a)?.has(b) ?? false\n  }\n  public add(a: T, b: T) {\n    if (!this.value.has(a)) {\n      this.value.set(a, new Set())\n    }\n    this.value.get(a)!.add(b)\n  }\n  public addAll(values: Array<[T, T]>) {\n    values.forEach(([a, b]) => this.add(a, b))\n  }\n  public delete(a: T, b: T) {\n    if (!this.value.has(a)) return\n    const set = this.value.get(a)!\n    set.delete(b)\n    if (!set.size) {\n      this.value.delete(a)\n    }\n  }\n  public isEmpty() {\n    return !this.value.size\n  }\n  public get values() {\n    return Array.from(this.value).flatMap(([a, values]) =>\n      Array.from(values).map((b) => [a, b] as [T, T]),\n    )\n  }\n}\n","import { DoubleSet } from \"./doubleSet\"\nimport type {\n  ArrayNode,\n  BinaryNode,\n  EnumNode,\n  OptionNode,\n  ResultNode,\n  StructNode,\n  TerminalNode,\n  TupleNode,\n  TypedefNode,\n} from \"./typedef\"\n\nexport enum CompatibilityLevel {\n  // No possible value from origin will be compatible with dest\n  Incompatible = 0,\n  // Some values of origin will be compatible with dest\n  Partial,\n  // Every value from origin will be compatible with dest\n  BackwardsCompatible,\n  // Types are identical\n  Identical,\n}\n\n/*\n * We have to be careful with circular references and early returns with the cache.\n *\n * For early returns, the resulting level could be even lower when exploring other branches.\n * This means that we can't store early returns in the cache. For simplicity, the\n * initial implementation will not have early returns.\n * It should be possible to store in the cache what was the CompatibilityLevel that\n * caused the early return, so that if the same call is done with the same CompatibilityLevel\n * we could still leverage the cache.\n *\n * For circular references, the simplest solution is to assume that the circular\n * node is fully-compatible (Identical). But then any node that is reading from it\n * can't be cached because its result will be doing the assumption that the circular\n * node is `Identical`.\n * Only once the whole cycle has completed, then the circular node can actually\n * cache its own result (TODO check this assumption is fine), and then any other\n * node that referenced it can also safely cache.\n * We have to think cases where there could be two cycles:\n *         F ← E\n *         ↓   ↑\n * A → B → C → D\n *     ↑       ↓\n *     I ← H ← G\n *\n * B = 4 => B = 1\n * B = 1 => B = 0\n *\n * As we're going depth-first, when we reach C from F, we will return a \"temporary\"\n * `Identical`. This means that F, E or D can't be cached. But then we continue\n * depth-first into G-H-I-B, then detect the cycle and return a \"temporary\" `Identical`.\n * Then I, H, G and C can't be cached because they actually depend on the temporary result of B.\n * B on the other hand will be able to cache its own result, and so does A.\n *\n * If a new call enters the cycle from D, then the branch G-H-I-B will be cached.\n * But the cycle D-E-F-C will make E-F-C not to cache their result yet.\n *\n *\n * => Maybe instead of having two separate [originNode, destNode] we can first merge\n * both trees into one, and then run the search? This would simplify the double-map/set stuff.\n * Can it be done lazily though? In a way that we don't need to go through the whole tree?\n */\n\nexport type Change = {\n  path: string\n  id: [number | null, number | null]\n  level: CompatibilityLevel\n}\nexport type StaticCompatibleResult = {\n  level: CompatibilityLevel\n  // paths causing the compatibility level. Doesn't return `Identical` paths.\n  changes: Array<Change>\n  // set of nodes that are assumed \"Identical\" (used with circular references)\n  assumptions: DoubleSet<TypedefNode>\n}\nexport type CompatibilityCache = Map<\n  TypedefNode,\n  Map<TypedefNode, { level: CompatibilityLevel; changes: Array<Change> } | null>\n>\nexport function isStaticCompatible(\n  originNode: TypedefNode | undefined,\n  getOriginNode: (id: number) => TypedefNode,\n  destNode: TypedefNode | undefined,\n  getDestNode: (id: number) => TypedefNode,\n  cache: CompatibilityCache,\n  deep = false,\n): StaticCompatibleResult {\n  if (!destNode && !originNode) {\n    return unconditional(CompatibilityLevel.Identical, [])\n  }\n  if (!destNode)\n    return unconditional(CompatibilityLevel.BackwardsCompatible, [])\n  if (!originNode)\n    return unconditional(\n      destNode.type === \"option\"\n        ? CompatibilityLevel.BackwardsCompatible\n        : CompatibilityLevel.Incompatible,\n      [],\n    )\n\n  if (!cache.has(destNode)) {\n    cache.set(destNode, new Map())\n  }\n  const destNodeCache = cache.get(destNode)!\n  if (destNodeCache.has(originNode)) {\n    const result = destNodeCache.get(originNode)\n    if (result == null) {\n      // Circular reference hit, return Identical with assumption\n      return {\n        level: CompatibilityLevel.Identical,\n        changes: [],\n        assumptions: new DoubleSet([[originNode, destNode]]),\n      }\n    }\n    return unconditional(result.level, result.changes)\n  }\n\n  // Initialize to null for detecting circular references\n  destNodeCache.set(originNode, null)\n\n  const result = getIsStaticCompatible(\n    originNode,\n    destNode,\n    (originNode, destNode) =>\n      isStaticCompatible(\n        typeof originNode === \"number\" ? getOriginNode(originNode) : originNode,\n        getOriginNode,\n        typeof destNode === \"number\" ? getDestNode(destNode) : destNode,\n        getDestNode,\n        cache,\n      ),\n    deep,\n  )\n\n  result.assumptions.delete(originNode, destNode)\n  if (\n    result.assumptions.isEmpty() ||\n    result.level === CompatibilityLevel.Incompatible\n  ) {\n    destNodeCache.set(originNode, result)\n  } else {\n    // Remove the temporary `null` value from the cache\n    destNodeCache.delete(originNode)\n  }\n  return result\n}\n\nfunction getIsStaticCompatible(\n  originNode: TypedefNode,\n  destNode: TypedefNode,\n  next: (\n    originNode: TypedefNode | number | undefined,\n    destNode: TypedefNode | number | undefined,\n  ) => StaticCompatibleResult,\n  deep: boolean,\n): StaticCompatibleResult {\n  const nextCall = (\n    originNode: TypedefNode | number | undefined,\n    destNode: TypedefNode | number | undefined,\n    path: string,\n  ): StaticCompatibleResult => {\n    const result = next(originNode, destNode)\n    return {\n      ...result,\n      changes:\n        result.level < CompatibilityLevel.Identical\n          ? [\n              {\n                id: [\n                  typeof originNode === \"number\" ? originNode : null,\n                  typeof destNode === \"number\" ? destNode : null,\n                ],\n                level: result.level,\n                path,\n              },\n            ]\n          : [],\n    }\n  }\n\n  if (originNode.type !== destNode.type) {\n    if (destNode.type === \"option\") {\n      return withMaxLevel(\n        nextCall(originNode, destNode.value, \"some\"),\n        CompatibilityLevel.BackwardsCompatible,\n      )\n    }\n    if (originNode.type === \"option\") {\n      return withMaxLevel(\n        nextCall(originNode.value, destNode, \"some\"),\n        CompatibilityLevel.Partial,\n      )\n    }\n    return unconditional(CompatibilityLevel.Incompatible, [])\n  }\n\n  switch (destNode.type) {\n    case \"terminal\":\n      return unconditional(\n        destNode.value.type === (originNode as TerminalNode).value.type\n          ? CompatibilityLevel.Identical\n          : CompatibilityLevel.Incompatible,\n        [],\n      )\n    case \"binary\":\n      const binaryOrigin = originNode as BinaryNode\n      return lengthChange(\n        compareOptionalLengths(binaryOrigin.value, destNode.value),\n      )\n    case \"array\":\n      const arrayOrigin = originNode as ArrayNode\n      const lengthCheck = lengthChange(\n        compareOptionalLengths(arrayOrigin.value.length, destNode.value.length),\n      )\n      return strictMerge(\n        [\n          lengthCheck,\n          () =>\n            nextCall(\n              arrayOrigin.value.typeRef,\n              destNode.value.typeRef,\n              \"value\",\n            ),\n        ],\n        deep,\n      )\n    case \"enum\": {\n      const enumOrigin = originNode as EnumNode\n      const destVariants = Object.fromEntries(\n        destNode.value.map(([key, value]) => [key, value.value]),\n      )\n\n      // check whether every possible `origin` value is compatible with dest\n      let enumResults = mergeResults(\n        enumOrigin.value.map(\n          ([type, value]) =>\n            () =>\n              type in destVariants\n                ? nextCall(value.value, destVariants[type], type)\n                : unconditional(CompatibilityLevel.Incompatible, [\n                    {\n                      id: [\n                        typeof value.value === \"number\" ? value.value : null,\n                        null,\n                      ],\n                      level: CompatibilityLevel.Incompatible,\n                      path: type,\n                    },\n                  ]),\n        ),\n      )\n      if (enumOrigin.value.length === destNode.value.length) return enumResults\n      enumResults = withMaxLevel(\n        enumResults,\n        CompatibilityLevel.BackwardsCompatible,\n      )\n\n      // Then add in the missing values as incompatible changes\n      const enumOriginVariants = new Set(enumOrigin.value.map(([key]) => key))\n      enumResults.changes = [\n        ...enumResults.changes,\n        ...destNode.value\n          .filter(([key]) => !enumOriginVariants.has(key))\n          .map(\n            ([key, value]): Change => ({\n              id: [null, typeof value === \"number\" ? value : null],\n              level: CompatibilityLevel.Incompatible,\n              path: key,\n            }),\n          ),\n      ]\n      return enumResults\n    }\n    case \"option\":\n      return withMinLevel(\n        nextCall((originNode as OptionNode).value, destNode.value, \"some\"),\n        CompatibilityLevel.Partial,\n      )\n    case \"struct\":\n      const structOrigin = originNode as StructNode\n      const originProperties = Object.fromEntries(structOrigin.value)\n      const maxLevel =\n        structOrigin.value.length === destNode.value.length\n          ? CompatibilityLevel.Identical\n          : CompatibilityLevel.BackwardsCompatible\n\n      return withMaxLevel(\n        strictMerge(\n          destNode.value.map(\n            ([key, value]) =>\n              () =>\n                nextCall(originProperties[key], value, key),\n          ),\n          deep,\n        ),\n        maxLevel,\n      )\n    case \"tuple\": {\n      const tupleOrigin = originNode as TupleNode\n      const lengthCheck = lengthChange(\n        compareArrayLengths(tupleOrigin.value, destNode.value),\n      )\n      return strictMerge(\n        [\n          lengthCheck,\n          ...destNode.value.map(\n            (value, idx) => () =>\n              nextCall(tupleOrigin.value[idx], value, String(idx)),\n          ),\n        ],\n        deep,\n      )\n    }\n    case \"result\":\n      const resultOrigin = originNode as ResultNode\n      return mergeResults([\n        nextCall(resultOrigin.value.ok, destNode.value.ok, \"ok\"),\n        nextCall(resultOrigin.value.ko, destNode.value.ko, \"ko\"),\n      ])\n  }\n}\n\nconst withMaxLevel = (\n  result: StaticCompatibleResult,\n  level: CompatibilityLevel,\n): StaticCompatibleResult => ({\n  // Changes stay the same. Use case: Option<Incompatible>, the option should show up as Partial, but the change should indicate that the inner one is incompatible.\n  ...result,\n  // Confusing yes, but it's Math.min. If we do withMaxLevel(result, 1), we expect to get at most [1] as a result\n  level: Math.min(result.level, level),\n})\nconst withMinLevel = (\n  result: StaticCompatibleResult,\n  level: CompatibilityLevel,\n): StaticCompatibleResult => ({\n  ...result,\n  level: Math.max(result.level, level),\n})\n\nconst noAssumptions = new DoubleSet<TypedefNode>()\nconst unconditional = (\n  level: CompatibilityLevel,\n  changes: Array<Change>,\n): StaticCompatibleResult => ({\n  level,\n  changes,\n  assumptions: noAssumptions,\n})\n\n/**\n * Merges multiple results, following the most \"strict\" one, (semantically an\n * AND)\n */\nconst strictMerge = (\n  results: Array<StaticCompatibleResult | (() => StaticCompatibleResult)>,\n  deep: boolean,\n): StaticCompatibleResult => {\n  let merged = unconditional(CompatibilityLevel.Identical, [])\n\n  for (const resultFn of results) {\n    const result = typeof resultFn === \"function\" ? resultFn() : resultFn\n    // On early return we don't need to keep the other assumptions\n    if (!deep && result.level === CompatibilityLevel.Incompatible) return result\n\n    if (result.level !== CompatibilityLevel.Identical)\n      merged.changes = [...merged.changes, ...result.changes]\n    merged.assumptions.addAll(result.assumptions.values)\n    merged.level = Math.min(merged.level, result.level)\n  }\n\n  return merged\n}\n\n/**\n * Merges multiple results, going to `partially` (semantically an OR)\n */\nconst mergeResults = (\n  results: Array<StaticCompatibleResult | (() => StaticCompatibleResult)>,\n): StaticCompatibleResult => {\n  if (!results.length) return unconditional(CompatibilityLevel.Identical, [])\n\n  let hasCompatibles = false\n\n  let merged = unconditional(CompatibilityLevel.Identical, [])\n  for (const resultFn of results) {\n    const result = typeof resultFn === \"function\" ? resultFn() : resultFn\n    if (result.level !== CompatibilityLevel.Identical)\n      merged.changes = [...merged.changes, ...result.changes]\n    if (result.level === CompatibilityLevel.Incompatible) {\n      merged.level = Math.min(merged.level, CompatibilityLevel.Partial)\n      continue\n    }\n    hasCompatibles = true\n\n    merged.assumptions.addAll(result.assumptions.values)\n    merged.level = Math.min(merged.level, result.level)\n  }\n\n  return hasCompatibles\n    ? merged\n    : unconditional(CompatibilityLevel.Incompatible, merged.changes)\n}\n\nconst lengthChange = (level: CompatibilityLevel): StaticCompatibleResult => ({\n  assumptions: noAssumptions,\n  changes:\n    level === CompatibilityLevel.Identical\n      ? []\n      : [\n          {\n            id: [null, null],\n            level,\n            path: \"length\",\n          },\n        ],\n  level,\n})\n\nconst compareArrayLengths = (\n  origin: unknown[],\n  dest: unknown[],\n): CompatibilityLevel =>\n  dest.length === origin.length\n    ? CompatibilityLevel.Identical\n    : origin.length >= dest.length\n      ? CompatibilityLevel.BackwardsCompatible\n      : CompatibilityLevel.Incompatible\n\nconst compareOptionalLengths = (\n  origin: number | undefined,\n  dest: number | undefined,\n): CompatibilityLevel =>\n  dest === origin\n    ? CompatibilityLevel.Identical\n    : dest == null || origin! >= dest\n      ? CompatibilityLevel.BackwardsCompatible\n      : origin == null\n        ? CompatibilityLevel.Partial\n        : CompatibilityLevel.Incompatible\n","import type { EnumVar } from \"@polkadot-api/metadata-builders\"\nimport {\n  compactNumber,\n  UnifiedMetadata,\n  Struct,\n  Variant,\n} from \"@polkadot-api/substrate-bindings\"\nimport { isCompatible } from \"./isCompatible\"\nimport {\n  Change,\n  CompatibilityCache,\n  CompatibilityLevel,\n  isStaticCompatible,\n} from \"./isStaticCompatible\"\nimport {\n  mapLookupToTypedef,\n  mapReferences,\n  Primitive,\n  TypedefCodec,\n  type TypedefNode,\n} from \"./typedef\"\n\nexport type EntryPointNode =\n  | {\n      type: \"lookup\"\n      value: number\n    }\n  | {\n      type: \"typedef\"\n      value: TypedefNode\n    }\nconst EntryPointNodeCodec = Variant({\n  lookup: compactNumber,\n  typedef: TypedefCodec,\n})\n\nconst lookupNode = (value: number): EntryPointNode => ({\n  type: \"lookup\",\n  value,\n})\nconst typedefNode = (value: TypedefNode): EntryPointNode => ({\n  type: \"typedef\",\n  value,\n})\nexport const voidEntryPointNode = typedefNode({\n  type: \"terminal\",\n  value: { type: Primitive.void },\n})\n\nexport interface EntryPoint {\n  args: EntryPointNode\n  values: EntryPointNode\n}\nexport const EntryPointCodec = Struct({\n  args: EntryPointNodeCodec,\n  values: EntryPointNodeCodec,\n})\n\nexport function storageEntryPoint(\n  storageEntry: Exclude<\n    UnifiedMetadata[\"pallets\"][number][\"storage\"],\n    undefined\n  >[\"items\"][number],\n): EntryPoint {\n  if (storageEntry.type.tag === \"plain\")\n    return {\n      args: voidEntryPointNode,\n      values: lookupNode(storageEntry.type.value),\n    }\n\n  const { key, value } = storageEntry.type.value\n  return {\n    args: lookupNode(key),\n    values: lookupNode(value),\n  }\n}\n\nexport function runtimeCallEntryPoint(\n  entry: UnifiedMetadata[\"apis\"][number][\"methods\"][number],\n): EntryPoint {\n  return {\n    args: typedefNode({\n      type: \"tuple\",\n      value: entry.inputs.map((v) => v.type),\n    }),\n    values: lookupNode(entry.output),\n  }\n}\n\nexport function enumValueEntryPointNode(\n  entry: EnumVar[\"value\"][keyof EnumVar[\"value\"]],\n): EntryPointNode {\n  return entry.type === \"lookupEntry\"\n    ? lookupNode(entry.value.id)\n    : typedefNode(mapLookupToTypedef(entry))\n}\n\nexport function singleValueEntryPoint(value: number): EntryPoint {\n  return {\n    args: voidEntryPointNode,\n    values: lookupNode(value),\n  }\n}\n\nexport interface CompatibilityResult {\n  level: CompatibilityLevel\n  changes: Array<Change>\n}\n\nexport function entryPointsAreCompatible(\n  descriptorEntry: EntryPoint,\n  getDescriptorNode: (id: number) => TypedefNode,\n  runtimeEntry: EntryPoint,\n  getRuntimeNode: (id: number) => TypedefNode,\n  cache: CompatibilityCache,\n  deep?: boolean,\n): {\n  args: CompatibilityResult\n  values: CompatibilityResult\n} {\n  const resolveNode = (\n    node: EntryPointNode,\n    getTypedef: (id: number) => TypedefNode,\n  ): TypedefNode =>\n    node.type === \"lookup\" ? getTypedef(node.value) : node.value\n\n  // EntryPoint interaction \"origin -> dest\" is descriptor -> runtime for args, and runtime -> descriptor for values.\n  return {\n    args: isStaticCompatible(\n      resolveNode(descriptorEntry.args, getDescriptorNode),\n      getDescriptorNode,\n      resolveNode(runtimeEntry.args, getRuntimeNode),\n      getRuntimeNode,\n      cache,\n      deep,\n    ),\n    values: isStaticCompatible(\n      resolveNode(runtimeEntry.values, getRuntimeNode),\n      getRuntimeNode,\n      resolveNode(descriptorEntry.values, getDescriptorNode),\n      getDescriptorNode,\n      cache,\n      deep,\n    ),\n  }\n}\n\nexport function valueIsCompatibleWithDest(\n  dest: EntryPointNode,\n  getDestNode: (id: number) => TypedefNode,\n  value: unknown,\n) {\n  const node = dest.type === \"lookup\" ? getDestNode(dest.value) : dest.value\n  return isCompatible(value, node, getDestNode)\n}\n\nexport function mapEntryPointReferences(\n  entryPoint: EntryPoint,\n  mapFn: (id: number) => number,\n): EntryPoint {\n  const mapNode = (node: EntryPointNode) =>\n    node.type === \"lookup\"\n      ? lookupNode(mapFn(node.value))\n      : typedefNode(mapReferences(node.value, mapFn))\n\n  return {\n    args: mapNode(entryPoint.args),\n    values: mapNode(entryPoint.values),\n  }\n}\n"],"names":["compactNumber","Vector","Tuple","str","Variant","_void","Self","Struct","Option","value","destNode","Binary","CompatibilityLevel","result","originNode","lengthCheck"],"mappings":"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"}