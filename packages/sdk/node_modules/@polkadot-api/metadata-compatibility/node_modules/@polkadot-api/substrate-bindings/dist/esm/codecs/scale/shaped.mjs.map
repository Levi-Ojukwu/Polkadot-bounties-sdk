{"version":3,"file":"shaped.mjs","sources":["../../../../src/codecs/scale/shaped.ts"],"sourcesContent":["import {\n  Struct as OStruct,\n  Tuple as OTuple,\n  Vector as OVector,\n  Result as OResult,\n  Option as OOption,\n  Codec,\n  Encoder,\n  Decoder,\n  StringRecord,\n  CodecType,\n  EncoderType,\n  DecoderType,\n  ResultPayload,\n} from \"scale-ts\"\nimport { withInner } from \"./with-inner\"\n\nexport const Struct: {\n  <A extends StringRecord<Codec<any>>>(\n    codecs: A,\n  ): Codec<{ [K in keyof A]: CodecType<A[K]> }> & { inner: A }\n  enc: <A_1 extends StringRecord<Encoder<any>>>(\n    encoders: A_1,\n  ) => Encoder<{ [K_1 in keyof A_1]: EncoderType<A_1[K_1]> }> & { inner: A_1 }\n  dec: <A_2 extends StringRecord<Decoder<any>>>(\n    decoders: A_2,\n  ) => Decoder<{ [K_2 in keyof A_2]: DecoderType<A_2[K_2]> }> & { inner: A_2 }\n} = (codecs) => withInner(OStruct(codecs), codecs)\nStruct.enc = (x) => withInner(OStruct.enc(x), x)\nStruct.dec = (x) => withInner(OStruct.dec(x), x)\n\nexport const Tuple: {\n  <A extends Codec<any>[]>(\n    ...inner: A\n  ): Codec<{ [K in keyof A]: A[K] extends Codec<infer D> ? D : unknown }> & {\n    inner: A\n  }\n  enc: <A_1 extends Encoder<any>[]>(\n    ...encoders: A_1\n  ) => Encoder<{\n    [K_1 in keyof A_1]: A_1[K_1] extends Encoder<infer D_1> ? D_1 : unknown\n  }> & { inner: A_1 }\n  dec: <A_2 extends Decoder<any>[]>(\n    ...decoders: A_2\n  ) => Decoder<{\n    [K_2 in keyof A_2]: A_2[K_2] extends Decoder<infer D_2> ? D_2 : unknown\n  }> & { inner: A_2 }\n} = (...inner) => withInner(OTuple(...inner), inner)\nTuple.enc = (...inner) => withInner(OTuple.enc(...inner), inner)\nTuple.dec = (...inner) => withInner(OTuple.dec(...inner), inner)\n\nexport const Vector: {\n  <T>(\n    inner: Codec<T>,\n    size?: number | undefined,\n  ): Codec<T[]> & { inner: Codec<T> }\n  enc: <T_1>(\n    inner: Encoder<T_1>,\n    size?: number | undefined,\n  ) => Encoder<T_1[]> & { inner: Encoder<T_1> }\n  dec: <T_2>(\n    getter: Decoder<T_2>,\n    size?: number | undefined,\n  ) => Decoder<T_2[]> & { inner: Decoder<T_2> }\n} = (inner, ...rest) => withInner(OVector(inner, ...rest), inner)\nVector.enc = (inner, ...rest) => withInner(OVector.enc(inner, ...rest), inner)\nVector.dec = (inner, ...rest) => withInner(OVector.dec(inner, ...rest), inner)\n\nexport const Result: {\n  <OK, KO>(\n    okCodec: Codec<OK>,\n    koCodec: Codec<KO>,\n  ): Codec<ResultPayload<OK, KO>> & { inner: { ok: Codec<OK>; ko: Codec<KO> } }\n  dec: <OK_1, KO_1>(\n    okDecoder: Decoder<OK_1>,\n    koDecoder: Decoder<KO_1>,\n  ) => Decoder<ResultPayload<OK_1, KO_1>> & {\n    inner: { ok: Decoder<OK_1>; ko: Decoder<KO_1> }\n  }\n  enc: <OK_2, KO_2>(\n    okEncoder: Encoder<OK_2>,\n    koEncoder: Encoder<KO_2>,\n  ) => Encoder<ResultPayload<OK_2, KO_2>> & {\n    inner: { ok: Encoder<OK_2>; ko: Encoder<KO_2> }\n  }\n} = (ok, ko) => withInner(OResult(ok, ko), { ok, ko })\nResult.enc = (ok, ko) => withInner(OResult.enc(ok, ko), { ok, ko })\nResult.dec = (ok, ko) => withInner(OResult.dec(ok, ko), { ok, ko })\n\nexport const Option: {\n  <T>(inner: Codec<T>): Codec<T | undefined> & { inner: Codec<T> }\n  enc: <T_1>(\n    inner: Encoder<T_1>,\n  ) => Encoder<T_1 | undefined> & { inner: Encoder<T_1> }\n  dec: <T_2>(\n    inner: Decoder<T_2>,\n  ) => Decoder<T_2 | undefined> & { inner: Decoder<T_2> }\n} = (inner) => withInner(OOption(inner), inner)\nOption.enc = (inner) => withInner(OOption.enc(inner), inner)\nOption.dec = (inner) => withInner(OOption.dec(inner), inner)\n"],"names":["OStruct","OTuple","OVector","OResult","OOption"],"mappings":";;;AAiBO,MAAM,SAUT,CAAC,MAAA,KAAW,UAAUA,QAAA,CAAQ,MAAM,GAAG,MAAM;AACjD,MAAA,CAAO,GAAA,GAAM,CAAC,CAAA,KAAM,SAAA,CAAUA,SAAQ,GAAA,CAAI,CAAC,GAAG,CAAC,CAAA;AAC/C,MAAA,CAAO,GAAA,GAAM,CAAC,CAAA,KAAM,SAAA,CAAUA,SAAQ,GAAA,CAAI,CAAC,GAAG,CAAC,CAAA;AAExC,MAAM,KAAA,GAgBT,IAAI,KAAA,KAAU,SAAA,CAAUC,QAAO,GAAG,KAAK,GAAG,KAAK;AACnD,KAAA,CAAM,GAAA,GAAM,IAAI,KAAA,KAAU,SAAA,CAAUA,QAAO,GAAA,CAAI,GAAG,KAAK,CAAA,EAAG,KAAK,CAAA;AAC/D,KAAA,CAAM,GAAA,GAAM,IAAI,KAAA,KAAU,SAAA,CAAUA,QAAO,GAAA,CAAI,GAAG,KAAK,CAAA,EAAG,KAAK,CAAA;AAExD,MAAM,MAAA,GAaT,CAAC,KAAA,EAAA,GAAU,IAAA,KAAS,SAAA,CAAUC,SAAQ,KAAA,EAAO,GAAG,IAAI,CAAA,EAAG,KAAK;AAChE,MAAA,CAAO,GAAA,GAAM,CAAC,KAAA,EAAA,GAAU,IAAA,KAAS,SAAA,CAAUA,QAAA,CAAQ,GAAA,CAAI,KAAA,EAAO,GAAG,IAAI,CAAA,EAAG,KAAK,CAAA;AAC7E,MAAA,CAAO,GAAA,GAAM,CAAC,KAAA,EAAA,GAAU,IAAA,KAAS,SAAA,CAAUA,QAAA,CAAQ,GAAA,CAAI,KAAA,EAAO,GAAG,IAAI,CAAA,EAAG,KAAK,CAAA;AAEtE,MAAM,MAAA,GAiBT,CAAC,EAAA,EAAI,EAAA,KAAO,SAAA,CAAUC,QAAA,CAAQ,EAAA,EAAI,EAAE,CAAA,EAAG,EAAE,EAAA,EAAI,EAAA,EAAI;AACrD,MAAA,CAAO,GAAA,GAAM,CAAC,EAAA,EAAI,EAAA,KAAO,SAAA,CAAUA,QAAA,CAAQ,GAAA,CAAI,EAAA,EAAI,EAAE,CAAA,EAAG,EAAE,EAAA,EAAI,IAAI,CAAA;AAClE,MAAA,CAAO,GAAA,GAAM,CAAC,EAAA,EAAI,EAAA,KAAO,SAAA,CAAUA,QAAA,CAAQ,GAAA,CAAI,EAAA,EAAI,EAAE,CAAA,EAAG,EAAE,EAAA,EAAI,IAAI,CAAA;AAE3D,MAAM,SAQT,CAAC,KAAA,KAAU,UAAUC,QAAA,CAAQ,KAAK,GAAG,KAAK;AAC9C,MAAA,CAAO,GAAA,GAAM,CAAC,KAAA,KAAU,SAAA,CAAUA,SAAQ,GAAA,CAAI,KAAK,GAAG,KAAK,CAAA;AAC3D,MAAA,CAAO,GAAA,GAAM,CAAC,KAAA,KAAU,SAAA,CAAUA,SAAQ,GAAA,CAAI,KAAK,GAAG,KAAK,CAAA;;;;"}