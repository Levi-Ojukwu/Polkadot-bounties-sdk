{"version":3,"file":"storage.mjs","sources":["../../src/storage.ts"],"sourcesContent":["import { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport type { Codec } from \"scale-ts\"\nimport {\n  Blake2128,\n  Blake2128Concat,\n  Blake2256,\n  Identity,\n  Twox128,\n  Twox256,\n  Twox64Concat,\n} from \"./hashes\"\n\nexport type EncoderWithHash<T> = [Codec<T>, (input: Uint8Array) => Uint8Array]\n\nconst textEncoder = new TextEncoder()\n\n// the value indicates:\n// - when positive: the number of bytes to skip before reaching the transparent-encoded key\n// - when negative: the number of bytes that the opaque hasher will generate\nconst hashers: Map<(input: Uint8Array) => Uint8Array, number> = new Map([\n  [Identity, 0],\n  [Twox64Concat, 8],\n  [Blake2128Concat, 16],\n  [Blake2128, -16],\n  [Blake2256, -32],\n  [Twox128, -16],\n  [Twox256, -32],\n])\n\nexport type OpaqueKeyHash = string & { __opaqueKeyHash?: unknown }\n\nexport const Storage = (pallet: string) => {\n  const palledEncoded = Twox128(textEncoder.encode(pallet))\n  return <A extends Array<EncoderWithHash<any>>>(\n    name: string,\n    ...encoders: [...A]\n  ): {\n    enc: (\n      ...args: {\n        [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n      }\n    ) => string\n    dec: (value: string) => {\n      [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n    }\n  } => {\n    const palletItemEncoded = mergeUint8([\n      palledEncoded,\n      Twox128(textEncoder.encode(name)),\n    ])\n\n    const palletItemEncodedHex = toHex(palletItemEncoded)\n\n    const dec = (\n      key: string,\n    ): {\n      [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n    } => {\n      if (!key.startsWith(palletItemEncodedHex))\n        throw new Error(`key does not match this storage (${pallet}.${name})`)\n\n      if (encoders.length === 0) return [] as any\n\n      const argsKey = fromHex(key.slice(palletItemEncodedHex.length))\n      const result = new Array<any>(encoders.length)\n      for (let i = 0, cur = 0; i < encoders.length; i++) {\n        const [codec, hasher] = encoders[i]\n        const hBytes = hashers.get(hasher)\n        if (hBytes == null) throw new Error(\"Unknown hasher\")\n        if (hBytes < 0) {\n          const opaqueBytes = hBytes * -1\n          result[i] = toHex(argsKey.slice(cur, cur + opaqueBytes))\n          cur += opaqueBytes\n        } else {\n          cur += hBytes\n          result[i] = codec.dec(argsKey.slice(cur))\n          cur += codec.enc(result[i]).length\n        }\n      }\n      return result as any\n    }\n\n    const fns = encoders.map(\n      ([{ enc }, hash]) =>\n        (val: any) =>\n          hash(enc(val)),\n    )\n\n    const enc = (\n      ...args: {\n        [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n      }\n    ): string =>\n      toHex(\n        mergeUint8([\n          palletItemEncoded,\n          ...args.map((val, idx) => fns[idx](val)),\n        ]),\n      )\n\n    return {\n      enc,\n      dec,\n    }\n  }\n}\n"],"names":["enc"],"mappings":"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"}