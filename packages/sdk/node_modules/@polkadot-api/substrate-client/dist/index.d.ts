export { AbortError } from '@polkadot-api/utils';
import { JsonRpcProvider } from '@polkadot-api/json-rpc-provider';
export * from '@polkadot-api/json-rpc-provider';
import { ClientRequest, Subscriber, ClientRequestCb } from '@polkadot-api/raw-client';
export * from '@polkadot-api/raw-client';
export { DestroyedError, RpcError } from '@polkadot-api/raw-client';

type UnsubscribeFn = () => void;
type WithAbortSignal<T extends Array<any>> = [
    ...args: T,
    abortSignal?: AbortSignal
];
type AbortablePromiseFn<A extends Array<any>, T> = (...args: WithAbortSignal<A>) => Promise<T>;

type Transaction = (tx: string, error: (e: Error) => void) => UnsubscribeFn;

declare const getTransaction: (request: ClientRequest<string, any>) => (tx: string, error: (e: Error) => void) => () => void;

type FollowInnerSubscriptionCb<T> = (subscriptionId: string, cb: Subscriber<T>) => UnsubscribeFn;
type ClientInnerRequestCb<T, TT> = {
    onSuccess: (result: T, followSubscription: FollowInnerSubscriptionCb<TT>) => void;
    onError: (e: Error) => void;
};
type ClientInnerRequest<T, TT> = (method: string, params: Array<any>, cb?: ClientInnerRequestCb<T, TT>) => UnsubscribeFn;
interface StorageItemInput {
    key: string;
    type: "value" | "hash" | "closestDescendantMerkleValue" | "descendantsValues" | "descendantsHashes";
}
interface StorageItemResponse {
    key: string;
    value?: string;
    hash?: string;
    closestDescendantMerkleValue?: string;
}
interface Runtime {
    specName: string;
    implName: string;
    specVersion: number;
    implVersion: number;
    transactionVersion: number;
    apis: Record<string, number>;
}
interface Initialized {
    type: "initialized";
    finalizedBlockHashes: string[];
}
type InitializedWithRuntime$1 = Initialized & {
    finalizedBlockRuntime: Runtime;
};
interface NewBlock {
    type: "newBlock";
    blockHash: string;
    parentBlockHash: string;
}
type NewBlockWithRuntime$1 = NewBlock & {
    newRuntime: Runtime | null;
};
interface BestBlockChanged {
    type: "bestBlockChanged";
    bestBlockHash: string;
}
interface Finalized {
    type: "finalized";
    finalizedBlockHashes: Array<string>;
    prunedBlockHashes: Array<string>;
}
type CommonFollowEvents = BestBlockChanged | Finalized;
type FollowEventWithRuntime = InitializedWithRuntime$1 | NewBlockWithRuntime$1 | CommonFollowEvents;
type FollowEventWithoutRuntime = Initialized | NewBlock | CommonFollowEvents;
type StorageResult<Input extends StorageItemInput["type"]> = Input extends "descendantsHashes" ? Array<{
    key: string;
    hash: string;
}> : Input extends "descendantsValues" ? Array<{
    key: string;
    value: string;
}> : string | null;
interface FollowResponse {
    unfollow: UnsubscribeFn;
    body: AbortablePromiseFn<[hash: string], Array<string>>;
    call: AbortablePromiseFn<[
        hash: string,
        fnName: string,
        callParameters: string
    ], string>;
    storage: <Type extends StorageItemInput["type"]>(hash: string, type: Type, key: string, childTrie: string | null, abortSignal?: AbortSignal | undefined) => Promise<StorageResult<Type>>;
    storageSubscription: (hash: string, inputs: Array<StorageItemInput>, childTrie: string | null, onItems: (items: Array<StorageItemResponse>) => void, onError: (e: Error) => void, onDone: () => void, onDiscardedItems: (nDiscarded: number) => void) => () => void;
    header: (hash: string) => Promise<string>;
    unpin: (hashes: Array<string>) => Promise<void>;
    _request: <Reply, Notification>(method: string, params: any[], cb?: ClientInnerRequestCb<Reply, Notification>) => UnsubscribeFn;
}
interface ChainHead {
    (withRuntime: false, cb: (event: FollowEventWithoutRuntime) => void, onError: (error: Error) => void): FollowResponse;
    (withRuntime: true, cb: (event: FollowEventWithRuntime) => void, onError: (error: Error) => void): FollowResponse;
    (withRuntime: boolean, cb: (event: FollowEventWithoutRuntime | FollowEventWithRuntime) => void, onError: (error: Error) => void): FollowResponse;
}

declare class StopError extends Error {
    constructor();
}
declare class DisjointError extends Error {
    constructor();
}
declare class OperationLimitError extends Error {
    constructor();
}
declare class OperationError extends Error {
    constructor(error: string);
}
declare class OperationInaccessibleError extends Error {
    constructor();
}

interface RuntimeRpc {
    specName: string;
    implName: string;
    specVersion: number;
    implVersion: number;
    transactionVersion: number;
    apis: Record<string, number>;
}
type InitializedRpc = {
    event: "initialized";
    finalizedBlockHashes: string[];
};
type InitializedWithRuntime = InitializedRpc & {
    finalizedBlockRuntime: RuntimeRpc;
};
interface NewBlockRpc {
    event: "newBlock";
    blockHash: string;
    parentBlockHash: string;
}
type NewBlockWithRuntime = NewBlockRpc & {
    newRuntime: RuntimeRpc | null;
};
interface BestBlockChangedRpc {
    event: "bestBlockChanged";
    bestBlockHash: string;
}
interface FinalizedRpc {
    event: "finalized";
    finalizedBlockHashes: Array<string>;
    prunedBlockHashes: Array<string>;
}
type CommonFollowEventsRpc = BestBlockChangedRpc | FinalizedRpc;
type FollowEventWithRuntimeRpc = InitializedWithRuntime | NewBlockWithRuntime | CommonFollowEventsRpc;
type FollowEventWithoutRuntimeRpc = InitializedRpc | NewBlockRpc | CommonFollowEventsRpc;
interface StopRpc {
    event: "stop";
}
interface OperationEventRpc {
    operationId: string;
}
type OperationWaitingForContinueRpc = OperationEventRpc & {
    event: "operationWaitingForContinue";
};
type OperationInaccessibleRpc = OperationEventRpc & {
    event: "operationInaccessible";
};
type OperationErrorRpc = OperationEventRpc & {
    event: "operationError";
    error: string;
};
type CommonOperationEventsRpc = OperationInaccessibleRpc | OperationErrorRpc;
type OperationBodyDoneRpc = OperationEventRpc & {
    event: "operationBodyDone";
    value: Array<string>;
};
type OperationCallDoneRpc = OperationEventRpc & {
    event: "operationCallDone";
    output: string;
};
interface StorageItemResponseRpc {
    key: string;
    value?: string;
    hash?: string;
    closestDescendantMerkleValue?: string;
}
type OperationStorageItemsRpc = OperationEventRpc & {
    event: "operationStorageItems";
    items: Array<StorageItemResponseRpc>;
};
type OperationStorageDoneRpc = OperationEventRpc & {
    event: "operationStorageDone";
};
type OperationEventsRpc = OperationBodyDoneRpc | OperationCallDoneRpc | OperationStorageItemsRpc | OperationWaitingForContinueRpc | OperationStorageDoneRpc | CommonOperationEventsRpc;

type FollowEventRpc = FollowEventWithRuntimeRpc | FollowEventWithoutRuntimeRpc | OperationEventsRpc | StopRpc;
declare function getChainHead(request: ClientRequest<string, FollowEventRpc>): ChainHead;

interface ChainSpecData {
    name: string;
    genesisHash: string;
    properties: any;
}
declare const createGetChainSpec: (clientRequest: ClientRequest<any, any>) => () => Promise<ChainSpecData>;

type ArchiveStorageItemInput = StorageItemInput & {
    paginationStartKey?: string;
};
interface Archive {
    body: AbortablePromiseFn<[hash: string], Array<string>>;
    call: AbortablePromiseFn<[
        hash: string,
        fnName: string,
        callParameters: string
    ], string>;
    header: AbortablePromiseFn<[hash: string], string>;
    finalizedHeight: AbortablePromiseFn<[], number>;
    hashByHeight: AbortablePromiseFn<[height: number], string[]>;
    storage: <Type extends StorageItemInput["type"]>(hash: string, type: Type, key: string, childTrie: string | null, abortSignal?: AbortSignal | undefined) => Promise<StorageResult<Type>>;
    storageSubscription: (hash: string, inputs: Array<ArchiveStorageItemInput>, childTrie: string | null, onItem: (item: StorageItemResponse) => void, onError: (e: Error) => void, onDone: () => void) => () => void;
}

declare class BlockHashNotFoundError extends Error {
    constructor(hash: string);
}
declare class StorageError extends Error {
    constructor(message: string);
}
declare class CallError extends Error {
    constructor(message: string);
}

declare const getArchive: (request: ClientRequest<any, any>) => Archive;

interface SubstrateClient {
    archive: Archive;
    chainHead: ChainHead;
    transaction: Transaction;
    destroy: UnsubscribeFn;
    getChainSpecData: () => Promise<ChainSpecData>;
    request: <T>(method: string, params: any[], abortSignal?: AbortSignal) => Promise<T>;
    _request: <Reply, Notification>(method: string, params: any[], cb?: ClientRequestCb<Reply, Notification>) => UnsubscribeFn;
}
declare const createClient: (provider: JsonRpcProvider) => SubstrateClient;

export { BlockHashNotFoundError, CallError, DisjointError, OperationError, OperationInaccessibleError, OperationLimitError, StopError, StorageError, createClient, createGetChainSpec, getArchive, getChainHead, getTransaction };
export type { AbortablePromiseFn, Archive, ArchiveStorageItemInput, BestBlockChanged, ChainHead, ChainSpecData, ClientInnerRequest, ClientInnerRequestCb, Finalized, FollowEventWithRuntime, FollowEventWithoutRuntime, FollowInnerSubscriptionCb, FollowResponse, Initialized, InitializedWithRuntime$1 as InitializedWithRuntime, NewBlock, NewBlockWithRuntime$1 as NewBlockWithRuntime, Runtime, StorageItemInput, StorageItemResponse, StorageResult, SubstrateClient, Transaction, UnsubscribeFn };
