{"version":3,"file":"archive.mjs","sources":["../../../src/archive/archive.ts"],"sourcesContent":["import { abortablePromiseFn } from \"@/internal-utils\"\nimport { type ClientRequest } from \"@polkadot-api/raw-client\"\nimport { createStorageCb } from \"./storage-subscription\"\nimport { createStorageFn } from \"./storage\"\nimport { Archive } from \"./public-types\"\nimport { CallError, BlockHashNotFoundError } from \"./errors\"\n\nconst identity =\n  <T>() =>\n  (x: T): T =>\n    x\n\nconst handleInvalidBlockHash =\n  <T>() =>\n  (result: T | null, hash: string): T => {\n    if (result === null) throw new BlockHashNotFoundError(hash)\n    return result\n  }\n\nexport const getArchive = (request: ClientRequest<any, any>): Archive => {\n  const archiveRequest: ClientRequest<any, any> = (method: string, ...rest) =>\n    request(`archive_v1_${method}`, ...rest)\n\n  const fnCreator =\n    <A extends Array<any>>(method: string) =>\n    <I, O>(mapper: (input: I, ...args: A) => O) =>\n      abortablePromiseFn<O, A>((res, rej, ...args) =>\n        archiveRequest(method, args, {\n          onSuccess: (x: I) => {\n            try {\n              res(mapper(x, ...args))\n            } catch (e) {\n              rej(e)\n            }\n          },\n          onError: rej,\n        }),\n      )\n\n  const header = fnCreator<[hash: string]>(\"header\")(\n    handleInvalidBlockHash<string>(),\n  )\n\n  const body = fnCreator<[hash: string]>(\"body\")(\n    handleInvalidBlockHash<string[]>(),\n  )\n\n  const storageSubscription = createStorageCb(archiveRequest)\n  const storage = createStorageFn(storageSubscription)\n\n  const call = fnCreator<\n    [hash: string, function: string, callParameters: string]\n  >(\"call\")((\n    x:\n      | { success: true; value: string }\n      | { success: false; error: string }\n      | null,\n    hash,\n  ) => {\n    if (!x) throw new BlockHashNotFoundError(hash)\n    if (!x.success) throw new CallError(x.error)\n    return x.value\n  })\n\n  const finalizedHeight = fnCreator<[]>(\"finalizedHeight\")(identity<number>())\n  const hashByHeight =\n    fnCreator<[height: number]>(\"hashByHeight\")(identity<string[]>())\n\n  return {\n    header,\n    body,\n    storageSubscription,\n    storage,\n    call,\n    finalizedHeight,\n    hashByHeight,\n  }\n}\n"],"names":[],"mappings":";;;;;AAOA,MAAM,QAAA,GACJ,MACA,CAAC,CAAA,KACC,CAAA;AAEJ,MAAM,sBAAA,GACJ,MACA,CAAC,MAAA,EAAkB,IAAA,KAAoB;AACrC,EAAA,IAAI,MAAA,KAAW,IAAA,EAAM,MAAM,IAAI,uBAAuB,IAAI,CAAA;AAC1D,EAAA,OAAO,MAAA;AACT,CAAA;AAEK,MAAM,UAAA,GAAa,CAAC,OAAA,KAA8C;AACvE,EAAA,MAAM,cAAA,GAA0C,CAAC,MAAA,EAAA,GAAmB,IAAA,KAClE,QAAQ,CAAA,WAAA,EAAc,MAAM,CAAA,CAAA,EAAI,GAAG,IAAI,CAAA;AAEzC,EAAA,MAAM,SAAA,GACJ,CAAuB,MAAA,KACvB,CAAO,MAAA,KACL,kBAAA;AAAA,IAAyB,CAAC,GAAA,EAAK,GAAA,EAAA,GAAQ,IAAA,KACrC,cAAA,CAAe,QAAQ,IAAA,EAAM;AAAA,MAC3B,SAAA,EAAW,CAAC,CAAA,KAAS;AACnB,QAAA,IAAI;AACF,UAAA,GAAA,CAAI,MAAA,CAAO,CAAA,EAAG,GAAG,IAAI,CAAC,CAAA;AAAA,QACxB,SAAS,CAAA,EAAG;AACV,UAAA,GAAA,CAAI,CAAC,CAAA;AAAA,QACP;AAAA,MACF,CAAA;AAAA,MACA,OAAA,EAAS;AAAA,KACV;AAAA,GACH;AAEJ,EAAA,MAAM,MAAA,GAAS,UAA0B,QAAQ,CAAA;AAAA,IAC/C,sBAAA;AAA+B,GACjC;AAEA,EAAA,MAAM,IAAA,GAAO,UAA0B,MAAM,CAAA;AAAA,IAC3C,sBAAA;AAAiC,GACnC;AAEA,EAAA,MAAM,mBAAA,GAAsB,gBAAgB,cAAc,CAAA;AAC1D,EAAA,MAAM,OAAA,GAAU,gBAAgB,mBAAmB,CAAA;AAEnD,EAAA,MAAM,OAAO,SAAA,CAEX,MAAM,CAAA,CAAE,CACR,GAIA,IAAA,KACG;AACH,IAAA,IAAI,CAAC,CAAA,EAAG,MAAM,IAAI,uBAAuB,IAAI,CAAA;AAC7C,IAAA,IAAI,CAAC,CAAA,CAAE,OAAA,QAAe,IAAI,SAAA,CAAU,EAAE,KAAK,CAAA;AAC3C,IAAA,OAAO,CAAA,CAAE,KAAA;AAAA,EACX,CAAC,CAAA;AAED,EAAA,MAAM,eAAA,GAAkB,SAAA,CAAc,iBAAiB,CAAA,CAAE,UAAkB,CAAA;AAC3E,EAAA,MAAM,YAAA,GACJ,SAAA,CAA4B,cAAc,CAAA,CAAE,UAAoB,CAAA;AAElE,EAAA,OAAO;AAAA,IACL,MAAA;AAAA,IACA,IAAA;AAAA,IACA,mBAAA;AAAA,IACA,OAAA;AAAA,IACA,IAAA;AAAA,IACA,eAAA;AAAA,IACA;AAAA,GACF;AACF;;;;"}