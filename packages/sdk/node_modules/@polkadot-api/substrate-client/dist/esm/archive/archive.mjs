import { abortablePromiseFn } from '../internal-utils/abortablePromiseFn.mjs';
import { createStorageCb } from './storage-subscription.mjs';
import { createStorageFn } from './storage.mjs';
import { BlockHashNotFoundError, CallError } from './errors.mjs';

const identity = () => (x) => x;
const handleInvalidBlockHash = () => (result, hash) => {
  if (result === null) throw new BlockHashNotFoundError(hash);
  return result;
};
const getArchive = (request) => {
  const archiveRequest = (method, ...rest) => request(`archive_v1_${method}`, ...rest);
  const fnCreator = (method) => (mapper) => abortablePromiseFn(
    (res, rej, ...args) => archiveRequest(method, args, {
      onSuccess: (x) => {
        try {
          res(mapper(x, ...args));
        } catch (e) {
          rej(e);
        }
      },
      onError: rej
    })
  );
  const header = fnCreator("header")(
    handleInvalidBlockHash()
  );
  const body = fnCreator("body")(
    handleInvalidBlockHash()
  );
  const storageSubscription = createStorageCb(archiveRequest);
  const storage = createStorageFn(storageSubscription);
  const call = fnCreator("call")((x, hash) => {
    if (!x) throw new BlockHashNotFoundError(hash);
    if (!x.success) throw new CallError(x.error);
    return x.value;
  });
  const finalizedHeight = fnCreator("finalizedHeight")(identity());
  const hashByHeight = fnCreator("hashByHeight")(identity());
  return {
    header,
    body,
    storageSubscription,
    storage,
    call,
    finalizedHeight,
    hashByHeight
  };
};

export { getArchive };
//# sourceMappingURL=archive.mjs.map
