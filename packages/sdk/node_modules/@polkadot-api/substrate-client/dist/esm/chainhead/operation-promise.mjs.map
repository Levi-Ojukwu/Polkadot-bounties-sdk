{"version":3,"file":"operation-promise.mjs","sources":["../../../src/chainhead/operation-promise.ts"],"sourcesContent":["import { abortablePromiseFn, noop } from \"@/internal-utils\"\nimport {\n  CommonOperationEventsRpc,\n  OperationResponseRpc,\n} from \"./json-rpc-types\"\nimport {\n  OperationError,\n  OperationInaccessibleError,\n  OperationLimitError,\n} from \"./errors\"\nimport { ClientInnerRequest } from \"./public-types\"\nimport { chainHead } from \"@/methods\"\n\nexport const createOperationPromise =\n  <I extends { operationId: string; event: string }, O, A extends Array<any>>(\n    operationName: string,\n    factory: (\n      ...args: A\n    ) => [\n      Array<any>,\n      (e: I, res: (x: O) => void, rej: (e: Error) => void) => void,\n    ],\n  ) =>\n  (\n    request: ClientInnerRequest<\n      OperationResponseRpc,\n      I | CommonOperationEventsRpc\n    >,\n  ) =>\n    abortablePromiseFn<O, A>((res, rej, ...args) => {\n      let isRunning = true\n      let cancel = () => {\n        isRunning = false\n      }\n\n      const [requestArgs, logicCb] = factory(...args)\n      request(operationName, requestArgs, {\n        onSuccess: (response, followSubscription) => {\n          if (response.result === \"limitReached\")\n            return rej(new OperationLimitError())\n\n          const { operationId } = response\n          const stopOperation = () => {\n            request(chainHead.stopOperation, [operationId])\n          }\n\n          if (!isRunning) return stopOperation()\n\n          let done = noop\n          const _res = (x: O) => {\n            isRunning = false\n            done()\n            res(x)\n          }\n          const _rej = (x: Error) => {\n            isRunning = false\n            done()\n            rej(x)\n          }\n\n          done = followSubscription(operationId, {\n            next: (e) => {\n              const _e = e as CommonOperationEventsRpc\n              if (_e.event === \"operationError\")\n                rej(new OperationError(_e.error))\n              else if (_e.event === \"operationInaccessible\")\n                rej(new OperationInaccessibleError())\n              else logicCb(e as I, _res, _rej)\n            },\n            error: _rej,\n          })\n\n          cancel = () => {\n            if (isRunning) {\n              done()\n              stopOperation()\n            }\n          }\n        },\n        onError: rej,\n      })\n\n      return () => {\n        cancel()\n      }\n    })\n"],"names":[],"mappings":";;;;;AAaO,MAAM,sBAAA,GACX,CACE,aAAA,EACA,OAAA,KAOF,CACE,YAKA,kBAAA,CAAyB,CAAC,GAAA,EAAK,GAAA,EAAA,GAAQ,IAAA,KAAS;AAC9C,EAAA,IAAI,SAAA,GAAY,IAAA;AAChB,EAAA,IAAI,SAAS,MAAM;AACjB,IAAA,SAAA,GAAY,KAAA;AAAA,EACd,CAAA;AAEA,EAAA,MAAM,CAAC,WAAA,EAAa,OAAO,CAAA,GAAI,OAAA,CAAQ,GAAG,IAAI,CAAA;AAC9C,EAAA,OAAA,CAAQ,eAAe,WAAA,EAAa;AAAA,IAClC,SAAA,EAAW,CAAC,QAAA,EAAU,kBAAA,KAAuB;AAC3C,MAAA,IAAI,SAAS,MAAA,KAAW,cAAA;AACtB,QAAA,OAAO,GAAA,CAAI,IAAI,mBAAA,EAAqB,CAAA;AAEtC,MAAA,MAAM,EAAE,aAAY,GAAI,QAAA;AACxB,MAAA,MAAM,gBAAgB,MAAM;AAC1B,QAAA,OAAA,CAAQ,SAAA,CAAU,aAAA,EAAe,CAAC,WAAW,CAAC,CAAA;AAAA,MAChD,CAAA;AAEA,MAAA,IAAI,CAAC,SAAA,EAAW,OAAO,aAAA,EAAc;AAErC,MAAA,IAAI,IAAA,GAAO,IAAA;AACX,MAAA,MAAM,IAAA,GAAO,CAAC,CAAA,KAAS;AACrB,QAAA,SAAA,GAAY,KAAA;AACZ,QAAA,IAAA,EAAK;AACL,QAAA,GAAA,CAAI,CAAC,CAAA;AAAA,MACP,CAAA;AACA,MAAA,MAAM,IAAA,GAAO,CAAC,CAAA,KAAa;AACzB,QAAA,SAAA,GAAY,KAAA;AACZ,QAAA,IAAA,EAAK;AACL,QAAA,GAAA,CAAI,CAAC,CAAA;AAAA,MACP,CAAA;AAEA,MAAA,IAAA,GAAO,mBAAmB,WAAA,EAAa;AAAA,QACrC,IAAA,EAAM,CAAC,CAAA,KAAM;AACX,UAAA,MAAM,EAAA,GAAK,CAAA;AACX,UAAA,IAAI,GAAG,KAAA,KAAU,gBAAA;AACf,YAAA,GAAA,CAAI,IAAI,cAAA,CAAe,EAAA,CAAG,KAAK,CAAC,CAAA;AAAA,eAAA,IACzB,GAAG,KAAA,KAAU,uBAAA;AACpB,YAAA,GAAA,CAAI,IAAI,4BAA4B,CAAA;AAAA,eACjC,OAAA,CAAQ,CAAA,EAAQ,IAAA,EAAM,IAAI,CAAA;AAAA,QACjC,CAAA;AAAA,QACA,KAAA,EAAO;AAAA,OACR,CAAA;AAED,MAAA,MAAA,GAAS,MAAM;AACb,QAAA,IAAI,SAAA,EAAW;AACb,UAAA,IAAA,EAAK;AACL,UAAA,aAAA,EAAc;AAAA,QAChB;AAAA,MACF,CAAA;AAAA,IACF,CAAA;AAAA,IACA,OAAA,EAAS;AAAA,GACV,CAAA;AAED,EAAA,OAAO,MAAM;AACX,IAAA,MAAA,EAAO;AAAA,EACT,CAAA;AACF,CAAC;;;;"}