import { getSubscriptionsManager, DestroyedError } from '@polkadot-api/raw-client';
import '@polkadot-api/utils';
import { deferred } from '../internal-utils/deferred-promise.mjs';
import { noop } from '../internal-utils/noop.mjs';
import { createBodyFn } from './body.mjs';
import { createCallFn } from './call.mjs';
import { createHeaderFn } from './header.mjs';
import { createStorageFn } from './storage.mjs';
import { createUnpinFn } from './unpin.mjs';
import { StopError, DisjointError } from './errors.mjs';
import { createStorageCb } from './storage-subscription.mjs';
import { chainHead } from '../methods.mjs';

function isOperationEvent(event) {
  return event.operationId !== void 0;
}
function getChainHead(request) {
  return (withRuntime, onFollowEvent, onFollowError) => {
    const subscriptions = getSubscriptionsManager();
    const ongoingRequests = /* @__PURE__ */ new Set();
    const deferredFollow = deferred();
    let followSubscription = deferredFollow.promise;
    let stopListeningToFollowEvents = noop;
    const unfollowRequest = (subscriptionId) => {
      request(chainHead.unfollow, [subscriptionId]);
    };
    const stopEverything = (sendUnfollow) => {
      stopListeningToFollowEvents();
      if (followSubscription === null) return;
      if (sendUnfollow) {
        if (followSubscription instanceof Promise) {
          followSubscription.then((x) => {
            if (typeof x === "string") unfollowRequest(x);
          });
        } else unfollowRequest(followSubscription);
      }
      followSubscription = null;
      ongoingRequests.forEach((cb) => {
        cb();
      });
      ongoingRequests.clear();
      subscriptions.errorAll(new DisjointError());
    };
    const onAllFollowEventsNext = (event) => {
      if (isOperationEvent(event))
        return subscriptions.next(event.operationId, event);
      switch (event.event) {
        case "stop":
          onFollowError(new StopError());
          return stopEverything(false);
        case "initialized":
        case "newBlock":
        case "bestBlockChanged":
        case "finalized":
          const { event: type, ...rest } = event;
          return onFollowEvent({ type, ...rest });
      }
    };
    const onAllFollowEventsError = (error) => {
      onFollowError(error);
      stopEverything(!(error instanceof DestroyedError));
    };
    request(chainHead.follow, [withRuntime], {
      onSuccess: (subscriptionId, follow) => {
        if (followSubscription instanceof Promise) {
          followSubscription = subscriptionId;
          stopListeningToFollowEvents = follow(subscriptionId, {
            next: onAllFollowEventsNext,
            error: onAllFollowEventsError
          });
        }
        deferredFollow.res(subscriptionId);
      },
      onError: (e) => {
        followSubscription = null;
        deferredFollow.res(e);
        onFollowError(e);
      }
    });
    const fRequest = (method, params, cb) => {
      const disjoint = () => {
        cb?.onError(new DisjointError());
      };
      if (followSubscription === null) {
        disjoint();
        return noop;
      }
      const onSubscription = (subscription) => {
        if (!cb) return request(method, [subscription, ...params]);
        ongoingRequests.add(disjoint);
        const onSubscribeOperation = (operationId, subscriber) => {
          if (followSubscription === null) {
            subscriber.error(new DisjointError());
            return noop;
          }
          subscriptions.subscribe(operationId, subscriber);
          return () => {
            subscriptions.unsubscribe(operationId);
          };
        };
        const cleanup = request(method, [subscription, ...params], {
          onSuccess: (response) => {
            ongoingRequests.delete(disjoint);
            cb.onSuccess(response, onSubscribeOperation);
          },
          onError: (e) => {
            ongoingRequests.delete(disjoint);
            cb.onError(e);
          }
        });
        return () => {
          ongoingRequests.delete(disjoint);
          cleanup();
        };
      };
      if (typeof followSubscription === "string")
        return onSubscription(followSubscription);
      let onCancel = noop;
      followSubscription.then((x) => {
        if (x instanceof Error) return disjoint();
        if (followSubscription) onCancel = onSubscription(x);
      });
      return () => {
        onCancel();
      };
    };
    return {
      unfollow() {
        stopEverything(true);
      },
      body: createBodyFn(fRequest),
      call: createCallFn(fRequest),
      header: createHeaderFn(fRequest),
      storage: createStorageFn(fRequest),
      storageSubscription: createStorageCb(fRequest),
      unpin: createUnpinFn(fRequest),
      _request: fRequest
    };
  };
}

export { getChainHead };
//# sourceMappingURL=chainhead.mjs.map
