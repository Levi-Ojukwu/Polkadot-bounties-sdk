'use strict';

var utils = require('@polkadot-api/utils');
var rawClient = require('@polkadot-api/raw-client');

class StopError extends Error {
  constructor() {
    super("ChainHead stopped");
    this.name = "StopError";
  }
}
class DisjointError extends Error {
  constructor() {
    super("ChainHead disjointed");
    this.name = "DisjointError";
  }
}
class OperationLimitError extends Error {
  constructor() {
    super("ChainHead operations limit reached");
    this.name = "OperationLimitError";
  }
}
class OperationError extends Error {
  constructor(error) {
    super(error);
    this.name = "OperationError";
  }
}
class OperationInaccessibleError extends Error {
  constructor() {
    super("ChainHead operation inaccessible");
    this.name = "OperationInaccessibleError";
  }
}

const abortablePromiseFn = (fn) => (...args) => new Promise((res, rej) => {
  let cancel = utils.noop;
  const [actualArgs, abortSignal] = args[args.length - 1] instanceof AbortSignal ? [args.slice(0, args.length - 1), args[args.length - 1]] : [args];
  const onAbort = () => {
    cancel();
    rej(new utils.AbortError());
  };
  abortSignal?.addEventListener("abort", onAbort, { once: true });
  const withCleanup = (fn2) => (x) => {
    cancel = utils.noop;
    abortSignal?.removeEventListener("abort", onAbort);
    fn2(x);
  };
  cancel = fn(...[withCleanup(res), withCleanup(rej), ...actualArgs]);
});

function deferred() {
  let res = () => {
  };
  let rej = () => {
  };
  const promise = new Promise((_res, _rej) => {
    res = _res;
    rej = _rej;
  });
  return { promise, res, rej };
}

const noop = () => {
};

const chainHead = {
  body: "",
  call: "",
  continue: "",
  follow: "",
  header: "",
  stopOperation: "",
  storage: "",
  unfollow: "",
  unpin: "",
  followEvent: ""
};
const chainSpec = {
  chainName: "",
  genesisHash: "",
  properties: ""
};
const transaction = {
  broadcast: "",
  stop: ""
};
Object.entries({ chainHead, chainSpec, transaction }).forEach(
  ([fnGroupName, methods]) => {
    Object.keys(methods).forEach((methodName) => {
      methods[methodName] = `${fnGroupName}_v1_${methodName}`;
    });
  }
);

const createOperationPromise = (operationName, factory) => (request) => abortablePromiseFn((res, rej, ...args) => {
  let isRunning = true;
  let cancel = () => {
    isRunning = false;
  };
  const [requestArgs, logicCb] = factory(...args);
  request(operationName, requestArgs, {
    onSuccess: (response, followSubscription) => {
      if (response.result === "limitReached")
        return rej(new OperationLimitError());
      const { operationId } = response;
      const stopOperation = () => {
        request(chainHead.stopOperation, [operationId]);
      };
      if (!isRunning) return stopOperation();
      let done = noop;
      const _res = (x) => {
        isRunning = false;
        done();
        res(x);
      };
      const _rej = (x) => {
        isRunning = false;
        done();
        rej(x);
      };
      done = followSubscription(operationId, {
        next: (e) => {
          const _e = e;
          if (_e.event === "operationError")
            rej(new OperationError(_e.error));
          else if (_e.event === "operationInaccessible")
            rej(new OperationInaccessibleError());
          else logicCb(e, _res, _rej);
        },
        error: _rej
      });
      cancel = () => {
        if (isRunning) {
          done();
          stopOperation();
        }
      };
    },
    onError: rej
  });
  return () => {
    cancel();
  };
});

const createBodyFn = createOperationPromise(
  chainHead.body,
  (hash) => [
    [hash],
    (e, res) => {
      res(e.value);
    }
  ]
);

const createCallFn = createOperationPromise(
  chainHead.call,
  (hash, fnName, callParameters) => [
    [hash, fnName, callParameters],
    (e, res) => {
      res(e.output);
    }
  ]
);

const createHeaderFn = (request) => (hash) => new Promise((res, rej) => {
  request(chainHead.header, [hash], {
    onSuccess: res,
    onError: rej
  });
});

const createStorageCb$1 = (request) => (hash, inputs, childTrie, onItems, onError, onDone, onDiscardedItems) => {
  if (inputs.length === 0) {
    onDone();
    return utils.noop;
  }
  let isRunning = true;
  let cancel = () => {
    isRunning = false;
  };
  request(chainHead.storage, [hash, inputs, childTrie], {
    onSuccess: (response, followSubscription) => {
      if (response.result === "limitReached" || response.discardedItems === inputs.length)
        return onError(new OperationLimitError());
      const { operationId } = response;
      const stopOperation = () => {
        request(chainHead.stopOperation, [operationId]);
      };
      if (!isRunning) return stopOperation();
      const doneListening = followSubscription(response.operationId, {
        next: (event) => {
          switch (event.event) {
            case "operationStorageItems": {
              onItems(event.items);
              break;
            }
            case "operationStorageDone": {
              _onDone();
              break;
            }
            case "operationError": {
              _onError(new OperationError(event.error));
              break;
            }
            case "operationInaccessible": {
              _onError(new OperationInaccessibleError());
              break;
            }
            default:
              request(chainHead.continue, [event.operationId]);
          }
        },
        error: onError
      });
      cancel = () => {
        doneListening();
        request(chainHead.stopOperation, [response.operationId]);
      };
      const _onError = (e) => {
        cancel = utils.noop;
        doneListening();
        onError(e);
      };
      const _onDone = () => {
        cancel = utils.noop;
        doneListening();
        onDone();
      };
      onDiscardedItems(response.discardedItems);
    },
    onError
  });
  return () => {
    cancel();
  };
};

const createStorageFn$1 = (request) => {
  const cbStore = createStorageCb$1(request);
  return abortablePromiseFn((resolve, reject, hash, type, key, childTrie) => {
    const isDescendants = type.startsWith("descendants");
    let result = isDescendants ? [] : null;
    const onItems = isDescendants ? (items) => {
      result.push(items);
    } : (items) => {
      result = items[0]?.[type];
    };
    const cancel = cbStore(
      hash,
      [{ key, type }],
      childTrie ?? null,
      onItems,
      reject,
      () => {
        try {
          resolve(isDescendants ? result.flat() : result);
        } catch (e) {
          reject(e);
        }
      },
      (nDiscarded) => {
        if (nDiscarded > 0) {
          cancel();
          reject(new OperationLimitError());
        }
      }
    );
    return cancel;
  });
};

const createUnpinFn = (request) => (hashes) => hashes.length > 0 ? new Promise((res, rej) => {
  request(chainHead.unpin, [hashes], {
    onSuccess() {
      res();
    },
    onError: rej
  });
}) : Promise.resolve();

function isOperationEvent(event) {
  return event.operationId !== void 0;
}
function getChainHead(request) {
  return (withRuntime, onFollowEvent, onFollowError) => {
    const subscriptions = rawClient.getSubscriptionsManager();
    const ongoingRequests = /* @__PURE__ */ new Set();
    const deferredFollow = deferred();
    let followSubscription = deferredFollow.promise;
    let stopListeningToFollowEvents = noop;
    const unfollowRequest = (subscriptionId) => {
      request(chainHead.unfollow, [subscriptionId]);
    };
    const stopEverything = (sendUnfollow) => {
      stopListeningToFollowEvents();
      if (followSubscription === null) return;
      if (sendUnfollow) {
        if (followSubscription instanceof Promise) {
          followSubscription.then((x) => {
            if (typeof x === "string") unfollowRequest(x);
          });
        } else unfollowRequest(followSubscription);
      }
      followSubscription = null;
      ongoingRequests.forEach((cb) => {
        cb();
      });
      ongoingRequests.clear();
      subscriptions.errorAll(new DisjointError());
    };
    const onAllFollowEventsNext = (event) => {
      if (isOperationEvent(event))
        return subscriptions.next(event.operationId, event);
      switch (event.event) {
        case "stop":
          onFollowError(new StopError());
          return stopEverything(false);
        case "initialized":
        case "newBlock":
        case "bestBlockChanged":
        case "finalized":
          const { event: type, ...rest } = event;
          return onFollowEvent({ type, ...rest });
      }
    };
    const onAllFollowEventsError = (error) => {
      onFollowError(error);
      stopEverything(!(error instanceof rawClient.DestroyedError));
    };
    request(chainHead.follow, [withRuntime], {
      onSuccess: (subscriptionId, follow) => {
        if (followSubscription instanceof Promise) {
          followSubscription = subscriptionId;
          stopListeningToFollowEvents = follow(subscriptionId, {
            next: onAllFollowEventsNext,
            error: onAllFollowEventsError
          });
        }
        deferredFollow.res(subscriptionId);
      },
      onError: (e) => {
        followSubscription = null;
        deferredFollow.res(e);
        onFollowError(e);
      }
    });
    const fRequest = (method, params, cb) => {
      const disjoint = () => {
        cb?.onError(new DisjointError());
      };
      if (followSubscription === null) {
        disjoint();
        return noop;
      }
      const onSubscription = (subscription) => {
        if (!cb) return request(method, [subscription, ...params]);
        ongoingRequests.add(disjoint);
        const onSubscribeOperation = (operationId, subscriber) => {
          if (followSubscription === null) {
            subscriber.error(new DisjointError());
            return noop;
          }
          subscriptions.subscribe(operationId, subscriber);
          return () => {
            subscriptions.unsubscribe(operationId);
          };
        };
        const cleanup = request(method, [subscription, ...params], {
          onSuccess: (response) => {
            ongoingRequests.delete(disjoint);
            cb.onSuccess(response, onSubscribeOperation);
          },
          onError: (e) => {
            ongoingRequests.delete(disjoint);
            cb.onError(e);
          }
        });
        return () => {
          ongoingRequests.delete(disjoint);
          cleanup();
        };
      };
      if (typeof followSubscription === "string")
        return onSubscription(followSubscription);
      let onCancel = noop;
      followSubscription.then((x) => {
        if (x instanceof Error) return disjoint();
        if (followSubscription) onCancel = onSubscription(x);
      });
      return () => {
        onCancel();
      };
    };
    return {
      unfollow() {
        stopEverything(true);
      },
      body: createBodyFn(fRequest),
      call: createCallFn(fRequest),
      header: createHeaderFn(fRequest),
      storage: createStorageFn$1(fRequest),
      storageSubscription: createStorageCb$1(fRequest),
      unpin: createUnpinFn(fRequest),
      _request: fRequest
    };
  };
}

class BlockHashNotFoundError extends Error {
  constructor(hash) {
    super(`Invalid BlockHash: ${hash}`);
    this.name = "BlockHashNotFoundError";
  }
}
class StorageError extends Error {
  constructor(message) {
    super(`Storage Error: ${message}`);
    this.name = "StorageError";
  }
}
class CallError extends Error {
  constructor(message) {
    super(`Call Error: ${message}`);
    this.name = "CallError";
  }
}

const createStorageCb = (archiveRequest) => (hash, inputs, childTrie, onItem, onError, onDone) => {
  if (inputs.length === 0) {
    onDone();
    return utils.noop;
  }
  let isRunning = true;
  let cancel = () => {
    isRunning = false;
  };
  archiveRequest("storage", [hash, inputs, childTrie], {
    onSuccess: (operationId, followSubscription) => {
      const stopOperation = () => {
        archiveRequest("stopStorage", [operationId]);
      };
      if (!isRunning) return stopOperation();
      const doneListening = followSubscription(operationId, {
        next: (event) => {
          const { event: type } = event;
          if (type === "storage") {
            const { event: _, ...item } = event;
            onItem(item);
          } else if (type === "storageDone") _onDone();
          else _onError(new StorageError(event.error));
        },
        error: onError
      });
      const tearDown = () => {
        cancel = utils.noop;
        doneListening();
      };
      cancel = () => {
        tearDown();
        stopOperation();
      };
      const _onError = (e) => {
        tearDown();
        onError(e);
      };
      const _onDone = () => {
        tearDown();
        onDone();
      };
    },
    onError
  });
  return () => {
    cancel();
  };
};

const createStorageFn = (cbStore) => abortablePromiseFn((resolve, reject, hash, type, key, childTrie) => {
  const isDescendants = type.startsWith("descendants");
  let result = isDescendants ? [] : null;
  const onItem = isDescendants ? result.push.bind(result) : ({ [type]: res }) => {
    result = res;
  };
  return cbStore(
    hash,
    [{ key, type }],
    childTrie,
    onItem,
    (e) => {
      reject(e);
      result = null;
    },
    () => {
      resolve(result);
      result = null;
    }
  );
});

const identity = () => (x) => x;
const handleInvalidBlockHash = () => (result, hash) => {
  if (result === null) throw new BlockHashNotFoundError(hash);
  return result;
};
const getArchive = (request) => {
  const archiveRequest = (method, ...rest) => request(`archive_v1_${method}`, ...rest);
  const fnCreator = (method) => (mapper) => abortablePromiseFn(
    (res, rej, ...args) => archiveRequest(method, args, {
      onSuccess: (x) => {
        try {
          res(mapper(x, ...args));
        } catch (e) {
          rej(e);
        }
      },
      onError: rej
    })
  );
  const header = fnCreator("header")(
    handleInvalidBlockHash()
  );
  const body = fnCreator("body")(
    handleInvalidBlockHash()
  );
  const storageSubscription = createStorageCb(archiveRequest);
  const storage = createStorageFn(storageSubscription);
  const call = fnCreator("call")((x, hash) => {
    if (!x) throw new BlockHashNotFoundError(hash);
    if (!x.success) throw new CallError(x.error);
    return x.value;
  });
  const finalizedHeight = fnCreator("finalizedHeight")(identity());
  const hashByHeight = fnCreator("hashByHeight")(identity());
  return {
    header,
    body,
    storageSubscription,
    storage,
    call,
    finalizedHeight,
    hashByHeight
  };
};

const getTransaction = (request) => (tx, error) => {
  let isDone = false;
  let cancel = () => {
    isDone = true;
  };
  request(transaction.broadcast, [tx], {
    onSuccess: (subscriptionId) => {
      if (subscriptionId !== null) {
        cancel = () => {
          request(transaction.stop, [subscriptionId]);
          cancel = noop;
        };
        if (isDone) cancel();
      } else if (!isDone) {
        error(new Error("Max # of broadcasted transactions has been reached"));
      }
    },
    onError: error
  });
  return () => {
    cancel();
  };
};

const createGetChainSpec = (clientRequest) => {
  const request = abortablePromiseFn(
    (onSuccess, onError, method, params) => clientRequest(method, params, { onSuccess, onError })
  );
  let cachedPromise = null;
  return async () => {
    if (cachedPromise) return cachedPromise;
    return cachedPromise = Promise.all([
      request(chainSpec.chainName, []),
      request(chainSpec.genesisHash, []),
      request(chainSpec.properties, [])
    ]).then(([name, genesisHash, properties]) => ({
      name,
      genesisHash,
      properties
    }));
  };
};

const createClient = (provider) => {
  const { request, disconnect } = rawClient.createClient(provider);
  return {
    archive: getArchive(request),
    chainHead: getChainHead(request),
    transaction: getTransaction(request),
    getChainSpecData: createGetChainSpec(request),
    destroy: disconnect,
    request: abortablePromiseFn(
      (onSuccess, onError, method, params) => request(method, params, { onSuccess, onError })
    ),
    _request: request
  };
};

Object.defineProperty(exports, "AbortError", {
  enumerable: true,
  get: function () { return utils.AbortError; }
});
Object.defineProperty(exports, "DestroyedError", {
  enumerable: true,
  get: function () { return rawClient.DestroyedError; }
});
Object.defineProperty(exports, "RpcError", {
  enumerable: true,
  get: function () { return rawClient.RpcError; }
});
exports.BlockHashNotFoundError = BlockHashNotFoundError;
exports.CallError = CallError;
exports.DisjointError = DisjointError;
exports.OperationError = OperationError;
exports.OperationInaccessibleError = OperationInaccessibleError;
exports.OperationLimitError = OperationLimitError;
exports.StopError = StopError;
exports.StorageError = StorageError;
exports.createClient = createClient;
//# sourceMappingURL=index.js.map
