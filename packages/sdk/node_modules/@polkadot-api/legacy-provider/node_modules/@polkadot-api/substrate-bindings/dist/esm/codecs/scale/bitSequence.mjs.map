{"version":3,"file":"bitSequence.mjs","sources":["../../../../src/codecs/scale/bitSequence.ts"],"sourcesContent":["import { Bytes, Decoder, Encoder, createCodec, createDecoder } from \"scale-ts\"\nimport { compactNumber } from \"./compact\"\n\nexport interface BitSequence {\n  bitsLen: number\n  bytes: Uint8Array\n}\n\nconst bitSequenceDecoder: Decoder<BitSequence> = createDecoder((data) => {\n  const bitsLen = compactNumber.dec(data)\n\n  const bytesLen = Math.ceil(bitsLen / 8)\n  const bytes = Bytes(bytesLen).dec(data)\n  return { bytes, bitsLen }\n})\n\nconst bitSequenceEncoder: Encoder<BitSequence> = (input) => {\n  if (input.bitsLen > input.bytes.length * 8)\n    throw new Error(\n      `Not enough bytes. (bitsLen:${input.bitsLen}, bytesLen:${input.bytes.length})`,\n    )\n\n  const lenEncoded = compactNumber.enc(input.bitsLen)\n  const result = new Uint8Array(input.bytes.length + lenEncoded.length)\n  result.set(lenEncoded, 0)\n  result.set(input.bytes, lenEncoded.length)\n  return result\n}\n\nexport const bitSequence = createCodec(bitSequenceEncoder, bitSequenceDecoder)\n"],"names":[],"mappings":";;;AAQA,MAAM,kBAAA,GAA2C,aAAA,CAAc,CAAC,IAAA,KAAS;AACvE,EAAA,MAAM,OAAA,GAAU,aAAA,CAAc,GAAA,CAAI,IAAI,CAAA;AAEtC,EAAA,MAAM,QAAA,GAAW,IAAA,CAAK,IAAA,CAAK,OAAA,GAAU,CAAC,CAAA;AACtC,EAAA,MAAM,KAAA,GAAQ,KAAA,CAAM,QAAQ,CAAA,CAAE,IAAI,IAAI,CAAA;AACtC,EAAA,OAAO,EAAE,OAAO,OAAA,EAAQ;AAC1B,CAAC,CAAA;AAED,MAAM,kBAAA,GAA2C,CAAC,KAAA,KAAU;AAC1D,EAAA,IAAI,KAAA,CAAM,OAAA,GAAU,KAAA,CAAM,KAAA,CAAM,MAAA,GAAS,CAAA;AACvC,IAAA,MAAM,IAAI,KAAA;AAAA,MACR,8BAA8B,KAAA,CAAM,OAAO,CAAA,WAAA,EAAc,KAAA,CAAM,MAAM,MAAM,CAAA,CAAA;AAAA,KAC7E;AAEF,EAAA,MAAM,UAAA,GAAa,aAAA,CAAc,GAAA,CAAI,KAAA,CAAM,OAAO,CAAA;AAClD,EAAA,MAAM,SAAS,IAAI,UAAA,CAAW,MAAM,KAAA,CAAM,MAAA,GAAS,WAAW,MAAM,CAAA;AACpE,EAAA,MAAA,CAAO,GAAA,CAAI,YAAY,CAAC,CAAA;AACxB,EAAA,MAAA,CAAO,GAAA,CAAI,KAAA,CAAM,KAAA,EAAO,UAAA,CAAW,MAAM,CAAA;AACzC,EAAA,OAAO,MAAA;AACT,CAAA;AAEO,MAAM,WAAA,GAAc,WAAA,CAAY,kBAAA,EAAoB,kBAAkB;;;;"}