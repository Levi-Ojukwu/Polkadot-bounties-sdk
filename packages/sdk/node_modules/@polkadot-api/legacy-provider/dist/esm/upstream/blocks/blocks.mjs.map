{"version":3,"file":"blocks.mjs","sources":["../../../../src/upstream/blocks/blocks.ts"],"sourcesContent":["import {\n  BestBlockChangedEvent,\n  DecentHeader,\n  InitializedEvent,\n  NewBlockEvent,\n} from \"@/types\"\nimport { UpstreamEvents } from \"./upstream-events\"\nimport {\n  concat,\n  concatMap,\n  filter,\n  map,\n  merge,\n  mergeMap,\n  noop,\n  Observable,\n  of,\n  share,\n  shareReplay,\n  skip,\n  take,\n  takeWhile,\n  tap,\n  toArray,\n  withLatestFrom,\n} from \"rxjs\"\nimport { HexString } from \"@polkadot-api/substrate-bindings\"\n\nexport const getBlocks = ({\n  initial$,\n  allHeads$,\n  finalized$,\n  getHeader$,\n  hasher$,\n  getRecursiveHeader,\n}: UpstreamEvents) => {\n  const finalizedhash$ = finalized$.pipe(map((x) => x.hash))\n  const blocks = new Map<\n    string,\n    DecentHeader & {\n      children: Set<string>\n      usages: Set<string>\n    }\n  >()\n  let prevFin = \"\"\n  let finalized = \"\"\n  let best = \"\"\n  let activeSubscriptions = new Set<string>()\n\n  const getTree = (root: string, result: string[] = []): string[] => {\n    result.push(root)\n    blocks.get(root)!.children.forEach((c) => {\n      getTree(c, result)\n    })\n    return result\n  }\n\n  const getFinalizedEvent = (): {\n    event: \"finalized\"\n    prunedBlockHashes: string[]\n    finalizedBlockHashes: string[]\n  } => {\n    const prunedBlockHashes: string[] = []\n    const finalizedBlockHashes: string[] = []\n\n    let current = blocks.get(finalized)!\n    let prev = blocks.get(current.parent)\n    while (prev) {\n      finalizedBlockHashes.push(current.hash)\n      prev.children.forEach((c) => {\n        if (c !== current.hash) getTree(c, prunedBlockHashes)\n      })\n      current = prev\n      if (current.hash === prevFin) break\n      prev = blocks.get(current.parent)\n    }\n    finalizedBlockHashes.reverse()\n\n    return { event: \"finalized\", prunedBlockHashes, finalizedBlockHashes }\n  }\n\n  const setBestFromFinalized = () => {\n    best = finalized\n    let bestHeight = 0\n    getTree(finalized)\n      .map((x) => blocks.get(x)!)\n      .forEach((x) => {\n        if (x.number > bestHeight) {\n          bestHeight = x.number\n          best = x.hash\n        }\n      })\n  }\n\n  const addBlock = (block: DecentHeader) => {\n    const { hash, parent } = block\n    const me = {\n      ...block,\n      children: new Set<string>(),\n      usages: new Set<string>(),\n    }\n    blocks.set(hash, me)\n    blocks.get(parent)?.children.add(hash)\n    return me\n  }\n\n  const ready$ = initial$.pipe(\n    withLatestFrom(finalizedhash$),\n    map(([initial, fin]) => {\n      initial.forEach(addBlock)\n      finalized = fin\n      setBestFromFinalized()\n      return null\n    }),\n    shareReplay(1),\n  )\n\n  const getNewBlockEvent = (blockHash: string) => {\n    const block = blocks.get(blockHash)!\n    activeSubscriptions.forEach((subId) => {\n      block.usages.add(subId)\n    })\n    return {\n      event: \"newBlock\" as const,\n      blockHash,\n      parentBlockHash: block.parent,\n      newRuntime: block.hasUpgrade\n        ? ({} as {\n            specName: string\n            implName: string\n            specVersion: number\n            implVersion: number\n            transactionVersion: number\n            apis: Record<string, number>\n          })\n        : null,\n    }\n  }\n\n  const tryRemove = (blockHash: string, up?: boolean) => {\n    const block = blocks.get(blockHash)\n    if (!block || block.usages.size > 0) return\n\n    const { parent, children } = block\n    if (up !== true) children.forEach((c) => tryRemove(c, false))\n    if (up !== false) tryRemove(parent, true)\n    if (!blocks.has(parent) || !block.children.size) {\n      blocks.get(parent)?.children.delete(blockHash)\n      blocks.delete(blockHash)\n    }\n  }\n\n  const ignoreUntilReady: <T>(input: Observable<T>) => Observable<T> = filter(\n    () => finalized !== \"\",\n  )\n  const isPresent = (blockHash: string) => blocks.has(blockHash)\n\n  // The initial blocks from `chain_unsubscribeAllHeads` are a royal mess,\n  // you may get a block that's 3 blocks above the currently finalized block,\n  // and a few seconds later receive a block that is 5 blocks above the currently\n  // finalized block that's from a different fork. So, this logic accounts for\n  // these exepctional cases that happen with the initial emissions of `allHeads$`.\n  const allHeadsEvents$ = allHeads$.pipe(\n    ignoreUntilReady,\n    concatMap((newBlock) =>\n      isPresent(newBlock.parent)\n        ? [newBlock]\n        : getRecursiveHeader(newBlock.parent).pipe(\n            takeWhile((x) => !isPresent(x.parent), true),\n            toArray(),\n            mergeMap((blocks) => [...blocks.reverse(), newBlock]),\n          ),\n    ),\n    map((value) => ({ type: \"new\" as const, value })),\n    share(),\n  )\n\n  const finalizedEvents$ = finalizedhash$.pipe(\n    skip(1),\n    ignoreUntilReady,\n    concatMap((blockHash) =>\n      isPresent(blockHash)\n        ? [blockHash]\n        : // it could happen that we are still loading the initial \"new-blocks\"\n          allHeadsEvents$.pipe(\n            map(() => blockHash),\n            filter(isPresent),\n            take(1),\n          ),\n    ),\n    map((value) => ({ type: \"fin\" as const, value })),\n  )\n\n  const updates$ = merge(allHeadsEvents$, finalizedEvents$).pipe(\n    mergeMap((x) => {\n      if (x.type === \"new\") {\n        const block = x.value\n        const { hash } = block\n        addBlock(block)\n        const result: Array<\n          | ReturnType<typeof getNewBlockEvent>\n          | { event: \"bestBlockChanged\"; bestBlockHash: string }\n        > = [getNewBlockEvent(hash)]\n        if (block.number > blocks.get(best)!.number) {\n          best = hash\n          result.push({ event: \"bestBlockChanged\", bestBlockHash: hash })\n        }\n        return result\n      }\n\n      prevFin = finalized\n      finalized = x.value\n      let prevBest = best\n      setBestFromFinalized()\n      const result: Array<\n        | ReturnType<typeof getFinalizedEvent>\n        | { event: \"bestBlockChanged\"; bestBlockHash: string }\n      > = [getFinalizedEvent()]\n\n      if (prevBest !== best)\n        result.unshift({ event: \"bestBlockChanged\", bestBlockHash: best })\n      return result\n    }),\n    share(),\n  )\n\n  const subscription = merge(ready$, updates$).subscribe({\n    error: noop, // the errors are propagated downstream\n  })\n\n  const upstream = (subId: string) => {\n    const getInitialized = () => {\n      const finalizedBlockHashes: string[] = []\n      let current = blocks.get(finalized)\n      while (current && finalizedBlockHashes.length < 10) {\n        finalizedBlockHashes.push(current.hash)\n        current.usages.add(subId)\n        current = blocks.get(current.parent)\n      }\n      finalizedBlockHashes.reverse()\n\n      return {\n        event: \"initialized\" as const,\n        finalizedBlockHashes,\n      }\n    }\n\n    const unpin = (blockHash: string) => {\n      const block = blocks.get(blockHash)\n      if (block) {\n        block.usages.delete(subId)\n        tryRemove(blockHash)\n      }\n    }\n\n    const initialEvents$: Observable<\n      InitializedEvent | NewBlockEvent | BestBlockChangedEvent\n    > = ready$.pipe(\n      mergeMap(() => {\n        const others: Array<NewBlockEvent | BestBlockChangedEvent> = getTree(\n          finalized,\n        )\n          .slice(1)\n          .map(getNewBlockEvent)\n        if (others.length)\n          others.push({\n            event: \"bestBlockChanged\" as const,\n            bestBlockHash: best,\n          })\n        return [getInitialized(), ...others]\n      }),\n    )\n\n    return {\n      blocks$: concat(initialEvents$, updates$).pipe(\n        tap({\n          subscribe: () => {\n            activeSubscriptions.add(subId)\n          },\n          finalize: () => {\n            activeSubscriptions.delete(subId)\n          },\n        }),\n        share(),\n      ),\n      getHeader: (blockHash: string) => blocks.get(blockHash)?.header ?? null,\n      isPinned: (blockHash: string) =>\n        !!blocks.get(blockHash)?.usages.has(subId),\n      unpin,\n    }\n  }\n  upstream.stop = () => {\n    subscription.unsubscribe()\n  }\n  return {\n    upstream,\n    finalized$,\n    getHeader$: (hash: HexString): Observable<DecentHeader> => {\n      const block = blocks.get(hash)\n      return block ? of(block) : getHeader$(hash)\n    },\n    hasher$,\n  }\n}\n"],"names":["blocks","result"],"mappings":"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"}