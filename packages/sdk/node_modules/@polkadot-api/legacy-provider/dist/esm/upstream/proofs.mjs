import { validateProofs } from '@polkadot-api/substrate-bindings';
import { mergeMap } from 'rxjs';

const createClosestDescendantMerkleValue = (obsRequest) => (at, key) => obsRequest("state_getReadProof", [[key], at]).pipe(
  mergeMap((x) => {
    const result = validateProofs(x.proof);
    if (!result) throw new Error("Invalid Proof");
    const { rootHash, proofs } = result;
    let winnerHash = rootHash;
    let current = proofs[winnerHash];
    let nKeyChars = 2;
    do {
      const nextOne = proofs[winnerHash];
      if (!nextOne || nextOne.type === "Raw") break;
      current = nextOne;
      winnerHash = void 0;
      if (!current.partialKey.startsWith(
        key.slice(nKeyChars, nKeyChars + current.partialKey.length)
      ))
        return [];
      nKeyChars += current.partialKey.length;
      if ((current.type === "LeafWithHash" || current.type === "BranchWithHash") && proofs[current.value]) {
        winnerHash = current.value;
        continue;
      }
      if ("children" in current) {
        const winner = Object.entries(
          current.children
        ).find(([, hash]) => proofs[hash]);
        if (winner) {
          if (winner[0] !== key[nKeyChars++]) return [];
          winnerHash = winner[1];
        }
      }
    } while (winnerHash);
    return [current.hash];
  })
);

export { createClosestDescendantMerkleValue };
//# sourceMappingURL=proofs.mjs.map
