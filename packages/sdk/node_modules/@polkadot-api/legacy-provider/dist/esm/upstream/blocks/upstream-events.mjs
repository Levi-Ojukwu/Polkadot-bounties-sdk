import { getFromShittyHeader } from '../../utils/fromShittyHeader.mjs';
import { getHasherFromBlock } from '../../utils/get-hasher-from-block.mjs';
import { withLatestFromBp } from '../../utils/with-latest-from-bp.mjs';
import { noop } from '@polkadot-api/utils';
import { Subject, mergeMap, map, shareReplay, pipe, Observable, share, combineLatest, take, concat, of, toArray, takeUntil } from 'rxjs';

const getUpstreamEvents = (request, request$) => {
  const firstFinHeader$ = new Subject();
  const hasher$ = firstFinHeader$.pipe(
    mergeMap(
      (h) => request$("chain_getBlockHash", [
        h.number
      ]).pipe(map(getHasherFromBlock(h)))
    ),
    shareReplay(1)
  );
  const fromShittyHeader$ = hasher$.pipe(
    map(getFromShittyHeader),
    shareReplay(1)
  );
  const toNiceHeader = pipe(
    withLatestFromBp(fromShittyHeader$),
    map(([fromShittyHeader, shitHeader]) => fromShittyHeader(shitHeader))
  );
  const getHeaders$ = (startMethod, stopMethod, isFin = false) => new Observable((observer) => {
    const onError = (e) => {
      observer.error(e);
    };
    let stop = null;
    let isFirstFin = isFin;
    request(startMethod, [], {
      onSuccess: (subId, followSub) => {
        const done = followSub(subId, {
          next: (v) => {
            if (isFirstFin) {
              isFirstFin = false;
              firstFinHeader$.next(v);
              firstFinHeader$.complete();
            }
            observer.next(v);
          },
          error: onError
        });
        const unsubscribe = () => {
          done();
          try {
            request(stopMethod, [subId], {
              onError: noop,
              onSuccess: noop
            });
          } catch {
          }
        };
        if (stop !== null) unsubscribe();
        else stop = unsubscribe;
      },
      onError
    });
    return () => {
      stop?.();
      stop = noop;
    };
  }).pipe(toNiceHeader);
  const allHeads$ = getHeaders$(
    "chain_subscribeAllHeads",
    "chain_unsubscribeAllHeads"
  ).pipe(share());
  const finalized$ = getHeaders$(
    "chain_subscribeFinalizedHeads",
    "chain_unsubscribeFinalizedHeads",
    true
  ).pipe(shareReplay(1));
  const getHeader$ = (hash) => request$("chain_getHeader", [hash]).pipe(
    toNiceHeader
  );
  const getRecursiveHeader = (hash) => getHeader$(hash).pipe(
    mergeMap(
      (header) => concat(of(header), getRecursiveHeader(header.parent))
    )
  );
  const gap$ = combineLatest([
    allHeads$.pipe(take(1)),
    finalized$.pipe(take(1))
  ]).pipe(
    mergeMap(([latest, fin]) => {
      const nMissing = latest.number - fin.number - 1;
      return concat(
        getRecursiveHeader(latest.parent).pipe(take(Math.max(0, nMissing))),
        of(fin)
      );
    }),
    toArray(),
    share()
  );
  const collected$ = allHeads$.pipe(takeUntil(gap$), toArray());
  const initial$ = combineLatest([collected$, gap$]).pipe(
    map(([collected, gap]) => [...gap.reverse(), ...collected])
  );
  return {
    initial$,
    allHeads$,
    finalized$,
    hasher$,
    getRecursiveHeader,
    getHeader$
  };
};

export { getUpstreamEvents };
//# sourceMappingURL=upstream-events.mjs.map
