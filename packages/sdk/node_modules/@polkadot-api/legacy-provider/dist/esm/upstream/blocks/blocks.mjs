import { map, withLatestFrom, shareReplay, filter, concatMap, takeWhile, toArray, mergeMap, share, skip, take, merge, noop, of, concat, tap } from 'rxjs';

const getBlocks = ({
  initial$,
  allHeads$,
  finalized$,
  getHeader$,
  hasher$,
  getRecursiveHeader
}) => {
  const finalizedhash$ = finalized$.pipe(map((x) => x.hash));
  const blocks = /* @__PURE__ */ new Map();
  let prevFin = "";
  let finalized = "";
  let best = "";
  let activeSubscriptions = /* @__PURE__ */ new Set();
  const getTree = (root, result = []) => {
    result.push(root);
    blocks.get(root).children.forEach((c) => {
      getTree(c, result);
    });
    return result;
  };
  const getFinalizedEvent = () => {
    const prunedBlockHashes = [];
    const finalizedBlockHashes = [];
    let current = blocks.get(finalized);
    let prev = blocks.get(current.parent);
    while (prev) {
      finalizedBlockHashes.push(current.hash);
      prev.children.forEach((c) => {
        if (c !== current.hash) getTree(c, prunedBlockHashes);
      });
      current = prev;
      if (current.hash === prevFin) break;
      prev = blocks.get(current.parent);
    }
    finalizedBlockHashes.reverse();
    return { event: "finalized", prunedBlockHashes, finalizedBlockHashes };
  };
  const setBestFromFinalized = () => {
    best = finalized;
    let bestHeight = 0;
    getTree(finalized).map((x) => blocks.get(x)).forEach((x) => {
      if (x.number > bestHeight) {
        bestHeight = x.number;
        best = x.hash;
      }
    });
  };
  const addBlock = (block) => {
    const { hash, parent } = block;
    const me = {
      ...block,
      children: /* @__PURE__ */ new Set(),
      usages: /* @__PURE__ */ new Set()
    };
    blocks.set(hash, me);
    blocks.get(parent)?.children.add(hash);
    return me;
  };
  const ready$ = initial$.pipe(
    withLatestFrom(finalizedhash$),
    map(([initial, fin]) => {
      initial.forEach(addBlock);
      finalized = fin;
      setBestFromFinalized();
      return null;
    }),
    shareReplay(1)
  );
  const getNewBlockEvent = (blockHash) => {
    const block = blocks.get(blockHash);
    activeSubscriptions.forEach((subId) => {
      block.usages.add(subId);
    });
    return {
      event: "newBlock",
      blockHash,
      parentBlockHash: block.parent,
      newRuntime: block.hasUpgrade ? {} : null
    };
  };
  const tryRemove = (blockHash, up) => {
    const block = blocks.get(blockHash);
    if (!block || block.usages.size > 0) return;
    const { parent, children } = block;
    if (up !== true) children.forEach((c) => tryRemove(c, false));
    if (up !== false) tryRemove(parent, true);
    if (!blocks.has(parent) || !block.children.size) {
      blocks.get(parent)?.children.delete(blockHash);
      blocks.delete(blockHash);
    }
  };
  const ignoreUntilReady = filter(
    () => finalized !== ""
  );
  const isPresent = (blockHash) => blocks.has(blockHash);
  const allHeadsEvents$ = allHeads$.pipe(
    ignoreUntilReady,
    concatMap(
      (newBlock) => isPresent(newBlock.parent) ? [newBlock] : getRecursiveHeader(newBlock.parent).pipe(
        takeWhile((x) => !isPresent(x.parent), true),
        toArray(),
        mergeMap((blocks2) => [...blocks2.reverse(), newBlock])
      )
    ),
    map((value) => ({ type: "new", value })),
    share()
  );
  const finalizedEvents$ = finalizedhash$.pipe(
    skip(1),
    ignoreUntilReady,
    concatMap(
      (blockHash) => isPresent(blockHash) ? [blockHash] : (
        // it could happen that we are still loading the initial "new-blocks"
        allHeadsEvents$.pipe(
          map(() => blockHash),
          filter(isPresent),
          take(1)
        )
      )
    ),
    map((value) => ({ type: "fin", value }))
  );
  const updates$ = merge(allHeadsEvents$, finalizedEvents$).pipe(
    mergeMap((x) => {
      if (x.type === "new") {
        const block = x.value;
        const { hash } = block;
        addBlock(block);
        const result2 = [getNewBlockEvent(hash)];
        if (block.number > blocks.get(best).number) {
          best = hash;
          result2.push({ event: "bestBlockChanged", bestBlockHash: hash });
        }
        return result2;
      }
      prevFin = finalized;
      finalized = x.value;
      let prevBest = best;
      setBestFromFinalized();
      const result = [getFinalizedEvent()];
      if (prevBest !== best)
        result.unshift({ event: "bestBlockChanged", bestBlockHash: best });
      return result;
    }),
    share()
  );
  const subscription = merge(ready$, updates$).subscribe({
    error: noop
    // the errors are propagated downstream
  });
  const upstream = (subId) => {
    const getInitialized = () => {
      const finalizedBlockHashes = [];
      let current = blocks.get(finalized);
      while (current && finalizedBlockHashes.length < 10) {
        finalizedBlockHashes.push(current.hash);
        current.usages.add(subId);
        current = blocks.get(current.parent);
      }
      finalizedBlockHashes.reverse();
      return {
        event: "initialized",
        finalizedBlockHashes
      };
    };
    const unpin = (blockHash) => {
      const block = blocks.get(blockHash);
      if (block) {
        block.usages.delete(subId);
        tryRemove(blockHash);
      }
    };
    const initialEvents$ = ready$.pipe(
      mergeMap(() => {
        const others = getTree(
          finalized
        ).slice(1).map(getNewBlockEvent);
        if (others.length)
          others.push({
            event: "bestBlockChanged",
            bestBlockHash: best
          });
        return [getInitialized(), ...others];
      })
    );
    return {
      blocks$: concat(initialEvents$, updates$).pipe(
        tap({
          subscribe: () => {
            activeSubscriptions.add(subId);
          },
          finalize: () => {
            activeSubscriptions.delete(subId);
          }
        }),
        share()
      ),
      getHeader: (blockHash) => blocks.get(blockHash)?.header ?? null,
      isPinned: (blockHash) => !!blocks.get(blockHash)?.usages.has(subId),
      unpin
    };
  };
  upstream.stop = () => {
    subscription.unsubscribe();
  };
  return {
    upstream,
    finalized$,
    getHeader$: (hash) => {
      const block = blocks.get(hash);
      return block ? of(block) : getHeader$(hash);
    },
    hasher$
  };
};

export { getBlocks };
//# sourceMappingURL=blocks.mjs.map
