{"version":3,"file":"proofs.mjs","sources":["../../../src/upstream/proofs.ts"],"sourcesContent":["import {\n  HexString,\n  ProofTrieNode,\n  TrieNode,\n  validateProofs,\n} from \"@polkadot-api/substrate-bindings\"\nimport { mergeMap, Observable } from \"rxjs\"\n\nexport const createClosestDescendantMerkleValue =\n  (\n    obsRequest: <Args extends Array<any>, Payload>(\n      method: string,\n      params: Args,\n    ) => Observable<Payload>,\n  ) =>\n  (at: HexString, key: HexString) =>\n    obsRequest<\n      [keys: Array<HexString>, at: HexString],\n      {\n        at: HexString\n        proof: HexString[]\n      }\n    >(\"state_getReadProof\", [[key], at]).pipe(\n      mergeMap((x) => {\n        const result = validateProofs(x.proof)\n        if (!result) throw new Error(\"Invalid Proof\")\n        const { rootHash, proofs } = result\n        let winnerHash: HexString | undefined = rootHash\n        let current: {\n          hash: HexString\n          parent?: HexString\n        } & TrieNode = proofs[winnerHash!] as any\n\n        let nKeyChars = 2 // skipping `0x`\n        do {\n          const nextOne: ProofTrieNode = proofs[winnerHash!]\n          if (!nextOne || nextOne.type === \"Raw\") break\n\n          current = nextOne\n          winnerHash = undefined\n          if (\n            !current.partialKey.startsWith(\n              key.slice(nKeyChars, nKeyChars + current.partialKey.length),\n            )\n          )\n            // This causes the observable to complete, which in its turn triggers an [`operationStorageDone`](https://paritytech.github.io/json-rpc-interface-spec/api/chainHead_v1_follow.html#operationstoragedone)\n            // event, without triggering the intermediary `OperationStorageItems` event. This is the expected behaviour when querying a non-existing storage entry.\n            return []\n          nKeyChars += current.partialKey.length\n          if (\n            (current.type === \"LeafWithHash\" ||\n              current.type === \"BranchWithHash\") &&\n            proofs[current.value]\n          ) {\n            winnerHash = current.value\n            continue\n          }\n\n          if (\"children\" in current) {\n            const winner: [string, string] | undefined = Object.entries(\n              current.children,\n            ).find(([, hash]) => proofs[hash])\n\n            if (winner) {\n              // Same as before: in this case we know that it won't match with the requested key, so we complete without an emission.\n              if (winner[0] !== key[nKeyChars++]) return []\n              winnerHash = winner[1]\n            }\n          }\n        } while (winnerHash)\n\n        return [current!.hash]\n      }),\n    )\n"],"names":[],"mappings":";;;AAQO,MAAM,kCAAA,GACX,CACE,UAAA,KAKF,CAAC,IAAe,GAAA,KACd,UAAA,CAME,oBAAA,EAAsB,CAAC,CAAC,GAAG,CAAA,EAAG,EAAE,CAAC,CAAA,CAAE,IAAA;AAAA,EACnC,QAAA,CAAS,CAAC,CAAA,KAAM;AACd,IAAA,MAAM,MAAA,GAAS,cAAA,CAAe,CAAA,CAAE,KAAK,CAAA;AACrC,IAAA,IAAI,CAAC,MAAA,EAAQ,MAAM,IAAI,MAAM,eAAe,CAAA;AAC5C,IAAA,MAAM,EAAE,QAAA,EAAU,MAAA,EAAO,GAAI,MAAA;AAC7B,IAAA,IAAI,UAAA,GAAoC,QAAA;AACxC,IAAA,IAAI,OAAA,GAGW,OAAO,UAAW,CAAA;AAEjC,IAAA,IAAI,SAAA,GAAY,CAAA;AAChB,IAAA,GAAG;AACD,MAAA,MAAM,OAAA,GAAyB,OAAO,UAAW,CAAA;AACjD,MAAA,IAAI,CAAC,OAAA,IAAW,OAAA,CAAQ,IAAA,KAAS,KAAA,EAAO;AAExC,MAAA,OAAA,GAAU,OAAA;AACV,MAAA,UAAA,GAAa,MAAA;AACb,MAAA,IACE,CAAC,QAAQ,UAAA,CAAW,UAAA;AAAA,QAClB,IAAI,KAAA,CAAM,SAAA,EAAW,SAAA,GAAY,OAAA,CAAQ,WAAW,MAAM;AAAA,OAC5D;AAIA,QAAA,OAAO,EAAC;AACV,MAAA,SAAA,IAAa,QAAQ,UAAA,CAAW,MAAA;AAChC,MAAA,IAAA,CACG,OAAA,CAAQ,SAAS,cAAA,IAChB,OAAA,CAAQ,SAAS,gBAAA,KACnB,MAAA,CAAO,OAAA,CAAQ,KAAK,CAAA,EACpB;AACA,QAAA,UAAA,GAAa,OAAA,CAAQ,KAAA;AACrB,QAAA;AAAA,MACF;AAEA,MAAA,IAAI,cAAc,OAAA,EAAS;AACzB,QAAA,MAAM,SAAuC,MAAA,CAAO,OAAA;AAAA,UAClD,OAAA,CAAQ;AAAA,SACV,CAAE,KAAK,CAAC,GAAG,IAAI,CAAA,KAAM,MAAA,CAAO,IAAI,CAAC,CAAA;AAEjC,QAAA,IAAI,MAAA,EAAQ;AAEV,UAAA,IAAI,OAAO,CAAC,CAAA,KAAM,IAAI,SAAA,EAAW,CAAA,SAAU,EAAC;AAC5C,UAAA,UAAA,GAAa,OAAO,CAAC,CAAA;AAAA,QACvB;AAAA,MACF;AAAA,IACF,CAAA,QAAS,UAAA;AAET,IAAA,OAAO,CAAC,QAAS,IAAI,CAAA;AAAA,EACvB,CAAC;AACH;;;;"}