{"version":3,"file":"storage.mjs","sources":["../../../src/downstream/storage.ts"],"sourcesContent":["import { createUpstream } from \"@/upstream/upstream\"\nimport { filter, map, merge } from \"rxjs\"\n\nconst validStorageTypes = new Set([\n  \"value\",\n  \"hash\",\n  \"closestDescendantMerkleValue\",\n  \"descendantsValues\",\n  \"descendantsHashes\",\n])\n\nexport type Items = Array<{\n  key: string\n  type:\n    | \"value\"\n    | \"hash\"\n    | \"closestDescendantMerkleValue\"\n    | \"descendantsValues\"\n    | \"descendantsHashes\"\n}>\n\nexport const areItemsValid = (items: any): items is Items =>\n  Array.isArray(items) &&\n  items.every(\n    (x) =>\n      typeof x === \"object\" &&\n      typeof x.key === \"string\" &&\n      validStorageTypes.has(x.type),\n  )\n\nexport const getStg$ = (\n  upstream: ReturnType<typeof createUpstream>,\n  at: string,\n  items: Array<{\n    key: string\n    type:\n      | \"value\"\n      | \"hash\"\n      | \"descendantsValues\"\n      | \"descendantsHashes\"\n      | \"closestDescendantMerkleValue\"\n  }>,\n) =>\n  merge(\n    ...items.map(({ key, type }) => {\n      switch (type) {\n        case \"value\":\n          return upstream.stgValue(at, key).pipe(\n            filter(Boolean),\n            map((value) => [\n              {\n                key,\n                value,\n              },\n            ]),\n          )\n        case \"hash\":\n          return upstream.stgHash(at, key).pipe(\n            filter(Boolean),\n            map((hash) => [\n              {\n                key,\n                hash,\n              },\n            ]),\n          )\n        case \"descendantsValues\":\n          return upstream\n            .stgDescendantValues(at, key)\n            .pipe(\n              map((values) => values.map(([key, value]) => ({ key, value }))),\n            )\n\n        case \"descendantsHashes\":\n          return upstream\n            .stgDescendantHashes(at, key)\n            .pipe(map((values) => values.map(([key, hash]) => ({ key, hash }))))\n\n        case \"closestDescendantMerkleValue\":\n          return upstream.stgClosestDescendant(at, key).pipe(\n            filter(Boolean),\n            map((closestDescendantMerkleValue) => [\n              {\n                key,\n                closestDescendantMerkleValue,\n              },\n            ]),\n          )\n      }\n    }),\n  )\n"],"names":["key"],"mappings":";;AAGA,MAAM,iBAAA,uBAAwB,GAAA,CAAI;AAAA,EAChC,OAAA;AAAA,EACA,MAAA;AAAA,EACA,8BAAA;AAAA,EACA,mBAAA;AAAA,EACA;AACF,CAAC,CAAA;AAYM,MAAM,gBAAgB,CAAC,KAAA,KAC5B,MAAM,OAAA,CAAQ,KAAK,KACnB,KAAA,CAAM,KAAA;AAAA,EACJ,CAAC,CAAA,KACC,OAAO,CAAA,KAAM,QAAA,IACb,OAAO,CAAA,CAAE,GAAA,KAAQ,QAAA,IACjB,iBAAA,CAAkB,GAAA,CAAI,CAAA,CAAE,IAAI;AAChC;AAEK,MAAM,OAAA,GAAU,CACrB,QAAA,EACA,EAAA,EACA,KAAA,KAUA,KAAA;AAAA,EACE,GAAG,KAAA,CAAM,GAAA,CAAI,CAAC,EAAE,GAAA,EAAK,MAAK,KAAM;AAC9B,IAAA,QAAQ,IAAA;AAAM,MACZ,KAAK,OAAA;AACH,QAAA,OAAO,QAAA,CAAS,QAAA,CAAS,EAAA,EAAI,GAAG,CAAA,CAAE,IAAA;AAAA,UAChC,OAAO,OAAO,CAAA;AAAA,UACd,GAAA,CAAI,CAAC,KAAA,KAAU;AAAA,YACb;AAAA,cACE,GAAA;AAAA,cACA;AAAA;AACF,WACD;AAAA,SACH;AAAA,MACF,KAAK,MAAA;AACH,QAAA,OAAO,QAAA,CAAS,OAAA,CAAQ,EAAA,EAAI,GAAG,CAAA,CAAE,IAAA;AAAA,UAC/B,OAAO,OAAO,CAAA;AAAA,UACd,GAAA,CAAI,CAAC,IAAA,KAAS;AAAA,YACZ;AAAA,cACE,GAAA;AAAA,cACA;AAAA;AACF,WACD;AAAA,SACH;AAAA,MACF,KAAK,mBAAA;AACH,QAAA,OAAO,QAAA,CACJ,mBAAA,CAAoB,EAAA,EAAI,GAAG,CAAA,CAC3B,IAAA;AAAA,UACC,GAAA,CAAI,CAAC,MAAA,KAAW,MAAA,CAAO,IAAI,CAAC,CAACA,IAAAA,EAAK,KAAK,OAAO,EAAE,GAAA,EAAAA,IAAAA,EAAK,KAAA,GAAQ,CAAC;AAAA,SAChE;AAAA,MAEJ,KAAK,mBAAA;AACH,QAAA,OAAO,QAAA,CACJ,oBAAoB,EAAA,EAAI,GAAG,EAC3B,IAAA,CAAK,GAAA,CAAI,CAAC,MAAA,KAAW,MAAA,CAAO,GAAA,CAAI,CAAC,CAACA,IAAAA,EAAK,IAAI,CAAA,MAAO,EAAE,KAAAA,IAAAA,EAAK,IAAA,EAAK,CAAE,CAAC,CAAC,CAAA;AAAA,MAEvE,KAAK,8BAAA;AACH,QAAA,OAAO,QAAA,CAAS,oBAAA,CAAqB,EAAA,EAAI,GAAG,CAAA,CAAE,IAAA;AAAA,UAC5C,OAAO,OAAO,CAAA;AAAA,UACd,GAAA,CAAI,CAAC,4BAAA,KAAiC;AAAA,YACpC;AAAA,cACE,GAAA;AAAA,cACA;AAAA;AACF,WACD;AAAA,SACH;AAAA;AACJ,EACF,CAAC;AACH;;;;"}