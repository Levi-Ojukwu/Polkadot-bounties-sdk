import { DisjointError } from '@polkadot-api/substrate-client';
import { Subject, filter, distinctUntilChanged, scan, mergeAll, map, switchMap, Observable, take, mergeMap, shareReplay, merge, takeWhile, share, ReplaySubject, tap, identity, noop, EMPTY, endWith, defer, of } from 'rxjs';
import { getWithRecovery } from './enhancers/operationLimitRecovery.mjs';
import { getWithOptionalHash$ } from './enhancers/optionalHash.mjs';
import { fromAbortControllerFn } from './enhancers/fromAbortControllerFn.mjs';
import { withLazyFollower } from './enhancers/lazyFollower.mjs';
import { withStopRecovery } from './enhancers/withStopRecovery.mjs';
import { withOperationInaccessibleRetry } from './enhancers/operation-inaccessible-retry.mjs';
import { BlockNotPinnedError } from './errors.mjs';
import { getRecoveralStorage$ } from './storage-queries.mjs';
import { getFollow$ } from './streams/follow.mjs';
import '@polkadot-api/substrate-bindings';
import { getPinnedBlocks$, toBlockInfo } from './streams/pinned-blocks.mjs';
import { getTrackTx } from './track-tx.mjs';
import { getValidateTx } from './validate-tx.mjs';
import { withDefaultValue } from '../utils/with-default-value.mjs';
import { delayUnsubscription } from '../utils/delay-unsubscription.mjs';
import { concatMapEager } from '../utils/concatMapEager.mjs';
import { shareLatest } from '../utils/shareLatest.mjs';

const getChainHead$ = (chainHead, getCachedMetadata, setCachedMetadata) => {
  const { getFollower, unfollow, follow$, getHeader, hasher$ } = getFollow$(chainHead);
  const lazyFollower = withLazyFollower(getFollower);
  const { withRecovery, withRecoveryFn } = getWithRecovery();
  const blockUsage$ = new Subject();
  const usingBlock = (hash) => (base) => new Observable((observer) => {
    blockUsage$.next({ type: "blockUsage", value: { type: "hold", hash } });
    const subscription = base.subscribe(observer);
    subscription.add(() => {
      setTimeout(() => {
        blockUsage$.next({
          type: "blockUsage",
          value: { type: "release", hash }
        });
      }, 0);
    });
    return subscription;
  });
  const withRefcount = (fn) => (hash, ...args) => fn(hash, ...args).pipe(usingBlock(hash));
  const withInMemory = (fn, label) => (hash, ...args) => new Observable(
    (observer) => pinnedBlocks$.state.blocks.has(hash) ? fn(hash, ...args).subscribe(observer) : observer.error(new BlockNotPinnedError(hash, label))
  );
  const unpin = (hashes) => getFollower().unpin(hashes).catch((e) => {
    if (e instanceof DisjointError) return;
    throw e;
  });
  const commonEnhancer = (fn, label) => withInMemory(
    withRefcount(
      withStopRecovery(
        pinnedBlocks$,
        withRecoveryFn(fromAbortControllerFn(fn)),
        `stop-${label}`
      )
    ),
    label
  );
  const cache = /* @__PURE__ */ new Map();
  const stg = withRefcount(
    withRecoveryFn(fromAbortControllerFn(lazyFollower("storage")))
  );
  const getCodeHash = (blockHash) => (
    // ":code" => "0x3a636f6465"
    stg(blockHash, "hash", "0x3a636f6465", null).pipe(map((x) => x))
  );
  const newBlocks$ = new Subject();
  const pinnedBlocks$ = getPinnedBlocks$(
    follow$,
    withRefcount(withRecoveryFn(fromAbortControllerFn(lazyFollower("call")))),
    getCodeHash,
    getCachedMetadata,
    setCachedMetadata,
    blockUsage$,
    newBlocks$,
    (blocks) => {
      unpin(blocks).catch((err) => {
        console.error("unpin", err);
      });
      blocks.forEach((hash) => {
        cache.delete(hash);
      });
    },
    (block) => {
      cache.delete(block);
    }
  );
  const getRuntimeContext$ = withInMemory(
    withRefcount(
      (hash) => pinnedBlocks$.state.runtimes[pinnedBlocks$.state.blocks.get(hash).runtime].runtime
    ),
    "getRuntimeCtx"
  );
  const withRuntime = (mapper) => (source$) => source$.pipe(
    concatMapEager(
      (x) => getRuntimeContext$(mapper(x)).pipe(map((runtime) => [x, runtime]))
    )
  );
  const upsertCachedStream = (hash, key, stream) => {
    const hashCache = cache.get(hash) ?? /* @__PURE__ */ new Map();
    const cached = hashCache.get(key);
    if (cached) return cached;
    cache.set(hash, hashCache);
    let connector;
    const result = stream.pipe(
      share({
        connector: () => connector = new ReplaySubject()
      }),
      tap({
        complete() {
          hashCache.set(key, connector);
        }
      }),
      delayUnsubscription()
    );
    hashCache.set(key, result);
    return result;
  };
  const finalized$ = pinnedBlocks$.pipe(
    filter((x) => !x.recovering),
    distinctUntilChanged((a, b) => a.finalized === b.finalized),
    scan((acc, value) => {
      let current = value.blocks.get(value.finalized);
      const result = [current];
      const latest = acc.at(-1);
      if (!latest) return result;
      while (current.number > latest.number + 1) {
        current = value.blocks.get(current.parent);
        if (!current) break;
        result.unshift(current);
      }
      return result;
    }, []),
    mergeAll(),
    map(toBlockInfo),
    shareLatest
  );
  const best$ = pinnedBlocks$.pipe(
    distinctUntilChanged((a, b) => a.best === b.best),
    map((pinned) => toBlockInfo(pinned.blocks.get(pinned.best))),
    shareLatest
  );
  const bestBlocks$ = pinnedBlocks$.pipe(
    filter((x) => !x.recovering),
    distinctUntilChanged(
      (prev, current) => prev.finalized === current.finalized && prev.best === current.best
    ),
    scan((acc, pinned) => {
      const getBlockInfo = (hash) => acc.get(hash) || toBlockInfo(pinned.blocks.get(hash));
      const best = getBlockInfo(pinned.best);
      const finalized = getBlockInfo(pinned.finalized);
      const len = best.number - finalized.number + 1;
      const result = new Array(len);
      for (let i = 0, hash = best.hash; i < len; i++) {
        result[i] = getBlockInfo(hash);
        hash = result[i].parent;
      }
      return new Map(result.map((b) => [b.hash, b]));
    }, /* @__PURE__ */ new Map()),
    map((x) => [...x.values()]),
    shareLatest
  );
  const runtime$ = pinnedBlocks$.pipe(
    distinctUntilChanged((a, b) => a.finalizedRuntime === b.finalizedRuntime),
    switchMap(
      ({ finalizedRuntime: { runtime } }) => runtime.pipe(withDefaultValue(null))
    ),
    shareLatest
  );
  const metadata$ = runtime$.pipe(map((x) => x?.lookup.metadata ?? null));
  const withOptionalHash$ = getWithOptionalHash$(
    finalized$.pipe(map((b) => b.hash)),
    best$.pipe(map((b) => b.hash)),
    usingBlock
  );
  const _body$ = commonEnhancer(lazyFollower("body"), "body");
  const body$ = (hash) => withOperationInaccessibleRetry(
    upsertCachedStream(hash, "body", _body$(hash))
  );
  const _storage$ = commonEnhancer(lazyFollower("storage"), "storage");
  const storage$ = withOptionalHash$(
    withInMemory(
      (hash, type, keyMapper, childTrie = null, mapper) => pinnedBlocks$.state.runtimes[pinnedBlocks$.state.blocks.get(hash).runtime].runtime.pipe(
        mergeMap((ctx) => {
          const key = keyMapper(ctx);
          return upsertCachedStream(
            hash,
            `storage-${type}-${key}-${childTrie ?? ""}`,
            _storage$(hash, type, key, childTrie)
          ).pipe(mapper ? map((raw) => mapper(raw, ctx)) : identity);
        })
      ),
      "storage"
    )
  );
  const recoveralStorage$ = getRecoveralStorage$(getFollower, withRecovery);
  const storageQueries$ = withOptionalHash$(
    withInMemory(
      withStopRecovery(
        pinnedBlocks$,
        (hash, queries, childTrie) => recoveralStorage$(hash, queries, childTrie ?? null, false),
        `storageQueries`
      ),
      "storageQueries"
    )
  );
  const header$ = withOptionalHash$(
    withInMemory(
      withStopRecovery(
        pinnedBlocks$,
        (hash) => defer(() => getHeader(hash)),
        "header"
      ),
      "header"
    )
  );
  const eventsAt$ = (hash) => storage$(
    hash,
    "value",
    (ctx) => ctx.events.key,
    null,
    (x, ctx) => ctx.events.dec(x)
  );
  const __call$ = commonEnhancer(lazyFollower("call"), "call");
  const call$ = withOptionalHash$(
    (hash, fn, args) => upsertCachedStream(hash, `call-${fn}-${args}`, __call$(hash, fn, args))
  );
  const validateTx$ = getValidateTx(call$, getRuntimeContext$);
  const innerBody$ = (hash) => upsertCachedStream(hash, "body", _body$(hash));
  const trackTx$ = getTrackTx(pinnedBlocks$, innerBody$, validateTx$, eventsAt$);
  const trackTxWithoutEvents$ = getTrackTx(
    pinnedBlocks$,
    innerBody$,
    validateTx$,
    () => of()
  );
  const genesis$ = runtime$.pipe(
    filter(Boolean),
    take(1),
    mergeMap((runtime) => {
      const { enc } = runtime.dynamicBuilder.buildStorage(
        "System",
        "BlockHash"
      ).keys;
      let key;
      try {
        key = enc(0);
      } catch {
        key = enc(0n);
      }
      return storage$(null, "value", () => key, null);
    }),
    shareReplay(1)
  );
  merge(runtime$, bestBlocks$).subscribe({
    error() {
    }
  });
  const getRuntime$ = (codeHash) => merge(
    ...Object.values(pinnedBlocks$.state.runtimes).map(
      (runtime) => runtime.codeHash$.pipe(
        mergeMap(
          (_codehash) => codeHash === _codehash ? runtime.runtime : EMPTY
        )
      )
    )
  ).pipe(endWith(null), take(1));
  const holdBlock = (blockHash, shouldThrow = false) => {
    let hash = blockHash || "finalized";
    hash = pinnedBlocks$.state[hash] || hash;
    if (!pinnedBlocks$.state.blocks.has(hash)) {
      if (shouldThrow) throw new BlockNotPinnedError(hash, "holdBlock");
      return noop;
    }
    blockUsage$.next({
      type: "blockUsage",
      value: {
        type: "hold",
        hash
      }
    });
    let tearDown = () => {
      blockUsage$.next({
        type: "blockUsage",
        value: {
          type: "release",
          hash
        }
      });
      tearDown = noop;
    };
    return () => {
      tearDown();
    };
  };
  const withHodl = (blockHash) => (base) => new Observable((observer) => {
    const subscription = base.subscribe(observer);
    if (!subscription.closed) subscription.add(holdBlock(blockHash));
    return subscription;
  });
  return {
    follow$,
    unfollow,
    finalized$,
    best$,
    bestBlocks$,
    newBlocks$: newBlocks$.pipe(takeWhile(Boolean)),
    runtime$,
    metadata$,
    genesis$,
    hasher$,
    getRuntime$,
    header$,
    body$,
    call$,
    storage$,
    storageQueries$,
    eventsAt$,
    withHodl,
    holdBlock,
    trackTx$,
    trackTxWithoutEvents$,
    validateTx$,
    pinnedBlocks$,
    withRuntime,
    getRuntimeContext$: withOptionalHash$(getRuntimeContext$)
  };
};

export { getChainHead$ };
//# sourceMappingURL=chainHead.mjs.map
