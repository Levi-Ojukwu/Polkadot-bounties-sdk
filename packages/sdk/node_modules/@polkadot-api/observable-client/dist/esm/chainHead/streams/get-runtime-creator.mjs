import { unifyMetadata, metadata } from '@polkadot-api/substrate-bindings';
import { shareReplay, map, mergeMap, catchError, of, tap, EMPTY, timer } from 'rxjs';
import { BlockNotPinnedError } from '../errors.mjs';
import { OperationInaccessibleError } from '@polkadot-api/substrate-client';
import { getRawMetadata$ } from '../../utils/get-raw-metadta.mjs';
import { createRuntimeCtx } from '../../utils/create-metadata-ctx.mjs';

const withRecovery = (getHash) => (fn) => {
  const result = (...args) => {
    const hash = getHash();
    return hash ? fn(hash, ...args).pipe(
      catchError((e) => {
        if (e instanceof BlockNotPinnedError) return result(...args);
        if (e instanceof OperationInaccessibleError)
          return timer(750).pipe(mergeMap(() => result(...args)));
        throw e;
      })
    ) : EMPTY;
  };
  return result;
};
const getRuntimeCreator = (call$, getCodeHash$, getCachedMetadata, setCachedMetadata) => {
  const getMetadata$ = (codeHash$, rawMetadata$) => codeHash$.pipe(
    mergeMap(
      (codeHash) => getCachedMetadata(codeHash).pipe(
        catchError(() => of(null)),
        mergeMap(
          (metadataRaw) => metadataRaw ? of(metadataRaw) : rawMetadata$.pipe(
            tap((raw) => {
              setCachedMetadata(codeHash, raw);
            })
          )
        ),
        map((metadataRaw) => ({
          codeHash,
          metadataRaw,
          metadata: unifyMetadata(metadata.dec(metadataRaw))
        }))
      )
    )
  );
  return (getHash) => {
    const enhancer = withRecovery(getHash);
    const initialHash = getHash();
    const usages = /* @__PURE__ */ new Set([initialHash]);
    const codeHash$ = enhancer(getCodeHash$)().pipe(shareReplay(1));
    const runtimeContext$ = getMetadata$(
      codeHash$,
      getRawMetadata$(enhancer(call$))
    ).pipe(
      map(
        ({ metadata, metadataRaw, codeHash }) => createRuntimeCtx(metadata, metadataRaw, codeHash)
      ),
      shareReplay(1)
    );
    const result = {
      at: initialHash,
      runtime: runtimeContext$,
      codeHash$,
      addBlock: (block) => {
        usages.add(block);
        return result;
      },
      deleteBlocks: (blocks) => {
        blocks.forEach((block) => {
          usages.delete(block);
        });
        return usages.size;
      },
      usages
    };
    runtimeContext$.subscribe({
      error() {
      }
    });
    return result;
  };
};

export { getRuntimeCreator };
//# sourceMappingURL=get-runtime-creator.mjs.map
