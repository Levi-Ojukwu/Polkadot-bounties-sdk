import { getHasherFromHeader } from '../../hashers.mjs';
import { blockHeader } from '@polkadot-api/substrate-bindings';
import { StopError } from '@polkadot-api/substrate-client';
import { Observable, share, noop, ReplaySubject, Subscription } from 'rxjs';

const createGetRuntimeChanges = (getCodeHash) => {
  const getRuntimeChanges = async (blocks, firstId, lastId) => {
    const firstBlock = blocks[firstId.idx];
    const lastBlock = blocks[lastId.idx];
    if (blocks.length === 2) return [firstBlock, lastBlock];
    const middleIdx = firstId.idx + Math.floor((lastId.idx - firstId.idx) / 2);
    const middle = {
      idx: middleIdx,
      id: await getCodeHash(blocks[middleIdx])
    };
    if (middle.id === firstId.id)
      return getRuntimeChanges(blocks, middle, lastId);
    if (middle.id === lastId.id)
      return getRuntimeChanges(blocks, firstId, middle);
    const [left, [_SKIP, ...right]] = await Promise.all([
      getRuntimeChanges(blocks, firstId, middle),
      getRuntimeChanges(blocks, middle, lastId)
    ]);
    return [...left, ...right];
  };
  return async (blocks) => {
    if (blocks.length < 2) return blocks;
    const lastIdx = blocks.length - 1;
    const [initialBlock] = blocks;
    const lastBlock = blocks[lastIdx];
    const [firstId, lastId] = await Promise.all(
      [initialBlock, lastBlock].map(getCodeHash)
    );
    if (firstId === lastId) return [blocks[0]];
    return getRuntimeChanges(
      blocks,
      { idx: 0, id: firstId },
      { idx: lastIdx, id: lastId }
    );
  };
};
const withInitializedNumber = (getFollower, getCodeHash) => {
  const getRuntimeChanges = createGetRuntimeChanges(getCodeHash);
  const getRawHeader = (blockHash) => getFollower().header(blockHash);
  const hasher$ = new ReplaySubject(1);
  const operator = (source$) => new Observable((observer) => {
    let pending = null;
    return source$.subscribe({
      next(event) {
        if (event.type === "initialized") {
          pending = [];
          const [blockHash] = event.finalizedBlockHashes;
          Promise.all([
            getRawHeader(blockHash),
            getRuntimeChanges(event.finalizedBlockHashes)
          ]).then(([rawHeader, changes]) => {
            if (!hasher$.closed) {
              hasher$.next(getHasherFromHeader(rawHeader, blockHash));
              hasher$.complete();
            }
            const header = blockHeader.dec(rawHeader);
            if (!observer.closed) {
              observer.next({
                type: "initialized",
                finalizedBlockHashes: event.finalizedBlockHashes,
                runtimeChanges: new Set(changes),
                number: header.number,
                parentHash: header.parentHash,
                hasNewRuntime: header.digests.some(
                  (d) => d.type === "runtimeUpdated"
                )
              });
              pending.forEach((e) => {
                observer.next(e);
              });
              pending = null;
            }
          }).catch((e) => {
            if (!observer.closed) observer.error(e);
          });
        } else if (pending) pending.push(event);
        else observer.next(event);
      },
      error(e) {
        observer.error(e);
      },
      complete() {
        observer.complete();
      }
    });
  });
  return {
    getHeader: (blockHash) => getRawHeader(blockHash).then(blockHeader[1]),
    hasher$: hasher$.asObservable(),
    operator
  };
};
const getFollow$ = (chainHead) => {
  let follower = null;
  let unfollow = noop;
  const getFollower = () => {
    if (!follower) throw new Error("Missing chainHead subscription");
    return follower;
  };
  const getCodeHash = async (blockHash) => (
    // ":code" => "0x3a636f6465"
    getFollower().storage(
      blockHash,
      "hash",
      "0x3a636f6465",
      null
    )
  );
  const { hasher$, operator, getHeader } = withInitializedNumber(
    getFollower,
    getCodeHash
  );
  const follow$ = new Observable((observer) => {
    follower = chainHead(
      true,
      (e) => {
        observer.next(e);
      },
      (e) => {
        follower = null;
        observer.error(e);
      }
    );
    unfollow = () => {
      observer.complete();
      follower?.unfollow();
    };
  }).pipe(operator, retryChainHeadError(), share());
  return {
    getHeader,
    hasher$,
    getFollower,
    follow$,
    unfollow: () => {
      unfollow();
    }
  };
};
const retryChainHeadError = () => (source$) => new Observable((observer) => {
  const subscription = new Subscription();
  const subscribe = () => source$.subscribe({
    next: (v) => observer.next(v),
    error: (e) => {
      subscription.add(subscribe());
      if (e instanceof StopError) {
        observer.next({ type: "stop-error" });
      } else {
        console.warn("ChainHead follow request failed, retrying\u2026", e);
      }
    },
    complete: () => observer.complete()
  });
  subscription.add(subscribe());
  return subscription;
});

export { getFollow$ };
//# sourceMappingURL=follow.mjs.map
