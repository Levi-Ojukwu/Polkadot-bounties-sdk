import { Subject, exhaustMap, timer, map, merge, scan, filter, tap } from 'rxjs';
import '@polkadot-api/substrate-client';
import { withStopRecovery } from '../enhancers/withStopRecovery.mjs';
import { getRuntimeCreator } from './get-runtime-creator.mjs';
import { shareLatest } from '../../utils/shareLatest.mjs';

const toBlockInfo = ({
  hash,
  number,
  parent,
  hasNewRuntime
}) => ({
  hash,
  number,
  parent,
  hasNewRuntime
});
const createRuntimeGetter = (pinned, startAt) => {
  return () => {
    const runtime = pinned.runtimes[startAt];
    if (!runtime) return pinned.blocks.has(startAt) ? startAt : null;
    const winner = [...runtime.usages].at(-1);
    return winner ?? null;
  };
};
const deleteBlock = (blocks, blockHash) => {
  blocks.get(blocks.get(blockHash).parent)?.children.delete(blockHash);
  blocks.delete(blockHash);
};
const deleteBlocks = (blocks, toDelete) => {
  toDelete.forEach((hash) => {
    deleteBlock(blocks.blocks, hash);
  });
  Object.entries(blocks.runtimes).map(([key, value]) => ({
    key,
    usages: value.deleteBlocks(toDelete)
  })).filter((x) => x.usages === 0).map((x) => x.key).forEach((unusedRuntime) => {
    delete blocks.runtimes[unusedRuntime];
  });
};
const getPinnedBlocks$ = (follow$, call$, getCodeHash$, getCachedMetadata$, setCachedMetadata, blockUsage$, newBlocks$, onUnpin, deleteFromCache) => {
  const onNewBlock = (block) => {
    newBlocks$.next(toBlockInfo(block));
  };
  const cleanup$ = new Subject();
  const cleanupEvt$ = cleanup$.pipe(
    exhaustMap(() => timer(0)),
    map(
      () => ({
        type: "cleanup"
      })
    )
  );
  const state = getInitialPinnedBlocks();
  const pinnedBlocks$ = merge(
    blockUsage$,
    cleanupEvt$,
    follow$
  ).pipe(
    scan((acc, event) => {
      const unpinAndDelete = (toUnpin) => {
        deleteBlocks(acc, toUnpin);
        onUnpin(toUnpin);
      };
      switch (event.type) {
        case "initialized":
          if (acc.recovering && !event.finalizedBlockHashes.some((hash) => acc.blocks.has(hash))) {
            acc = Object.assign(acc, getInitialPinnedBlocks());
            newBlocks$.next(null);
          }
          const latestFinalizedHeight = acc.blocks.get(acc.finalized)?.number ?? -1;
          const lastIdx = event.finalizedBlockHashes.length - 1;
          acc.finalized = acc.best = event.finalizedBlockHashes[lastIdx];
          let latestRuntime = acc.finalizedRuntime.at;
          const newBlocks = [];
          event.finalizedBlockHashes.forEach((hash, i) => {
            const unpinnable = i !== lastIdx;
            const preexistingBlock = acc.blocks.get(hash);
            if (preexistingBlock) {
              preexistingBlock.recovering = false;
              preexistingBlock.unpinnable = unpinnable;
            } else {
              const number = event.number + i;
              const isNew = number > latestFinalizedHeight;
              const requiresFromNewRuntime = event.runtimeChanges.has(hash) && !acc.runtimes[hash] && isNew;
              if (requiresFromNewRuntime) latestRuntime = hash;
              const parent = i === 0 ? event.parentHash : event.finalizedBlockHashes[i - 1];
              const block = {
                hash,
                hasNewRuntime: i ? event.runtimeChanges.has(hash) : event.hasNewRuntime,
                parent,
                children: new Set(
                  i === lastIdx ? [] : [event.finalizedBlockHashes[i + 1]]
                ),
                unpinnable,
                runtime: latestRuntime,
                refCount: 0,
                number,
                recovering: false
              };
              acc.blocks.set(hash, block);
              if (requiresFromNewRuntime)
                acc.finalizedRuntime = acc.runtimes[hash] = getRuntime(
                  createRuntimeGetter(acc, hash)
                );
              acc.runtimes[latestRuntime].usages.add(hash);
              if (isNew) newBlocks.push(block);
            }
          });
          newBlocks.forEach(onNewBlock);
          return acc;
        case "stop-error":
          for (const block of acc.blocks.values()) {
            block.recovering = true;
          }
          acc.recovering = true;
          return acc;
        case "newBlock": {
          const { parentBlockHash: parent, blockHash: hash } = event;
          if (acc.blocks.has(hash)) {
            acc.blocks.get(hash).recovering = false;
          } else {
            const parentNode = acc.blocks.get(parent);
            parentNode.children.add(hash);
            const number = parentNode.number + 1;
            const block = {
              hash,
              number,
              parent,
              children: /* @__PURE__ */ new Set(),
              runtime: event.newRuntime ? hash : parentNode.runtime,
              unpinnable: false,
              refCount: 0,
              recovering: false,
              hasNewRuntime: !!event.newRuntime
            };
            acc.blocks.set(hash, block);
            if (event.newRuntime) {
              acc.runtimes[hash] = getRuntime(createRuntimeGetter(acc, hash));
            }
            acc.runtimes[block.runtime].addBlock(hash);
            onNewBlock(block);
          }
          return acc;
        }
        case "bestBlockChanged": {
          if (acc.recovering) {
            for (const [hash, block] of acc.blocks) {
              if (block.recovering) {
                deleteBlock(acc.blocks, hash);
                deleteFromCache(hash);
              }
            }
            acc.recovering = false;
          }
          acc.best = event.bestBlockHash;
          return acc;
        }
        case "finalized": {
          acc.finalized = event.finalizedBlockHashes.slice(-1)[0];
          const { blocks } = acc;
          if (blocks.get(acc.best).number < blocks.get(acc.finalized).number)
            acc.best = acc.finalized;
          acc.finalizedRuntime = acc.runtimes[blocks.get(acc.finalized).runtime];
          event.prunedBlockHashes.forEach((hash) => {
            const block = acc.blocks.get(hash);
            if (block) {
              block.unpinnable = true;
            }
          });
          let current = blocks.get(blocks.get(acc.finalized).parent);
          while (current && !current.unpinnable) {
            current.unpinnable = true;
            current = blocks.get(current.parent);
          }
          cleanup$.next();
          return acc;
        }
        case "cleanup": {
          const toUnpin = [...acc.blocks.values()].filter(({ unpinnable, refCount }) => unpinnable && !refCount).map(({ hash }) => hash);
          unpinAndDelete(toUnpin);
          return acc;
        }
        case "blockUsage": {
          if (!acc.blocks.has(event.value.hash)) return acc;
          const block = acc.blocks.get(event.value.hash);
          block.refCount += event.value.type === "hold" ? 1 : -1;
          if (block.refCount === 0 && !block.recovering && block.unpinnable) {
            const toUnpin = [block.hash];
            unpinAndDelete(toUnpin);
          }
          return acc;
        }
      }
    }, state),
    filter((x) => !!x.finalizedRuntime.runtime),
    map((x) => ({ ...x })),
    tap({
      error(e) {
        newBlocks$.error(e);
      }
    }),
    shareLatest
  );
  const getRuntime = getRuntimeCreator(
    withStopRecovery(pinnedBlocks$, call$, "pinned-blocks"),
    withStopRecovery(pinnedBlocks$, getCodeHash$, "pinned-blocks"),
    getCachedMetadata$,
    setCachedMetadata
  );
  return Object.assign(pinnedBlocks$, { state });
};
const getInitialPinnedBlocks = () => ({
  best: "",
  finalized: "",
  runtimes: {},
  blocks: /* @__PURE__ */ new Map(),
  finalizedRuntime: {},
  recovering: false
});

export { getPinnedBlocks$, toBlockInfo };
//# sourceMappingURL=pinned-blocks.mjs.map
