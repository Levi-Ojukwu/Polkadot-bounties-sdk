import '@polkadot-api/substrate-client';
import { Observable, mergeMap, of, map, catchError, tap } from 'rxjs';
import { fromAbortControllerFn } from '../chainHead/enhancers/fromAbortControllerFn.mjs';
import { blockHeader, unifyMetadata, metadata } from '@polkadot-api/substrate-bindings';
import { getRawMetadata$ } from '../utils/get-raw-metadta.mjs';
import { createRuntimeCtx } from '../utils/create-metadata-ctx.mjs';

const getArchive = ({ storageSubscription, ...archive }) => (getRuntime) => {
  const runtimes = {};
  const rawStorage$ = fromAbortControllerFn(archive.storage);
  const call$ = fromAbortControllerFn(archive.call);
  const rawHeader$ = fromAbortControllerFn(archive.header);
  const body$ = fromAbortControllerFn(archive.body);
  const header$ = (blockHash) => rawHeader$(blockHash).pipe(map(blockHeader[1]));
  const getCodeHash = (blockHash) => (
    // ":code" => "0x3a636f6465"
    rawStorage$(blockHash, "hash", "0x3a636f6465", null).pipe(map((x) => x))
  );
  const getRuntime$ = (codeHash, blockHash) => getRuntime(codeHash).pipe(
    catchError(() => of(null)),
    mergeMap(
      (result) => result ? of(result) : getRawMetadata$((...args) => call$(blockHash, ...args)).pipe(
        map(
          (rawMetadata) => createRuntimeCtx(
            unifyMetadata(metadata.dec(rawMetadata)),
            rawMetadata,
            codeHash
          )
        )
      )
    ),
    tap((runtime) => {
      runtimes[codeHash] = runtime;
    })
  );
  const getRuntimeContext$ = (blockHash) => getCodeHash(blockHash).pipe(
    mergeMap((codeHash) => {
      const runtime = runtimes[codeHash];
      return runtime ? of(runtime) : getRuntime$(codeHash, blockHash);
    })
  );
  const storage$ = (hash, type, keyMapper, childTrie = null, mapper) => getRuntimeContext$(hash).pipe(
    mergeMap(
      (ctx) => rawStorage$(hash, type, keyMapper(ctx), childTrie).pipe(
        map((x) => mapper ? mapper(x, ctx) : x)
      )
    )
  );
  const storageQueries$ = (hash, queries, childTrie) => new Observable(
    (observer) => storageSubscription(
      hash,
      queries,
      childTrie || null,
      (item) => observer.next(item),
      (error) => observer.error(error),
      () => {
        observer.complete();
      }
    )
  );
  const eventsAt$ = (hash) => storage$(
    hash,
    "value",
    (ctx) => ctx.events.key,
    null,
    (x, ctx) => ctx.events.dec(x)
  );
  return {
    body$,
    header$,
    storage$,
    storageQueries$,
    call$,
    eventsAt$,
    getRuntimeContext$
  };
};

export { getArchive };
//# sourceMappingURL=archive.mjs.map
