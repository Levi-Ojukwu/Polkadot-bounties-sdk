{"version":3,"file":"create-metadata-ctx.mjs","sources":["../../../src/utils/create-metadata-ctx.ts"],"sourcesContent":["import type { RuntimeContext } from \"@/chainHead\"\nimport {\n  AccountId,\n  Bytes,\n  compactNumber,\n  createDecoder,\n  Decoder,\n  DecoderType,\n  enhanceDecoder,\n  extrinsicFormat,\n  StringRecord,\n  Struct,\n  u16,\n  u8,\n  type UnifiedMetadata,\n} from \"@polkadot-api/substrate-bindings\"\nimport { getDynamicBuilder, getLookupFn } from \"@polkadot-api/metadata-builders\"\n\nconst CHECK_MORTALITY = \"CheckMortality\"\n\nexport const createRuntimeCtx = (\n  metadata: UnifiedMetadata,\n  metadataRaw: Uint8Array,\n  codeHash: string,\n): RuntimeContext => {\n  const lookup = getLookupFn(metadata)\n  const dynamicBuilder = getDynamicBuilder(lookup)\n  const events = dynamicBuilder.buildStorage(\"System\", \"Events\")\n\n  const assetPayment = metadata.extrinsic.signedExtensions.find(\n    (x) => x.identifier === \"ChargeAssetTxPayment\",\n  )\n\n  let assetId: null | number = null\n  if (assetPayment) {\n    const assetTxPayment = lookup(assetPayment.type)\n    if (assetTxPayment.type === \"struct\") {\n      const optionalAssetId = assetTxPayment.value.asset_id\n      if (optionalAssetId.type === \"option\") assetId = optionalAssetId.value.id\n    }\n  }\n\n  const extrinsicDecoder = getExtrinsicDecoder(lookup.metadata, dynamicBuilder)\n  const getMortalityFromTx: typeof mortalityDecoder = (tx) => {\n    const decodedExt = extrinsicDecoder(tx)\n    return (\n      (\"extra\" in decodedExt &&\n        (decodedExt.extra[CHECK_MORTALITY] as\n          | DecoderType<typeof mortalityDecoder>\n          | undefined)) || { mortal: false }\n    )\n  }\n\n  return {\n    assetId,\n    metadataRaw,\n    codeHash,\n    lookup,\n    dynamicBuilder,\n    events: {\n      key: events.keys.enc(),\n      dec: events.value.dec as any,\n    },\n    accountId: AccountId(dynamicBuilder.ss58Prefix),\n    getMortalityFromTx,\n  }\n}\n\n// TODO: put all the logic that follows in a generic enough low-level package\nconst allBytesDec = Bytes(Infinity).dec\n\ntype DecodedExtrinsic = {\n  len: number\n  callData: Uint8Array\n} & (\n  | { version: 4 | 5; type: \"bare\" }\n  | {\n      version: 4\n      type: \"signed\"\n      address: any\n      signature: any\n      extra: Record<string, any>\n    }\n  | {\n      version: 5\n      type: \"general\"\n      extensionVersion: number\n      extra: Record<string, any>\n    }\n)\n\nconst mortalDecoder = enhanceDecoder(u16[1], (input) => {\n  const period = 2 << input % (1 << 4)\n  const factor = Math.max(period >> 12, 1)\n  const phase = (input >> 4) * factor\n  return { mortal: true as const, period, phase }\n})\n\nconst mortalityDecoder = createDecoder((value) => {\n  const firstByte = u8.dec(value)\n  if (firstByte === 0) return { mortal: false as const }\n  const secondByte = u8.dec(value)\n  return mortalDecoder(Uint8Array.from([firstByte, secondByte]))\n})\n\nconst getExtrinsicDecoder = (\n  metadata: UnifiedMetadata,\n  dynamicBuilder: ReturnType<typeof getDynamicBuilder>,\n): Decoder<DecodedExtrinsic> => {\n  const innerExtra = Object.fromEntries(\n    metadata.extrinsic.signedExtensions.map(\n      (x) =>\n        [\n          x.identifier,\n          x.identifier === CHECK_MORTALITY\n            ? mortalityDecoder\n            : dynamicBuilder.buildDefinition(x.type)[1],\n        ] as [string, Decoder<any>],\n    ),\n  ) as StringRecord<Decoder<any>>\n\n  let address: Decoder<any>\n  let signature: Decoder<any>\n  const { extrinsic } = metadata\n  if (\"address\" in extrinsic) {\n    // v15/v16\n    address = dynamicBuilder.buildDefinition(extrinsic.address)[1]\n    signature = dynamicBuilder.buildDefinition(extrinsic.signature)[1]\n  } else {\n    // v14\n    const params = metadata.lookup[extrinsic.type]?.params\n    const _call = params?.find((v) => v.name === \"Call\")?.type\n    const addr = params?.find((v) => v.name === \"Address\")?.type\n    const sig = params?.find((v) => v.name === \"Signature\")?.type\n    if (_call == null || addr == null || sig == null)\n      throw new Error(\"Call, Address and/or signature not found\")\n    address = dynamicBuilder.buildDefinition(addr)[1]\n    signature = dynamicBuilder.buildDefinition(sig)[1]\n  }\n\n  const v4Body = Struct.dec({\n    address,\n    signature,\n    extra: Struct.dec(innerExtra),\n    callData: allBytesDec,\n  })\n\n  return createDecoder((data) => {\n    const len = compactNumber.dec(data)\n    const { type, version } = extrinsicFormat[1](data)\n    if (type === \"bare\")\n      return { len, version, type, callData: allBytesDec(data) }\n    if (type === \"signed\") return { len, version, type, ...v4Body(data) }\n\n    const extensionVersion = u8.dec(data)\n    let extraDec: Decoder<StringRecord<any>>\n    if (metadata.version === 16) {\n      const extensionsToApply = (\n        metadata as UnifiedMetadata<16>\n      ).extrinsic.signedExtensionsByVersion.find(\n        ([x]) => x === extensionVersion,\n      )\n      if (!extensionsToApply) throw new Error(\"Unexpected extension version\")\n      extraDec = Struct.dec(\n        Object.fromEntries(\n          Object.entries(innerExtra).filter((_, idx) =>\n            extensionsToApply[1].includes(idx),\n          ),\n        ) as StringRecord<Decoder<any>>,\n      )\n    } else extraDec = Struct.dec(innerExtra)\n    const extra = extraDec(data)\n\n    return {\n      len,\n      type,\n      version,\n      extensionVersion,\n      extra,\n      callData: allBytesDec(data),\n    }\n  }) as any\n}\n"],"names":[],"mappings":"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"}