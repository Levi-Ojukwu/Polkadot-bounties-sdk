import { AccountId, createDecoder, Struct, Bytes, compactNumber, extrinsicFormat, u8, enhanceDecoder, u16 } from '@polkadot-api/substrate-bindings';
import { getLookupFn, getDynamicBuilder } from '@polkadot-api/metadata-builders';

const CHECK_MORTALITY = "CheckMortality";
const createRuntimeCtx = (metadata, metadataRaw, codeHash) => {
  const lookup = getLookupFn(metadata);
  const dynamicBuilder = getDynamicBuilder(lookup);
  const events = dynamicBuilder.buildStorage("System", "Events");
  const assetPayment = metadata.extrinsic.signedExtensions.find(
    (x) => x.identifier === "ChargeAssetTxPayment"
  );
  let assetId = null;
  if (assetPayment) {
    const assetTxPayment = lookup(assetPayment.type);
    if (assetTxPayment.type === "struct") {
      const optionalAssetId = assetTxPayment.value.asset_id;
      if (optionalAssetId.type === "option") assetId = optionalAssetId.value.id;
    }
  }
  const extrinsicDecoder = getExtrinsicDecoder(lookup.metadata, dynamicBuilder);
  const getMortalityFromTx = (tx) => {
    const decodedExt = extrinsicDecoder(tx);
    return "extra" in decodedExt && decodedExt.extra[CHECK_MORTALITY] || { mortal: false };
  };
  return {
    assetId,
    metadataRaw,
    codeHash,
    lookup,
    dynamicBuilder,
    events: {
      key: events.keys.enc(),
      dec: events.value.dec
    },
    accountId: AccountId(dynamicBuilder.ss58Prefix),
    getMortalityFromTx
  };
};
const allBytesDec = Bytes(Infinity).dec;
const mortalDecoder = enhanceDecoder(u16[1], (input) => {
  const period = 2 << input % (1 << 4);
  const factor = Math.max(period >> 12, 1);
  const phase = (input >> 4) * factor;
  return { mortal: true, period, phase };
});
const mortalityDecoder = createDecoder((value) => {
  const firstByte = u8.dec(value);
  if (firstByte === 0) return { mortal: false };
  const secondByte = u8.dec(value);
  return mortalDecoder(Uint8Array.from([firstByte, secondByte]));
});
const getExtrinsicDecoder = (metadata, dynamicBuilder) => {
  const innerExtra = Object.fromEntries(
    metadata.extrinsic.signedExtensions.map(
      (x) => [
        x.identifier,
        x.identifier === CHECK_MORTALITY ? mortalityDecoder : dynamicBuilder.buildDefinition(x.type)[1]
      ]
    )
  );
  let address;
  let signature;
  const { extrinsic } = metadata;
  if ("address" in extrinsic) {
    address = dynamicBuilder.buildDefinition(extrinsic.address)[1];
    signature = dynamicBuilder.buildDefinition(extrinsic.signature)[1];
  } else {
    const params = metadata.lookup[extrinsic.type]?.params;
    const _call = params?.find((v) => v.name === "Call")?.type;
    const addr = params?.find((v) => v.name === "Address")?.type;
    const sig = params?.find((v) => v.name === "Signature")?.type;
    if (_call == null || addr == null || sig == null)
      throw new Error("Call, Address and/or signature not found");
    address = dynamicBuilder.buildDefinition(addr)[1];
    signature = dynamicBuilder.buildDefinition(sig)[1];
  }
  const v4Body = Struct.dec({
    address,
    signature,
    extra: Struct.dec(innerExtra),
    callData: allBytesDec
  });
  return createDecoder((data) => {
    const len = compactNumber.dec(data);
    const { type, version } = extrinsicFormat[1](data);
    if (type === "bare")
      return { len, version, type, callData: allBytesDec(data) };
    if (type === "signed") return { len, version, type, ...v4Body(data) };
    const extensionVersion = u8.dec(data);
    let extraDec;
    if (metadata.version === 16) {
      const extensionsToApply = metadata.extrinsic.signedExtensionsByVersion.find(
        ([x]) => x === extensionVersion
      );
      if (!extensionsToApply) throw new Error("Unexpected extension version");
      extraDec = Struct.dec(
        Object.fromEntries(
          Object.entries(innerExtra).filter(
            (_, idx) => extensionsToApply[1].includes(idx)
          )
        )
      );
    } else extraDec = Struct.dec(innerExtra);
    const extra = extraDec(data);
    return {
      len,
      type,
      version,
      extensionVersion,
      extra,
      callData: allBytesDec(data)
    };
  });
};

export { createRuntimeCtx };
//# sourceMappingURL=create-metadata-ctx.mjs.map
