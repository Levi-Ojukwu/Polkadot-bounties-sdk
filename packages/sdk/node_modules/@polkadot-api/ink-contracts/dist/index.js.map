{"version":3,"file":"index.js","sources":["../src/dynamic-builders.ts","../src/metadata-pjs-types.ts","../src/get-lookup.ts","../src/ink-client.ts"],"sourcesContent":["import { getLookupCodecBuilder } from \"@polkadot-api/metadata-builders\"\nimport { Binary, Variant } from \"@polkadot-api/substrate-bindings\"\nimport {\n  _void,\n  Bytes,\n  Codec,\n  CodecType,\n  createCodec,\n  enhanceCodec,\n  StringRecord,\n  Struct,\n  Tuple,\n} from \"@polkadot-api/substrate-bindings\"\nimport { InkMetadataLookup } from \"./get-lookup\"\nimport {\n  EventParamSpec,\n  EventSpecV5,\n  MessageParamSpec,\n  TypeSpec,\n} from \"./metadata-types\"\n\nexport const getInkDynamicBuilder = (metadataLookup: InkMetadataLookup) => {\n  const { metadata } = metadataLookup\n\n  const buildDefinition = getLookupCodecBuilder(metadataLookup)\n\n  const buildStorage = (name = \"\") => {\n    const storageEntry = metadataLookup.storage[name]\n    if (!storageEntry)\n      throw new Error(`Storage entry ${name ? name : \"{root}\"} not found`)\n\n    const keyCodec =\n      storageEntry.key == null ? _void : buildDefinition(storageEntry.key)\n    return {\n      key: prependBytes(keyCodec, storageEntry.keyPrefix),\n      value: buildDefinition(storageEntry.typeId),\n    }\n  }\n\n  const buildCallable = (callable: {\n    selector: string\n    args: Array<MessageParamSpec>\n    returnType: TypeSpec\n  }) => {\n    const argsCodec = Struct(\n      Object.fromEntries(\n        callable.args.map((param) => [\n          param.label,\n          buildDefinition(param.type.type),\n        ]),\n      ) as StringRecord<Codec<any>>,\n    )\n\n    return {\n      call: prependBytes(argsCodec, callable.selector),\n      value: buildDefinition(callable.returnType.type),\n    }\n  }\n\n  const buildConstructor = (label: string) => {\n    const constr = metadata.spec.constructors.find((c) => c.label === label)\n    if (!constr) {\n      throw new Error(`Constructor ${label} not found`)\n    }\n\n    return buildCallable(constr)\n  }\n\n  const buildMessage = (label: string) => {\n    const message = metadata.spec.messages.find((c) => c.label === label)\n    if (!message) {\n      throw new Error(`Message ${label} not found`)\n    }\n\n    return buildCallable(message)\n  }\n\n  const buildEventCodec = (event: { args: EventParamSpec[] }) =>\n    Struct(\n      Object.fromEntries(\n        event.args.map((param) => [\n          param.label,\n          buildDefinition(param.type.type),\n        ]),\n      ) as StringRecord<Codec<any>>,\n    )\n\n  const buildEvent = (signatureTopic: string | undefined) => {\n    const events = metadata.spec.events as EventSpecV5[]\n\n    const withType = <T>(codec: Codec<T>, type: string) =>\n      enhanceCodec<T, { type: string; value: T }>(\n        codec,\n        (evt) => evt.value,\n        (value) => ({ type, value }),\n      )\n\n    if (signatureTopic) {\n      const event = events.find((evt) => evt.signature_topic === signatureTopic)\n      return event ? withType(buildEventCodec(event), event.label) : null\n    }\n\n    const candidates = events.filter(\n      (evt) => evt.signature_topic === signatureTopic,\n    )\n    return candidates.length\n      ? first(candidates.map((c) => withType(buildEventCodec(c), c.label)))\n      : null\n  }\n\n  const buildEvents = () =>\n    Variant(\n      Object.fromEntries(\n        metadata.spec.events.map((evt) => [evt.label, buildEventCodec(evt)]),\n      ) as unknown as StringRecord<Codec<any>>,\n    )\n\n  return {\n    buildConstructor,\n    buildMessage,\n    buildStorage,\n    buildEvents,\n    buildEvent,\n  }\n}\n\nexport type InkDynamicBuilder = ReturnType<typeof getInkDynamicBuilder>\n\nconst prependBytes = <T>(codec: Codec<T>, hex: string) => {\n  const bytes = Binary.fromHex(hex).asBytes()\n  const wrappedCodec = Tuple(Bytes(bytes.length), codec)\n  return enhanceCodec(\n    wrappedCodec,\n    (value: CodecType<typeof codec>): CodecType<typeof wrappedCodec> => [\n      bytes,\n      value,\n    ],\n    ([, value]) => value,\n  )\n}\n\nconst first = <T>(codecs: Codec<T>[]) =>\n  createCodec<T>(\n    (x) => {\n      for (const codec of codecs) {\n        try {\n          codec.enc(x)\n        } catch (_) {}\n      }\n      throw new Error(\"Unable to encode\")\n    },\n    (x) => {\n      for (const codec of codecs) {\n        try {\n          codec.dec(x)\n        } catch (_) {}\n      }\n      throw new Error(\"Unable to decode\")\n    },\n  )\n","import {\n  _void,\n  Codec,\n  CodecType,\n  compactNumber,\n  enhanceCodec,\n  Option,\n  ScaleEnum,\n  str,\n  StringRecord,\n  Struct,\n  u32,\n  u8,\n  Vector,\n} from \"@polkadot-api/substrate-bindings\"\n\ntype PjsVariant<O extends StringRecord<Codec<any>>> = {\n  [K in keyof O]: {\n    [KK in K]: CodecType<O[K]>\n  }\n}[keyof O]\nconst Variant = <O extends StringRecord<Codec<any>>>(inner: O) =>\n  enhanceCodec(\n    ScaleEnum(inner),\n    (value: PjsVariant<O>) => {\n      if (typeof value === \"string\") {\n        return {\n          tag: value,\n          value: undefined,\n        } as any\n      }\n      const [tag, val] = Object.entries(value)[0]\n\n      return {\n        tag: tag as keyof O,\n        value: val,\n      }\n    },\n    (value) => {\n      return {\n        [value.tag]: value.value,\n      } as PjsVariant<O>\n    },\n  )\n\n// Seems like pjs can omit empty vectors\nconst PjsVector = <T>(inner: Codec<T>, size?: number) =>\n  enhanceCodec(\n    Vector(inner, size),\n    (value: T[] | undefined) => value ?? [],\n    (v) => v,\n  )\n\nconst oStr = Option(str)\nconst docs = PjsVector(str)\n\nconst primitive = Variant({\n  bool: _void,\n  char: _void,\n  str: _void,\n  u8: _void,\n  u16: _void,\n  u32: _void,\n  u64: _void,\n  u128: _void,\n  u256: _void,\n  i8: _void,\n  i16: _void,\n  i32: _void,\n  i64: _void,\n  i128: _void,\n  i256: _void,\n})\n\nconst fields = PjsVector(\n  Struct({\n    name: oStr,\n    type: compactNumber,\n    typeName: oStr,\n    docs,\n  }),\n)\n\nconst arr = Struct({\n  len: u32,\n  type: compactNumber,\n})\n\nconst bitSequence = Struct({\n  bitStoreType: compactNumber,\n  bitOrderType: compactNumber,\n})\n\nconst variants = PjsVector(\n  Struct({\n    name: str,\n    fields,\n    index: u8,\n    docs,\n  }),\n)\n\nconst def = Variant({\n  composite: Struct({\n    fields,\n  }),\n  variant: Struct({\n    variants,\n  }),\n  sequence: Struct({\n    type: compactNumber,\n  }),\n  array: arr,\n  tuple: Vector(compactNumber),\n  primitive,\n  compact: compactNumber,\n  bitSequence,\n})\n\nconst param = Struct({\n  name: str,\n  type: Option(compactNumber),\n})\nconst params = PjsVector(param)\n\nconst metadataEntry = Struct({\n  id: compactNumber,\n  path: docs,\n  params,\n  def,\n  docs,\n})\n\nconst entry = enhanceCodec(\n  metadataEntry,\n  (value: {\n    id: number\n    type: {\n      def: CodecType<typeof def>\n      path: CodecType<typeof docs>\n      params?: Array<{ name: string; type: number | undefined }>\n    }\n  }) => ({\n    id: value.id,\n    path: value.type.path,\n    params: value.type.params ?? [],\n    def: value.type.def,\n    docs: [],\n  }),\n  (value) => ({\n    id: value.id,\n    type: {\n      def: value.def,\n      path: value.path,\n      params: value.params,\n    },\n  }),\n)\n\nexport const pjsTypes = PjsVector(entry)\nexport type PjsTypes = CodecType<typeof pjsTypes>\n","import { denormalizeLookup, LookupEntry } from \"@polkadot-api/metadata-builders\"\nimport { Binary, V14Lookup, v14Lookup } from \"@polkadot-api/substrate-bindings\"\nimport { InkMetadata, Layout } from \"./metadata-types\"\nimport { pjsTypes } from \"./metadata-pjs-types\"\n\nexport interface InkMetadataLookup {\n  (id: number): LookupEntry\n  metadata: InkMetadata\n  storage: StorageLayout\n}\n\nexport interface StorageEntryPoint {\n  keyPrefix: string\n  key: number | null\n  typeId: number\n}\n\nexport type StorageLayout = Record<string, StorageEntryPoint>\n\nexport const getInkLookup = (metadata: InkMetadata): InkMetadataLookup => {\n  // We can reuse dynamic-builder's lookup if we encode and re-decode the type\n  // into V14Lookup, because both v14 metadata lookup and ink types use scale-info\n  const encoded = pjsTypes.enc(metadata.types)\n  const decoded = v14Lookup.dec(encoded)\n\n  // Signal the lookup the AccountId type\n  const accountTypeId = metadata.spec.environment.accountId.type\n  const accountIdEntry = decoded.find((e) => e.id === accountTypeId)\n  if (accountIdEntry) {\n    accountIdEntry.path = [\"AccountId32\"]\n  }\n\n  const storage = getStorageLayout(metadata, decoded)\n  const getLookupEntryDef = denormalizeLookup(decoded)\n\n  return Object.assign(getLookupEntryDef, {\n    metadata,\n    lookup: decoded,\n    storage,\n  })\n}\n\nfunction getStorageLayout(metadata: InkMetadata, lookup: V14Lookup) {\n  const result: StorageLayout = {}\n\n  const readLayout = (node: Layout, path: string[] = []): number | null => {\n    function addType(def: V14Lookup[number][\"def\"]) {\n      const id = lookup.length\n      lookup[id] = {\n        id,\n        docs: [],\n        def,\n        params: [],\n        path: [],\n      }\n      return id\n    }\n\n    if (\"root\" in node) {\n      // On version 4-, the keys in the storage were in big-endian.\n      // For version 5+, the keys in storage are in scale, which is little-endian.\n      // https://use.ink/faq/migrating-from-ink-4-to-5#metadata-storage-keys-encoding-change\n      // https://github.com/use-ink/ink/pull/2048\n      const keyPrefix =\n        Number(metadata.version) === 4\n          ? Binary.fromBytes(\n              Binary.fromHex(node.root.root_key).asBytes().reverse(),\n            ).asHex()\n          : node.root.root_key\n\n      const typeId = readLayout(node.root.layout, path)!\n      if (node.root.ty != null) {\n        function resolveType(id: number, path: string[]) {\n          const type = metadata.types[id].type\n\n          // A vector internally uses a Mapping, but we have to get it\n          const fields =\n            \"composite\" in type.def\n              ? new Map(\n                  (type.def.composite.fields ?? []).map((v) => [\n                    v.name,\n                    v.type,\n                  ]),\n                )\n              : null\n          const params = new Map(\n            (type.params ?? []).map((v) => [v.name, v.type]),\n          )\n\n          if (\n            params.size === 2 &&\n            params.has(\"V\") &&\n            fields &&\n            fields.size === 2 &&\n            fields.has(\"len\") &&\n            fields.has(\"elements\")\n          ) {\n            // Vectors have length and elements as different entry points\n            resolveType(fields.get(\"len\")!, [...path, \"len\"])\n            resolveType(fields.get(\"elements\")!, path)\n            return\n          } else if (params.size === 3 && params.has(\"K\") && params.has(\"V\")) {\n            // Mapping\n            result[path.join(\".\")] = {\n              keyPrefix,\n              key: params.get(\"K\")!,\n              typeId: params.get(\"V\")!,\n            }\n          } else if (params.size === 2 && params.has(\"V\")) {\n            // Lazy\n            result[path.join(\".\")] = {\n              keyPrefix,\n              key: null,\n              typeId: params.get(\"V\")!,\n            }\n          }\n        }\n        resolveType(node.root.ty, path)\n      }\n\n      if (!result[path.join(\".\")]) {\n        result[path.join(\".\")] = {\n          keyPrefix,\n          key: null,\n          typeId,\n        }\n      }\n\n      // Anyone addressing this node will encounter an empty type\n      return addType({\n        tag: \"composite\",\n        value: [],\n      })\n    }\n    if (\"leaf\" in node) {\n      return node.leaf.ty\n    }\n    if (\"hash\" in node) {\n      throw new Error(\"HashLayout not implemented\")\n    }\n    if (\"array\" in node) {\n      const inner = readLayout(node.array.layout, path)\n\n      return inner == null\n        ? null\n        : addType({\n            tag: \"array\",\n            value: {\n              len: node.array.len,\n              type: inner,\n            },\n          })\n    }\n    if (\"struct\" in node) {\n      const inner = node.struct.fields\n        .map((field) => ({\n          name: field.name,\n          type: readLayout(field.layout, [...path, field.name])!,\n          typeName: undefined,\n          docs: [],\n        }))\n        .filter((field) => field.type != null)\n\n      return addType({\n        tag: \"composite\",\n        value: inner,\n      })\n    }\n\n    const inner = Object.values(node.enum.variants).map((variant, index) => ({\n      name: variant.name,\n      fields: variant.fields\n        .map((field) => ({\n          name: field.name,\n          type: readLayout(field.layout, [...path, variant.name, field.name])!,\n          typeName: undefined,\n          docs: [],\n        }))\n        .filter((v) => v.type !== null),\n      index,\n      docs: [],\n    }))\n\n    return addType({\n      tag: \"variant\",\n      value: inner,\n    })\n  }\n  readLayout(metadata.storage)\n\n  return result\n}\n","import { Binary } from \"@polkadot-api/substrate-bindings\"\nimport { getInkDynamicBuilder, InkDynamicBuilder } from \"./dynamic-builders\"\nimport { getInkLookup, InkMetadataLookup } from \"./get-lookup\"\nimport {\n  Event,\n  InkCallableDescriptor,\n  InkDescriptors,\n  InkStorageDescriptor,\n} from \"./ink-descriptors\"\nimport { ConstructorSpec, EventSpecV5, MessageSpec } from \"./metadata-types\"\n\nexport type InkCallableInterface<T extends InkCallableDescriptor> = <\n  L extends string & keyof T,\n>(\n  label: L,\n) => {\n  encode: {} extends T[L][\"message\"]\n    ? (value?: T[L][\"message\"]) => Binary\n    : (value: T[L][\"message\"]) => Binary\n  decode: (value: { data: Binary }) => T[L][\"response\"]\n  attributes: {\n    payable: boolean\n    default: boolean\n    mutates: boolean\n  }\n}\n\nexport type InkStorageInterface<S extends InkStorageDescriptor> =\n  (\"\" extends keyof S\n    ? () => {\n        encode: S[\"\"][\"key\"] extends undefined\n          ? (key?: undefined) => Binary\n          : (key: S[\"\"][\"key\"]) => Binary\n        decode: (data: Binary) => S[\"\"][\"value\"]\n      }\n    : unknown) &\n    (<L extends string & keyof S>(\n      label: L,\n    ) => {\n      encode: S[L][\"key\"] extends undefined\n        ? (key?: undefined) => Binary\n        : (key: S[L][\"key\"]) => Binary\n      decode: (data: Binary) => S[L][\"value\"]\n    })\n\nexport type GenericEvent =\n  | {\n      type: \"Contracts\"\n      value:\n        | {\n            type: \"ContractEmitted\"\n            value: {\n              contract: string\n              data: Binary\n            }\n          }\n        | { type: string; value: unknown }\n    }\n  | { type: string; value: unknown }\nexport interface InkEventInterface<E> {\n  decode: (value: { data: Binary }, signatureTopic?: string) => E\n  filter: (\n    address: string,\n    events?: Array<\n      | { event: GenericEvent; topics: Binary[] }\n      | (GenericEvent & { topics: Binary[] })\n    >,\n  ) => E[]\n}\n\ntype HasDefault<T> = \"default\" extends keyof T\n  ? T[\"default\"] extends true\n    ? true\n    : false\n  : false\ntype GetDefault<M> = keyof {\n  [K in keyof M as HasDefault<M[K]> extends true ? K : never]: true\n}\n\n// T can be the default message or `never`.\n// Typescript doesn't like doing `extends never` (it works for the \"false\" case, but for the other it will always give back never)\n// One way of running around it is by checking whether an empty object extends an object with that key.\ntype WrapDefault<T extends string> = {} extends {\n  [K in T]: K\n}\n  ? string | undefined\n  : T\n\nexport interface InkClient<\n  D extends InkDescriptors<\n    InkStorageDescriptor,\n    InkCallableDescriptor,\n    InkCallableDescriptor,\n    Event\n  >,\n> {\n  constructor: InkCallableInterface<D[\"__types\"][\"constructors\"]>\n  defaultConstructor: WrapDefault<GetDefault<D[\"__types\"][\"constructors\"]>>\n  message: InkCallableInterface<D[\"__types\"][\"messages\"]>\n  defaultMessage: WrapDefault<GetDefault<D[\"__types\"][\"messages\"]>>\n  storage: InkStorageInterface<D[\"__types\"][\"storage\"]>\n  event: InkEventInterface<D[\"__types\"][\"event\"]>\n}\n\nexport const getInkClient = <\n  D extends InkDescriptors<\n    InkStorageDescriptor,\n    InkCallableDescriptor,\n    InkCallableDescriptor,\n    Event\n  >,\n>(\n  inkContract: D,\n): InkClient<D> => {\n  if (!inkContract.metadata) {\n    throw new Error(\"Ink client needs the contract metadata\")\n  }\n\n  const lookup = getInkLookup(inkContract.metadata)\n  const builder = getInkDynamicBuilder(lookup)\n\n  const constructorCodec = buildCallable(builder.buildConstructor)\n  const messageCodec = buildCallable(builder.buildMessage)\n\n  const findConstructor = (label: string) => {\n    const result = lookup.metadata.spec.constructors.find(\n      (c) => c.label === label,\n    )\n    if (!result) {\n      throw new Error(`Constructor ${label} not found`)\n    }\n    return result\n  }\n  const findMessage = (label: string) => {\n    const result = lookup.metadata.spec.messages.find((c) => c.label === label)\n    if (!result) {\n      throw new Error(`Message ${label} not found`)\n    }\n    return result\n  }\n\n  const defaultConstructor: any = lookup.metadata.spec.constructors.find(\n    (c) => c.default,\n  )?.label\n  const defaultMessage: any = lookup.metadata.spec.messages.find(\n    (c) => c.default,\n  )?.label\n\n  return {\n    constructor: (label) => ({\n      attributes: getAttributes(findConstructor(label)),\n      ...constructorCodec(label),\n    }),\n    defaultConstructor,\n    message: (label) => ({\n      attributes: getAttributes(findMessage(label)),\n      ...messageCodec(label),\n    }),\n    defaultMessage,\n    storage: buildStorage(builder.buildStorage),\n    event:\n      Number(lookup.metadata.version) === 4\n        ? buildEventV4(builder.buildEvents)\n        : buildEventV5(lookup, builder.buildEvent),\n  }\n}\n\nconst getAttributes = (spec: ConstructorSpec | MessageSpec) => ({\n  payable: spec.payable,\n  default: spec.default,\n  mutates: \"mutates\" in spec ? spec.mutates : true,\n})\n\nconst buildCallable =\n  <T extends InkCallableDescriptor>(\n    builder:\n      | InkDynamicBuilder[\"buildConstructor\"]\n      | InkDynamicBuilder[\"buildMessage\"],\n  ) =>\n  <L extends string & keyof T>(label: L) => {\n    const codecs = builder(label)\n\n    return {\n      encode: (value?: T[L][\"message\"]) =>\n        Binary.fromBytes(codecs.call.enc(value || {})),\n      decode: (response: { data: Binary }) =>\n        codecs.value.dec(response.data.asBytes()),\n    }\n  }\n\nconst buildStorage =\n  <S extends InkStorageDescriptor>(\n    builder: InkDynamicBuilder[\"buildStorage\"],\n  ): InkStorageInterface<S> =>\n  <L extends string & keyof S>(label?: L) => {\n    const codecs = builder(label)\n\n    return {\n      encode: (key?: S[L][\"key\"]) =>\n        Binary.fromBytes(codecs.key.enc(key as any)),\n      decode: (response: Binary) => codecs.value.dec(response.asBytes()),\n    }\n  }\n\nconst buildEventV4 = <E extends Event>(\n  eventsDecoder: InkDynamicBuilder[\"buildEvents\"],\n): InkEventInterface<E> => {\n  const decode: InkEventInterface<E>[\"decode\"] = (value) => {\n    return eventsDecoder().dec(value.data.asBytes()) as E\n  }\n  const filter: InkEventInterface<E>[\"filter\"] = (address, events = []) => {\n    const contractEvents = events\n      .map((v) => (\"event\" in v ? v.event : v))\n      .filter(\n        (v: any) =>\n          v.type === \"Contracts\" &&\n          v.value.type === \"ContractEmitted\" &&\n          v.value.value.contract === address,\n      )\n    return contractEvents.map((v: any) => {\n      try {\n        return decode(v.value.value)\n      } catch (ex) {\n        console.error(\n          `Contract ${address} emitted an incompatible event`,\n          v.value.value,\n        )\n        throw ex\n      }\n    })\n  }\n  return { decode, filter }\n}\n\nconst buildEventV5 = <E extends Event>(\n  lookup: InkMetadataLookup,\n  eventDecoder: InkDynamicBuilder[\"buildEvent\"],\n): InkEventInterface<E> => {\n  const metadataEventTopics = new Set(\n    lookup.metadata.spec.events\n      .map((evt) => (evt as EventSpecV5).signature_topic)\n      .filter((v) => v != null),\n  )\n  const hasAnonymousEvents = lookup.metadata.spec.events.some(\n    (evt) => (evt as EventSpecV5).signature_topic == null,\n  )\n\n  const decode: InkEventInterface<E>[\"decode\"] = (value, signatureTopic) => {\n    if (signatureTopic != null) {\n      if (!metadataEventTopics.has(signatureTopic)) {\n        throw new Error(`Event with signature topic ${value} not found`)\n      }\n      return eventDecoder(signatureTopic)!.dec(value.data.asBytes()) as E\n    }\n    if (!hasAnonymousEvents) {\n      throw new Error(\"Event signature topic required\")\n    }\n    return eventDecoder(undefined)!.dec(value.data.asBytes()) as E\n  }\n  const filter: InkEventInterface<E>[\"filter\"] = (address, events = []) => {\n    const addrEq = (a: string | Binary) =>\n      (a instanceof Binary ? a.asHex() : a) === address\n\n    const contractEvents = events\n      .map((v) => (\"event\" in v ? v : { event: v, topics: v.topics }))\n      .filter(\n        (v) =>\n          (v.event.type === \"Contracts\" || v.event.type === \"Revive\") &&\n          (v.event.value as any).type === \"ContractEmitted\" &&\n          addrEq((v.event.value as any).value.contract),\n      )\n\n    return contractEvents\n      .map((v) => {\n        const eventTopics = [\n          ...v.topics,\n          ...((v.event.value as any)?.value?.topics ?? []),\n        ].map((evt) => evt.asHex())\n        const suitableTopic = eventTopics.find((topic) =>\n          metadataEventTopics.has(topic),\n        )\n        try {\n          return decode((v.event.value as any).value, suitableTopic)\n        } catch (ex) {\n          return null\n        }\n      })\n      .filter((v) => v !== null)\n  }\n\n  return {\n    decode,\n    filter,\n  }\n}\n"],"names":["getLookupCodecBuilder","_void","Struct","enhanceCodec","Variant","Binary","Tuple","Bytes","createCodec","ScaleEnum","Vector","Option","str","compactNumber","u32","u8","v14Lookup","denormalizeLookup","resolveType","path","inner"],"mappings":"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"}