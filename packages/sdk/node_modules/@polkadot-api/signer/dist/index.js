'use strict';

var utils = require('@polkadot-api/utils');
var signersCommon = require('@polkadot-api/signers-common');
var substrateBindings = require('@polkadot-api/substrate-bindings');
var merkleizeMetadata = require('@polkadot-api/merkleize-metadata');

function getPolkadotSigner(publicKey, signingType, sign) {
  const signTx = async (callData, signedExtensions, metadata, _, hasher = substrateBindings.Blake2256) => {
    const decMeta = substrateBindings.unifyMetadata(substrateBindings.decAnyMetadata(metadata));
    const extra = [];
    const additionalSigned = [];
    decMeta.extrinsic.signedExtensions.map(({ identifier }) => {
      const signedExtension = signedExtensions[identifier];
      if (!signedExtension)
        throw new Error(`Missing ${identifier} signed extension`);
      extra.push(signedExtension.value);
      additionalSigned.push(signedExtension.additionalSigned);
    });
    const toSign = utils.mergeUint8([callData, ...extra, ...additionalSigned]);
    const signed = await sign(toSign.length > 256 ? hasher(toSign) : toSign);
    return signersCommon.createV4Tx(decMeta, publicKey, signed, extra, callData, signingType);
  };
  return {
    publicKey,
    signTx,
    signBytes: signersCommon.getSignBytes(sign)
  };
}
const METADATA_IDENTIFIER = "CheckMetadataHash";
const oneU8 = Uint8Array.from([1]);
const withMetadataHash = (networkInfo, base) => ({
  ...base,
  signTx: async (callData, signedExtensions, metadata, ...rest) => base.signTx(
    callData,
    signedExtensions[METADATA_IDENTIFIER] ? {
      ...signedExtensions,
      [METADATA_IDENTIFIER]: {
        identifier: METADATA_IDENTIFIER,
        value: oneU8,
        additionalSigned: utils.mergeUint8([
          oneU8,
          merkleizeMetadata.merkleizeMetadata(metadata, networkInfo).digest()
        ])
      }
    } : signedExtensions,
    metadata,
    ...rest
  )
});

exports.getPolkadotSigner = getPolkadotSigner;
exports.withMetadataHash = withMetadataHash;
//# sourceMappingURL=index.js.map
