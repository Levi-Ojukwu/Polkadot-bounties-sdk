import { mergeUint8 } from '@polkadot-api/utils';
import { getSignBytes, createV4Tx } from '@polkadot-api/signers-common';
import { Blake2256, unifyMetadata, decAnyMetadata } from '@polkadot-api/substrate-bindings';
import { merkleizeMetadata } from '@polkadot-api/merkleize-metadata';

function getPolkadotSigner(publicKey, signingType, sign) {
  const signTx = async (callData, signedExtensions, metadata, _, hasher = Blake2256) => {
    const decMeta = unifyMetadata(decAnyMetadata(metadata));
    const extra = [];
    const additionalSigned = [];
    decMeta.extrinsic.signedExtensions.map(({ identifier }) => {
      const signedExtension = signedExtensions[identifier];
      if (!signedExtension)
        throw new Error(`Missing ${identifier} signed extension`);
      extra.push(signedExtension.value);
      additionalSigned.push(signedExtension.additionalSigned);
    });
    const toSign = mergeUint8([callData, ...extra, ...additionalSigned]);
    const signed = await sign(toSign.length > 256 ? hasher(toSign) : toSign);
    return createV4Tx(decMeta, publicKey, signed, extra, callData, signingType);
  };
  return {
    publicKey,
    signTx,
    signBytes: getSignBytes(sign)
  };
}
const METADATA_IDENTIFIER = "CheckMetadataHash";
const oneU8 = Uint8Array.from([1]);
const withMetadataHash = (networkInfo, base) => ({
  ...base,
  signTx: async (callData, signedExtensions, metadata, ...rest) => base.signTx(
    callData,
    signedExtensions[METADATA_IDENTIFIER] ? {
      ...signedExtensions,
      [METADATA_IDENTIFIER]: {
        identifier: METADATA_IDENTIFIER,
        value: oneU8,
        additionalSigned: mergeUint8([
          oneU8,
          merkleizeMetadata(metadata, networkInfo).digest()
        ])
      }
    } : signedExtensions,
    metadata,
    ...rest
  )
});

export { getPolkadotSigner, withMetadataHash };
//# sourceMappingURL=from-raw-signer.mjs.map
