import { SdkDefinition } from '@polkadot-api/common-sdk-utils';
import { Enum, TypedApi, PalletsTypedef, StorageDescriptor, Binary, SS58String, FixedSizeArray, TxDescriptor, TxCallData, PlainDescriptor, ApisTypedef, ChainDefinition, FixedSizeBinary, Transaction, TxEvent, DescriptorEntry } from 'polkadot-api';
import { Observable } from 'rxjs';

type WhoAmount = {
    who: SS58String;
    amount: bigint;
};
type BasicReferendumInfo = [
    number,
    WhoAmount | undefined,
    WhoAmount | undefined
];
type ExtendableEnum<T extends {}> = Enum<T> | {
    type: string;
    value: unknown;
};
type PolkadotRuntimeOriginCallerVariants = {
    system: ExtendableEnum<{
        Root: undefined;
    }>;
    Origins: ExtendableEnum<{
        Treasurer: undefined;
        SmallTipper: undefined;
        BigTipper: undefined;
        SmallSpender: undefined;
        MediumSpender: undefined;
        BigSpender: undefined;
    }>;
};
type PolkadotRuntimeOriginCallerOriginal = Enum<PolkadotRuntimeOriginCallerVariants>;
type PolkadotRuntimeOriginCaller = ExtendableEnum<PolkadotRuntimeOriginCallerVariants>;
type PreimagesBounded = Enum<{
    Legacy: {
        hash: Binary;
    };
    Inline: Binary;
    Lookup: {
        hash: Binary;
        len: number;
    };
}>;
type TraitsScheduleDispatchTime = Enum<{
    At: number;
    After: number;
}>;
type ReferendumInfo<TOrigin = unknown> = Enum<{
    Ongoing: {
        track: number;
        origin: TOrigin;
        proposal: PreimagesBounded;
        enactment: Enum<{
            At: number;
            After: number;
        }>;
        submitted: number;
        submission_deposit: WhoAmount;
        decision_deposit?: WhoAmount | undefined;
        deciding?: {
            since: number;
            confirming?: number | undefined;
        } | undefined;
        tally: {
            ayes: bigint;
            nays: bigint;
            support: bigint;
        };
        in_queue: boolean;
        alarm?: [number, FixedSizeArray<2, number>] | undefined;
    };
    Approved: BasicReferendumInfo;
    Rejected: BasicReferendumInfo;
    Cancelled: BasicReferendumInfo;
    TimedOut: BasicReferendumInfo;
    Killed: number;
}>;
type ReferendaTypesCurve = Enum<{
    LinearDecreasing: {
        length: number;
        floor: number;
        ceil: number;
    };
    SteppedDecreasing: {
        begin: number;
        end: number;
        step: number;
        period: number;
    };
    Reciprocal: {
        factor: bigint;
        x_offset: bigint;
        y_offset: bigint;
    };
}>;
type ReferendaTrackData = {
    name: string;
    max_deciding: number;
    decision_deposit: bigint;
    prepare_period: number;
    decision_period: number;
    confirm_period: number;
    min_enactment_period: number;
    min_approval: ReferendaTypesCurve;
    min_support: ReferendaTypesCurve;
};
type ReferendaSdkPallets<TOrigin> = PalletsTypedef<{
    Preimage: {
        PreimageFor: StorageDescriptor<[
            Key: [Binary, number]
        ], Binary, true, never>;
    };
    Referenda: {
        /**
         * Information concerning any given referendum.
         */
        ReferendumInfoFor: StorageDescriptor<[
            Key: number
        ], ReferendumInfo<TOrigin>, true, never>;
    };
    Balances: {
        TotalIssuance: StorageDescriptor<[], bigint, false, never>;
        InactiveIssuance: StorageDescriptor<[], bigint, false, never>;
    };
}, {
    Referenda: {
        submit: TxDescriptor<{
            proposal_origin: TOrigin;
            proposal: PreimagesBounded;
            enactment_moment: TraitsScheduleDispatchTime;
        }>;
    };
    Utility: {
        batch_all: TxDescriptor<{
            calls: Array<TxCallData>;
        }>;
    };
    Preimage: {
        note_preimage: TxDescriptor<{
            bytes: Binary;
        }>;
    };
}, {
    Referenda: {
        Submitted: PlainDescriptor<{
            index: number;
            track: number;
            proposal: PreimagesBounded;
        }>;
    };
}, {}, {
    Referenda: {
        Tracks: PlainDescriptor<Array<[number, ReferendaTrackData]>>;
    };
}, {}>;
type ReferendaSdkDefinition<TOrigin> = SdkDefinition<ReferendaSdkPallets<TOrigin>, ApisTypedef<{}>>;
type ReferendaSdkTypedApi<TOrigin = unknown> = TypedApi<ReferendaSdkDefinition<TOrigin>>;
type RuntimeOriginCaller<D> = D extends ChainDefinition ? D["descriptors"]["pallets"]["__tx"]["Referenda"]["submit"]["___"]["proposal_origin"] : Enum<Record<string, unknown>>;

declare const SpenderOrigin: {
    readonly Treasurer: "Treasurer";
    readonly SmallTipper: "SmallTipper";
    readonly BigTipper: "BigTipper";
    readonly SmallSpender: "SmallSpender";
    readonly MediumSpender: "MediumSpender";
    readonly BigSpender: "BigSpender";
};
type Origin = (typeof SpenderOrigin)[keyof typeof SpenderOrigin];
declare const polkadotSpenderOrigin: (value: bigint) => Origin | null;
declare const kusamaSpenderOrigin: (value: bigint) => Origin | null;

type BountiesBountyStatus = Enum<{
    Proposed: undefined;
    Approved: undefined;
    Funded: undefined;
    CuratorProposed: {
        curator: SS58String;
    };
    Active: {
        curator: SS58String;
        update_due: number;
    };
    PendingPayout: {
        curator: SS58String;
        beneficiary: SS58String;
        unlock_at: number;
    };
    ApprovedWithCurator: {
        curator: SS58String;
    };
}>;
interface BountyWithoutDescription {
    proposer: SS58String;
    value: bigint;
    fee: bigint;
    curator_deposit: bigint;
    bond: bigint;
    status: BountiesBountyStatus;
}
type BountiesSdkPallets<TOrigin> = PalletsTypedef<{
    Preimage: {
        PreimageFor: StorageDescriptor<[
            Key: [Binary, number]
        ], Binary, true, never>;
    };
    Bounties: {
        /**
         * Number of bounty proposals that have been made.
         */
        BountyCount: StorageDescriptor<[], number, false, never>;
        /**
         * Bounties that have been made.
         */
        Bounties: StorageDescriptor<[
            Key: number
        ], BountyWithoutDescription, true, never>;
        /**
         * The description of each bounty.
         */
        BountyDescriptions: StorageDescriptor<[Key: number], Binary, true, never>;
    };
    Scheduler: {
        /**
         * Items to be executed, indexed by the block number that they should be executed on.
         */
        Agenda: StorageDescriptor<[
            Key: number
        ], Array<{
            maybe_id?: FixedSizeBinary<32> | undefined;
            priority: number;
            call: PreimagesBounded;
            maybe_periodic?: FixedSizeArray<2, number> | undefined;
            origin: TOrigin;
        } | undefined>, false, never>;
    };
}, {
    Bounties: {
        approve_bounty: TxDescriptor<{
            bounty_id: number;
        }>;
        propose_curator: TxDescriptor<{
            bounty_id: number;
            curator: MultiAddress;
            fee: bigint;
        }>;
        unassign_curator: TxDescriptor<{
            bounty_id: number;
        }>;
        accept_curator: TxDescriptor<{
            bounty_id: number;
        }>;
        award_bounty: TxDescriptor<{
            bounty_id: number;
            beneficiary: MultiAddress;
        }>;
        claim_bounty: TxDescriptor<{
            bounty_id: number;
        }>;
        close_bounty: TxDescriptor<{
            bounty_id: number;
        }>;
        extend_bounty_expiry: TxDescriptor<{
            bounty_id: number;
            remark: Binary;
        }>;
    };
}, {
    Bounties: {
        /**
         *New bounty proposal.
         */
        BountyProposed: PlainDescriptor<{
            index: number;
        }>;
    };
}, {}, {}, {}>;
type BountiesSdkDefinition<TOrigin> = SdkDefinition<BountiesSdkPallets<TOrigin>, ApisTypedef<{}>>;
type BountiesSdkTypedApi<TOrigin = unknown> = TypedApi<BountiesSdkDefinition<TOrigin>>;
type MultiAddress = Enum<{
    Id: SS58String;
    Index: undefined;
    Raw: Binary;
    Address32: FixedSizeBinary<32>;
    Address20: FixedSizeBinary<20>;
}>;

type ConvictionVotingVoteAccountVote = Enum<{
    Standard: {
        vote: number;
        balance: bigint;
    };
    Split: {
        aye: bigint;
        nay: bigint;
    };
    SplitAbstain: {
        aye: bigint;
        nay: bigint;
        abstain: bigint;
    };
}>;
type VotingConviction = Enum<{
    None: undefined;
    Locked1x: undefined;
    Locked2x: undefined;
    Locked3x: undefined;
    Locked4x: undefined;
    Locked5x: undefined;
    Locked6x: undefined;
}>;
type ConvictionVotingVoteVoting = Enum<{
    Casting: {
        votes: Array<[number, ConvictionVotingVoteAccountVote]>;
        delegations: {
            votes: bigint;
            capital: bigint;
        };
        prior: [number, bigint];
    };
    Delegating: {
        balance: bigint;
        target: SS58String;
        conviction: VotingConviction;
        delegations: {
            votes: bigint;
            capital: bigint;
        };
        prior: [number, bigint];
    };
}>;
type VotingSdkPallets = PalletsTypedef<{
    ConvictionVoting: {
        VotingFor: StorageDescriptor<[
            SS58String,
            number
        ], ConvictionVotingVoteVoting, false, never>;
    };
}, {
    ConvictionVoting: {
        vote: TxDescriptor<{
            poll_index: number;
            vote: ConvictionVotingVoteAccountVote;
        }>;
        delegate: TxDescriptor<{
            class: number;
            to: MultiAddress;
            conviction: VotingConviction;
            balance: bigint;
        }>;
        undelegate: TxDescriptor<{
            class: number;
        }>;
        unlock: TxDescriptor<{
            class: number;
            target: MultiAddress;
        }>;
        remove_vote: TxDescriptor<{
            class: number | undefined;
            index: number;
        }>;
    };
}, {}, {}, {
    ConvictionVoting: {
        VoteLockingPeriod: PlainDescriptor<number>;
    };
}, {}>;
type VotingSdkDefinition = SdkDefinition<VotingSdkPallets, ApisTypedef<{}>>;
type VotingSdkTypedApi = TypedApi<VotingSdkDefinition>;

type PollOutcome = {
    ended: number;
    side: "aye" | "nay";
} | null;
/**
 * Types:
 * - free: The funds locked by this vote will become free once the vote is removed.
 * - locked: The funds locked by this vote will become locked once the vote is removed.
 * - extends: Removing this vote will extend the duration of a pre-existing lock.
 * - extended: Removing this vote before its end will have it locked for the duration of the pre-existing lock.
 */
type VoteLock = {
    type: "free";
} | {
    type: "locked" | "extends" | "extended";
    end: number;
};
interface CommonVote {
    poll: number;
    balance: bigint;
    getLock(outcome: PollOutcome): VoteLock;
    remove(): Transaction<any, string, string, unknown>;
}
interface StandardVote extends CommonVote {
    type: "standard";
    direction: "aye" | "nay" | "abstain";
    conviction: VotingConviction;
}
interface SplitVote extends CommonVote {
    type: "split";
    aye: bigint;
    nay: bigint;
    abstain: bigint;
}
type Vote = StandardVote | SplitVote;
interface TrackDetails {
    track: number;
    delegationPower: DelegationPower;
    lock: {
        block: number;
        balance: bigint;
    } | null;
    unlock(): Transaction<any, string, string, unknown>;
}
type UnlockSchedule = Array<{
    block: number;
    balance: bigint;
    unlocks: Array<{
        type: "poll";
        id: number;
    } | {
        type: "lock";
    }>;
}>;
interface TrackCasting extends TrackDetails {
    type: "casting";
    votes: Vote[];
    getUnlockSchedule(pollOutcomes: Record<number, PollOutcome>): UnlockSchedule;
}
interface TrackDelegating extends TrackDetails {
    type: "delegating";
    target: SS58String;
    balance: bigint;
    conviction: VotingConviction;
    lockDuration: number;
    remove(): Transaction<any, string, string, unknown>;
}
type VotingTrack = TrackCasting | TrackDelegating;
interface DelegationPower {
    track: number;
    votes: bigint;
    capital: bigint;
}
interface ConvictionVotingSdk {
    getVotingTracks(account: SS58String): Promise<Array<VotingTrack>>;
    getVotingTrack(account: SS58String, track: number): Promise<VotingTrack>;
    votingTracks$(account: SS58String): Observable<Array<VotingTrack>>;
    votingTrack$(account: SS58String, track: number): Observable<VotingTrack>;
    vote(vote: "aye" | "nay", poll: number, value: bigint, conviction?: VotingConviction): Transaction<any, string, string, unknown>;
    voteAbstain(poll: number, value: bigint): Transaction<any, string, string, unknown>;
    voteSplit(poll: number, vote: Partial<{
        aye: bigint;
        nay: bigint;
        abstain: bigint;
    }>): Transaction<any, string, string, unknown>;
}

type RawOngoingReferendum<T> = (ReferendumInfo<T> & {
    type: "Ongoing";
})["value"];
interface ReferendumDetails {
    title?: string;
}
type OngoingReferendum<T extends {
    origin: unknown;
} = {
    origin: unknown;
}> = Omit<RawOngoingReferendum<T["origin"]>, "proposal"> & {
    type: "Ongoing";
    id: number;
    proposal: {
        rawValue: PreimagesBounded;
        resolve: () => Promise<Binary>;
        decodedCall: () => Promise<{
            type: string;
            value: {
                type: string;
                value: any;
            };
        }>;
    };
    getDetails: (apiKey: string) => Promise<ReferendumDetails>;
    getConfirmationStart: () => Promise<number | null>;
    getConfirmationEnd: () => Promise<number | null>;
    getTrack: () => Promise<ReferendaTrack>;
    outcome: PollOutcome;
    getExpectedOutcome: () => Promise<PollOutcome>;
};
interface ClosedReferendum {
    type: "Approved" | "Rejected" | "Cancelled" | "TimedOut" | "Killed";
    outcome: PollOutcome;
    block: number;
    submission_deposit: WhoAmount | undefined;
    decision_deposit: WhoAmount | undefined;
}
type Referendum<TEnums extends {
    origin: unknown;
} = {
    origin: unknown;
}> = OngoingReferendum<TEnums> | ClosedReferendum;
interface ReferendaSdkConfig {
    spenderOrigin: (value: bigint) => Origin | null;
}
/**
 * threshold are in perbillion
 */
interface TrackFunctionDetails {
    curve: ReferendaTypesCurve;
    getThreshold(block: number): bigint;
    getBlock(threshold: bigint): number;
    getData(step?: number): Array<{
        block: number;
        threshold: number;
    }>;
}
type ReferendaTrack = Omit<ReferendaTrackData, "min_approval" | "min_support"> & {
    minApproval: TrackFunctionDetails;
    minSupport: TrackFunctionDetails;
};
interface ReferendaSdk<TEnums extends {
    origin: unknown;
} = {
    origin: unknown;
}> {
    getReferenda(): Promise<Referendum<TEnums>[]>;
    getReferendum(id: number): Promise<Referendum<TEnums> | null>;
    watch: {
        referenda$: Observable<Map<number, Referendum<TEnums>>>;
        referendaIds$: Observable<number[]>;
        getReferendumById$: (key: number) => Observable<Referendum<TEnums>>;
    };
    getSpenderTrack(value: bigint): {
        origin: TEnums["origin"];
        track: Promise<ReferendaTrack>;
    };
    getTrack(id: number | string): Promise<ReferendaTrack | null>;
    createReferenda(origin: TEnums["origin"], proposal: Binary, options?: Partial<{
        enactment: TraitsScheduleDispatchTime;
    }>): Transaction<any, string, string, unknown>;
    createSpenderReferenda(callData: Binary, value: bigint): Transaction<any, string, string, unknown>;
    getSubmittedReferendum(txEvent: TxEvent): {
        index: number;
        track: number;
        proposal: PreimagesBounded;
    } | null;
}

declare function createReferendaSdk<TOrigin extends PolkadotRuntimeOriginCaller>(typedApi: ReferendaSdkTypedApi<TOrigin>, config?: Partial<ReferendaSdkConfig>): ReferendaSdk<{
    origin: TOrigin;
}>;

interface GenericBounty extends BountyWithoutDescription {
    type: BountiesBountyStatus["type"];
    id: number;
    description: string | null;
    account: SS58String;
}
interface ClosableBounty$1 {
    close(): Transaction<any, string, string, unknown>;
}
interface ProposedBounty<TEnums extends {
    origin: unknown;
} = {
    origin: unknown;
}> extends GenericBounty, ClosableBounty$1 {
    type: "Proposed";
    approve(): Transaction<any, string, string, unknown>;
    filterApprovingReferenda(referenda: OngoingReferendum<TEnums>[]): Promise<Array<{
        referendum: OngoingReferendum<TEnums>;
        proposeCuratorCalls: {
            curator: MultiAddress;
            fee: bigint;
        }[];
    }>>;
    getScheduledApprovals(): Promise<number[]>;
}
interface ApprovedBounty extends GenericBounty {
    type: "Approved" | "ApprovedWithCurator";
}
interface FundedBounty<TEnums extends {
    origin: unknown;
} = {
    origin: unknown;
}> extends GenericBounty, ClosableBounty$1 {
    type: "Funded";
    proposeCurator(curator: SS58String, fee: bigint): Transaction<any, string, string, unknown>;
    filterProposingReferenda(referenda: OngoingReferendum<TEnums>[]): Promise<Array<{
        referendum: OngoingReferendum<TEnums>;
        proposeCuratorCalls: {
            curator: MultiAddress;
            fee: bigint;
        }[];
    }>>;
    getScheduledProposals(): Promise<Array<{
        height: number;
        proposeCuratorCalls: {
            curator: MultiAddress;
            fee: bigint;
        }[];
    }>>;
}
interface CuratorUnassignable$1 {
    unassignCurator(): Transaction<any, string, string, unknown>;
}
interface CuratorProposedBounty extends GenericBounty, CuratorUnassignable$1, ClosableBounty$1 {
    type: "CuratorProposed";
    curator: SS58String;
    acceptCuratorRole(): Transaction<any, string, string, unknown>;
}
interface ActiveBounty extends GenericBounty, CuratorUnassignable$1, ClosableBounty$1 {
    type: "Active";
    curator: SS58String;
    updateDue: number;
    extendExpiry(remark?: string): Transaction<any, string, string, unknown>;
    award(beneficiary: SS58String): Transaction<any, string, string, unknown>;
}
interface PendingPayoutBounty extends GenericBounty, CuratorUnassignable$1 {
    type: "PendingPayout";
    curator: SS58String;
    beneficiary: SS58String;
    unlockAt: number;
    claim(): Transaction<any, string, string, unknown>;
}
type Bounty<TEnums extends {
    origin: unknown;
} = {
    origin: unknown;
}> = ProposedBounty<TEnums> | ApprovedBounty | FundedBounty<TEnums> | CuratorProposedBounty | ActiveBounty | PendingPayoutBounty;
interface BountiesSdk<TEnums extends {
    origin: unknown;
} = {
    origin: unknown;
}> {
    watch: {
        bounties$: Observable<Map<number, Bounty<TEnums>>>;
        bountyIds$: Observable<number[]>;
        getBountyById$: (key: number) => Observable<Bounty<TEnums>>;
    };
    getBounty(id: number): Promise<Bounty<TEnums> | null>;
    getBounties(): Promise<Bounty<TEnums>[]>;
    getProposedBounty(txEvent: TxEvent): Promise<ProposedBounty<TEnums> | null>;
}

declare function createBountiesSdk<TOrigin extends PolkadotRuntimeOriginCaller>(typedApi: BountiesSdkTypedApi<TOrigin>): BountiesSdk<{
    origin: TOrigin;
}>;

type BountiesChildBountyStatus = Enum<{
    Added: undefined;
    CuratorProposed: {
        curator: SS58String;
    };
    Active: {
        curator: SS58String;
    };
    PendingPayout: {
        curator: SS58String;
        beneficiary: SS58String;
        unlock_at: number;
    };
}>;
interface ChildBountyWithoutDescription {
    parent_bounty: number;
    value: bigint;
    fee: bigint;
    curator_deposit: bigint;
    status: BountiesChildBountyStatus;
}
type ChildBountiesV0Storage = {
    ChildBounties: {
        /**
         * Child bounties that have been added.
         */
        ChildBounties: StorageDescriptor<FixedSizeArray<2, number>, ChildBountyWithoutDescription, true, never>;
        /**
         * The description of each child-bounty.
         */
        ChildBountyDescriptions: StorageDescriptor<[
            Key: number
        ], Binary, true, never>;
    };
};
type ChildBountiesV1Storage = {
    ChildBounties: {
        /**
         * Child bounties that have been added.
         */
        ChildBounties: StorageDescriptor<FixedSizeArray<2, number>, ChildBountyWithoutDescription, true, never>;
        /**
         * The description of each child-bounty.
         */
        ChildBountyDescriptionsV1: StorageDescriptor<FixedSizeArray<2, number>, Binary, true, never>;
    };
};
type ChildBountiesSdkPallets<St extends DescriptorEntry<StorageDescriptor<any, any, any, any>>> = PalletsTypedef<St, {
    ChildBounties: {
        add_child_bounty: TxDescriptor<{
            parent_bounty_id: number;
            value: bigint;
            description: Binary;
        }>;
        propose_curator: TxDescriptor<{
            parent_bounty_id: number;
            child_bounty_id: number;
            curator: MultiAddress;
            fee: bigint;
        }>;
        accept_curator: TxDescriptor<{
            parent_bounty_id: number;
            child_bounty_id: number;
        }>;
        unassign_curator: TxDescriptor<{
            parent_bounty_id: number;
            child_bounty_id: number;
        }>;
        award_child_bounty: TxDescriptor<{
            parent_bounty_id: number;
            child_bounty_id: number;
            beneficiary: MultiAddress;
        }>;
        claim_child_bounty: TxDescriptor<{
            parent_bounty_id: number;
            child_bounty_id: number;
        }>;
        close_child_bounty: TxDescriptor<{
            parent_bounty_id: number;
            child_bounty_id: number;
        }>;
    };
}, {}, {}, {}, {}>;
type ChildBountiesSdkDefinition<St extends DescriptorEntry<StorageDescriptor<any, any, any, any>>> = SdkDefinition<ChildBountiesSdkPallets<St>, ApisTypedef<{}>>;
type ChildBountiesSdkTypedApi<St extends DescriptorEntry<StorageDescriptor<any, any, any, any>> = ChildBountiesV0Storage | ChildBountiesV1Storage> = TypedApi<ChildBountiesSdkDefinition<St>>;

interface GenericChildBounty extends ChildBountyWithoutDescription {
    type: BountiesChildBountyStatus["type"];
    id: number;
    description: string | null;
    account: SS58String;
}
interface ClosableBounty {
    close(): Transaction<any, string, string, unknown>;
}
interface AddedChildBounty extends GenericChildBounty, ClosableBounty {
    type: "Added";
    proposeCurator(curator: SS58String, fee: bigint): Transaction<any, string, string, unknown>;
}
interface CuratorUnassignable {
    unassignCurator(): Transaction<any, string, string, unknown>;
}
interface CuratorProposedChildBounty extends GenericChildBounty, CuratorUnassignable, ClosableBounty {
    type: "CuratorProposed";
    curator: SS58String;
    acceptCuratorRole(): Transaction<any, string, string, unknown>;
}
interface ActiveChildBounty extends GenericChildBounty, CuratorUnassignable, ClosableBounty {
    type: "Active";
    curator: SS58String;
    award(beneficiary: SS58String): Transaction<any, string, string, unknown>;
}
interface PendingPayoutChildBounty extends GenericChildBounty, CuratorUnassignable {
    type: "PendingPayout";
    curator: SS58String;
    beneficiary: SS58String;
    unlockAt: number;
    claim(): Transaction<any, string, string, unknown>;
}
type ChildBounty = AddedChildBounty | CuratorProposedChildBounty | ActiveChildBounty | PendingPayoutChildBounty;
interface ChildBountiesSdk {
    watch(parentId: number): {
        bounties$: Observable<Map<number, ChildBounty>>;
        bountyIds$: Observable<number[]>;
        getBountyById$: (key: number) => Observable<ChildBounty>;
    };
    getChildBounty(parentId: number, id: number): Promise<ChildBounty | null>;
    getChildBounties(parentId: number): Promise<ChildBounty[]>;
}

declare function createChildBountiesSdk(typedApi: ChildBountiesSdkTypedApi): ChildBountiesSdk;

declare function createConvictionVotingSdk(typedApi: VotingSdkTypedApi): ConvictionVotingSdk;

export { createBountiesSdk, createChildBountiesSdk, createConvictionVotingSdk, createReferendaSdk, kusamaSpenderOrigin, polkadotSpenderOrigin };
export type { ActiveBounty, ActiveChildBounty, AddedChildBounty, ApprovedBounty, BountiesBountyStatus, BountiesChildBountyStatus, BountiesSdk, BountiesSdkTypedApi, Bounty, BountyWithoutDescription, ChildBountiesSdk, ChildBountiesSdkTypedApi, ChildBountiesV0Storage, ChildBountiesV1Storage, ChildBounty, ChildBountyWithoutDescription, ClosedReferendum, ConvictionVotingSdk, ConvictionVotingVoteAccountVote, ConvictionVotingVoteVoting, CuratorProposedBounty, CuratorProposedChildBounty, DelegationPower, FundedBounty, GenericBounty, GenericChildBounty, MultiAddress, OngoingReferendum, Origin, PendingPayoutBounty, PendingPayoutChildBounty, PolkadotRuntimeOriginCaller, PolkadotRuntimeOriginCallerOriginal, PollOutcome, PreimagesBounded, ProposedBounty, ReferendaSdk, ReferendaSdkConfig, ReferendaSdkTypedApi, ReferendaTrack, ReferendaTrackData, ReferendaTypesCurve, Referendum, ReferendumDetails, ReferendumInfo, RuntimeOriginCaller, SplitVote, StandardVote, TrackCasting, TrackDelegating, TrackFunctionDetails, TraitsScheduleDispatchTime, UnlockSchedule, Vote, VoteLock, VotingConviction, VotingSdkTypedApi, VotingTrack, WhoAmount };
