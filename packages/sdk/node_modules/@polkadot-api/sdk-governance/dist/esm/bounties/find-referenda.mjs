import { keyedMemo } from '../util/memo.mjs';

const spenderOrigins = [
  "Treasurer",
  "SmallSpender",
  "MediumSpender",
  "BigSpender",
  "SmallTipper",
  "BigTipper"
];
const uncachedGetDecodedSpenderReferenda = async (ongoingReferenda) => {
  const spenderReferenda = ongoingReferenda.filter((ref) => {
    const origin = ref.origin;
    return origin.type === "Origins" && spenderOrigins.includes(origin.value.type) || origin.type === "system" && origin.value.type === "Root";
  });
  const response = await Promise.all(
    spenderReferenda.map(
      (referendum) => referendum.proposal.decodedCall().then((call) => ({
        referendum,
        call
      })).catch((ex) => {
        console.error(ex);
        return null;
      })
    )
  );
  return response.filter((v) => !!v);
};
const getDecodedSpenderReferenda = keyedMemo(uncachedGetDecodedSpenderReferenda, /* @__PURE__ */ new WeakMap());
const filterApproveCuratorCalls = (calls, bountyId) => calls.filter(
  (v) => v?.bounty_id === bountyId && typeof v.curator === "object" && typeof v.fee === "bigint"
).map((v) => ({
  curator: v.curator,
  fee: v.fee
}));
async function findApprovingReferenda(ongoingReferenda, bountyId) {
  const spenderReferenda = await getDecodedSpenderReferenda(ongoingReferenda);
  return spenderReferenda.map(({ call, referendum }) => {
    const approveWithCuratorCalls = filterApproveCuratorCalls(
      findCalls(
        {
          pallet: "Bounties",
          name: "approve_bounty_with_curator"
        },
        call
      ),
      bountyId
    );
    const approveCalls = findCalls(
      {
        pallet: "Bounties",
        name: "approve_bounty"
      },
      call
    ).filter((v) => v?.bounty_id === bountyId);
    const approveThenProposeCalls = approveCalls.length ? filterApproveCuratorCalls(
      findCalls(
        {
          pallet: "Bounties",
          name: "propose_curator"
        },
        call
      ),
      bountyId
    ) : [];
    if (!(approveCalls.length + approveWithCuratorCalls.length)) return null;
    return {
      referendum,
      proposeCuratorCalls: [
        ...approveWithCuratorCalls,
        ...approveThenProposeCalls
      ]
    };
  }).filter((v) => v !== null);
}
async function findProposingCuratorReferenda(ongoingReferenda, bountyId) {
  const spenderReferenda = await getDecodedSpenderReferenda(ongoingReferenda);
  return spenderReferenda.map(({ call, referendum }) => {
    const proposeCuratorCalls = filterApproveCuratorCalls(
      findCalls(
        {
          pallet: "Bounties",
          name: "propose_curator"
        },
        call
      ),
      bountyId
    );
    if (!proposeCuratorCalls.length) return null;
    return { referendum, proposeCuratorCalls };
  }).filter((v) => v !== null);
}
const findCalls = (call, obj) => {
  if (typeof obj !== "object") return [];
  if (Array.isArray(obj)) {
    const approves2 = [];
    for (const item of obj) approves2.push(...findCalls(call, item));
    return approves2;
  }
  if (obj?.type === call.pallet && obj?.value?.type === call.name) {
    return [obj.value.value];
  }
  const approves = [];
  for (const key of Object.keys(obj))
    approves.push(...findCalls(call, obj[key]));
  return approves;
};

export { findApprovingReferenda, findCalls, findProposingCuratorReferenda };
//# sourceMappingURL=find-referenda.mjs.map
