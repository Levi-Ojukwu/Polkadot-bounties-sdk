import { keyedMemo } from '../util/memo.mjs';
import { partitionEntries } from '../util/watchEntries.mjs';
import { toKeySet, combineKeys } from '@react-rxjs/utils';
import { CompatibilityLevel } from 'polkadot-api';
import { map, combineLatest, distinctUntilChanged } from 'rxjs';
import { getChildBountyAccount } from './bounty-account.mjs';
import { getBountyDescriptions$ } from './bounty-descriptions.mjs';

function createChildBountiesSdk(typedApi) {
  const enhanceBounty = (bounty, description, id) => {
    const generic = {
      ...bounty,
      type: bounty.status.type,
      id,
      description,
      account: getChildBountyAccount(bounty.parent_bounty, id)
    };
    const idObj = {
      parent_bounty_id: bounty.parent_bounty,
      child_bounty_id: id
    };
    switch (generic.status.type) {
      case "Added":
        return {
          ...generic,
          type: "Added",
          proposeCurator(curator, fee) {
            return typedApi.tx.ChildBounties.propose_curator({
              ...idObj,
              curator: {
                type: "Id",
                value: curator
              },
              fee
            });
          },
          close() {
            return typedApi.tx.ChildBounties.close_child_bounty(idObj);
          }
        };
      case "CuratorProposed":
        return {
          ...generic,
          ...generic.status.value,
          type: "CuratorProposed",
          acceptCuratorRole() {
            return typedApi.tx.ChildBounties.accept_curator(idObj);
          },
          unassignCurator() {
            return typedApi.tx.ChildBounties.unassign_curator(idObj);
          },
          close() {
            return typedApi.tx.ChildBounties.close_child_bounty(idObj);
          }
        };
      case "Active":
        return {
          ...generic,
          type: "Active",
          curator: generic.status.value.curator,
          award(beneficiary) {
            return typedApi.tx.ChildBounties.award_child_bounty({
              ...idObj,
              beneficiary: {
                type: "Id",
                value: beneficiary
              }
            });
          },
          unassignCurator() {
            return typedApi.tx.ChildBounties.unassign_curator(idObj);
          },
          close() {
            return typedApi.tx.ChildBounties.close_child_bounty(idObj);
          }
        };
      case "PendingPayout":
        return {
          ...generic,
          type: "PendingPayout",
          curator: generic.status.value.curator,
          unlockAt: generic.status.value.unlock_at,
          beneficiary: generic.status.value.beneficiary,
          claim() {
            return typedApi.tx.ChildBounties.claim_child_bounty(idObj);
          },
          unassignCurator() {
            return typedApi.tx.ChildBounties.unassign_curator(idObj);
          }
        };
    }
    throw new Error("Unreachable");
  };
  function watchChildBounties(parentId) {
    const [getBountyById$, bountyKeyChanges$] = partitionEntries(
      typedApi.query.ChildBounties.ChildBounties.watchEntries(parentId)
    );
    const v0Api = typedApi;
    const v1Api = typedApi;
    const getEntries = async () => {
      if (await v0Api.query.ChildBounties.ChildBountyDescriptions.isCompatible(
        CompatibilityLevel.Partial
      )) {
        return v0Api.query.ChildBounties.ChildBountyDescriptions.getEntries();
      }
      const result = await v1Api.query.ChildBounties.ChildBountyDescriptionsV1.getEntries(
        parentId
      );
      return result.map((r) => ({
        keyArgs: [r.keyArgs[1]],
        value: r.value
      }));
    };
    const getValues = async (keys) => {
      if (await v0Api.query.ChildBounties.ChildBountyDescriptions.isCompatible(
        CompatibilityLevel.Partial
      )) {
        return v0Api.query.ChildBounties.ChildBountyDescriptions.getValues(keys);
      }
      return v1Api.query.ChildBounties.ChildBountyDescriptionsV1.getValues(
        keys.map(([key]) => [parentId, key])
      );
    };
    const descriptions$ = getBountyDescriptions$(
      getEntries,
      getValues,
      bountyKeyChanges$
    );
    const bountyIds$ = bountyKeyChanges$.pipe(
      toKeySet(),
      map((set) => [...set])
    );
    const getEnhancedBountyById$ = (id) => combineLatest([
      getBountyById$(id),
      descriptions$.pipe(
        map((r) => r[id] ?? null),
        distinctUntilChanged()
      )
    ]).pipe(
      map(([bounty, description]) => enhanceBounty(bounty, description, id))
    );
    return {
      bounties$: combineKeys(bountyIds$, getEnhancedBountyById$),
      getBountyById$: getEnhancedBountyById$,
      bountyIds$
    };
  }
  function getChildBounty(parentId, id) {
    const v0Api = typedApi;
    const v1Api = typedApi;
    return Promise.all([
      typedApi.query.ChildBounties.ChildBounties.getValue(parentId, id),
      v1Api.query.ChildBounties.ChildBountyDescriptionsV1.isCompatible(
        CompatibilityLevel.Partial
      ).then(
        (isCompat) => isCompat ? v1Api.query.ChildBounties.ChildBountyDescriptionsV1.getValue(
          parentId,
          id
        ) : v0Api.query.ChildBounties.ChildBountyDescriptions.getValue(id)
      ).then((r) => r ? r.asText() : null)
    ]).then(
      ([bounty, description]) => bounty ? enhanceBounty(bounty, description, id) : null
    );
  }
  function getChildBounties(parentId) {
    const v0Api = typedApi;
    const v1Api = typedApi;
    return Promise.all([
      typedApi.query.ChildBounties.ChildBounties.getEntries(parentId),
      v1Api.query.ChildBounties.ChildBountyDescriptionsV1.isCompatible(
        CompatibilityLevel.Partial
      ).then(
        (isCompat) => isCompat ? v1Api.query.ChildBounties.ChildBountyDescriptionsV1.getEntries(
          parentId
        ).then(
          (r) => r.map(({ keyArgs, value }) => ({
            keyArgs: [keyArgs[1]],
            value
          }))
        ) : v0Api.query.ChildBounties.ChildBountyDescriptions.getEntries()
      )
    ]).then(([entries, descriptions]) => {
      const descriptionMap = Object.fromEntries(
        descriptions.map(({ keyArgs, value }) => [keyArgs[0], value.asText()])
      );
      return entries.map(({ keyArgs: [, id], value }) => ({ bounty: value, id })).sort((a, b) => a.id - b.id).map(
        ({ bounty, id }) => enhanceBounty(bounty, descriptionMap[id] ?? null, id)
      );
    });
  }
  const watch = keyedMemo(
    watchChildBounties,
    /* @__PURE__ */ new Map()
  );
  return {
    watch,
    getChildBounty,
    getChildBounties
  };
}

export { createChildBountiesSdk };
//# sourceMappingURL=child-bounties-sdk.mjs.map
