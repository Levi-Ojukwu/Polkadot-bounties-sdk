{"version":3,"file":"index.js","sources":["../src/codecs.ts","../src/get-accessible-types.ts","../src/get-lookup.ts","../src/get-metadata.ts","../src/utils.ts","../src/decode-and-collect.ts","../src/proof.ts","../src/main.ts"],"sourcesContent":["import {\n  Bytes,\n  Codec,\n  CodecType,\n  Option,\n  ScaleEnum,\n  Struct,\n  Tuple,\n  V14Lookup,\n  Vector,\n  _void,\n  bool,\n  compact,\n  compactNumber,\n  extrinsicFormat,\n  str,\n  u16,\n  u32,\n  u8,\n} from \"@polkadot-api/substrate-bindings\"\n\nconst extraInfoInner = {\n  specVersion: u32,\n  specName: str,\n  base58Prefix: u16,\n  decimals: u8,\n  tokenSymbol: str,\n}\nexport const extraInfo = Struct(extraInfoInner)\nexport type ExtraInfo = CodecType<typeof extraInfo>\n\nexport const hash = Bytes(32)\nexport const metadataDigest = ScaleEnum({\n  V0: _void,\n  V1: Struct({\n    typeInformationTreeRoot: hash,\n    extrinsicMetadataHash: hash,\n    ...extraInfoInner,\n  }),\n})\nexport type MetadataDigest = CodecType<typeof metadataDigest>\n\nexport const scalePrimitive = ScaleEnum({\n  bool: _void,\n  char: _void,\n  str: _void,\n  u8: _void,\n  u16: _void,\n  u32: _void,\n  u64: _void,\n  u128: _void,\n  u256: _void,\n  i8: _void,\n  i16: _void,\n  i32: _void,\n  i64: _void,\n  i128: _void,\n  i256: _void,\n})\nexport type ScalePrimitive = CodecType<typeof scalePrimitive>\n\nexport const typeRef = ScaleEnum({\n  bool: _void,\n  char: _void,\n  str: _void,\n  u8: _void,\n  u16: _void,\n  u32: _void,\n  u64: _void,\n  u128: _void,\n  u256: _void,\n  i8: _void,\n  i16: _void,\n  i32: _void,\n  i64: _void,\n  i128: _void,\n  i256: _void,\n  compactU8: _void,\n  compactU16: _void,\n  compactU32: _void,\n  compactU64: _void,\n  compactU128: _void,\n  compactU256: _void,\n  void: _void,\n  perId: compactNumber,\n})\nexport type TypeRef = CodecType<typeof typeRef>\n\nconst field = Struct({\n  name: Option(str),\n  ty: typeRef,\n  typeName: Option(str),\n})\nexport const typeDef = ScaleEnum({\n  composite: Vector(field),\n  enumeration: Struct({\n    name: str,\n    fields: Vector(field),\n    index: compactNumber,\n  }),\n  sequence: typeRef,\n  array: Struct({\n    len: u32,\n    typeParam: typeRef,\n  }),\n  tuple: Vector(typeRef),\n  bitSequence: Struct({\n    numBytes: u8,\n    leastSignificantBitFirst: bool,\n  }),\n})\nexport type TypeDef = CodecType<typeof typeDef>\n\nexport const lookupType = Struct({\n  path: Vector(str),\n  typeDef: typeDef,\n  typeId: compactNumber,\n})\nexport type LookupEntry = CodecType<typeof lookupType>\nexport type Lookup = Array<LookupEntry>\nexport const lookup: Codec<Lookup> = Vector(lookupType)\n\nexport const extrinsicMetadata = Struct({\n  version: u8,\n  addressTy: typeRef,\n  callTy: typeRef,\n  signatureTy: typeRef,\n  signedExtensions: Vector(\n    Struct({\n      identifier: str,\n      includedInExtrinsic: typeRef,\n      includedInSignedData: typeRef,\n    }),\n  ),\n})\nexport type ExtrinsicMetadata = CodecType<typeof extrinsicMetadata>\nexport type LookupValue = V14Lookup[number]\n\nexport const extrinsicDec = Tuple.dec(\n  compact[1],\n  extrinsicFormat[1],\n  Bytes(Infinity)[1],\n)\n\nexport const proof = Struct({\n  leaves: lookup,\n  leafIdxs: Vector(u32),\n  proofs: Vector(hash),\n  extrinsic: extrinsicMetadata,\n  info: extraInfo,\n})\nexport type Proof = CodecType<typeof proof>\n","import { UnifiedMetadata } from \"@polkadot-api/substrate-bindings\"\nimport { LookupValue } from \"./codecs\"\n\nexport const getAccessibleTypes = (\n  metadata: UnifiedMetadata<15 | 16>,\n  definitions: Map<number, LookupValue>,\n): Map<number, number> => {\n  const types = new Set<number>()\n\n  const collectTypesFromId = (id: number) => {\n    if (types.has(id)) return\n\n    const { tag, value } = definitions.get(id)!.def\n    switch (tag) {\n      case \"composite\":\n        if (!value.length) break\n        types.add(id)\n        value.forEach(({ type }) => {\n          collectTypesFromId(type)\n        })\n        break\n      case \"variant\":\n        if (!value.length) break\n        types.add(id)\n        value.forEach(({ fields }) => {\n          fields.forEach(({ type }) => {\n            collectTypesFromId(type)\n          })\n        })\n        break\n      case \"tuple\":\n        if (!value.length) break\n        types.add(id)\n        value.forEach(collectTypesFromId)\n        break\n      case \"sequence\":\n        types.add(id)\n        collectTypesFromId(value)\n        break\n      case \"array\":\n        types.add(id)\n        collectTypesFromId(value.type)\n        break\n      case \"bitSequence\": // bitSequence inner types are not stored\n        types.add(id)\n      // primitive and compact are not stored\n    }\n  }\n\n  collectTypesFromId(metadata.extrinsic.call)\n  collectTypesFromId(metadata.extrinsic.address)\n  collectTypesFromId(metadata.extrinsic.signature)\n  metadata.extrinsic.signedExtensions.forEach(({ type, additionalSigned }) => {\n    collectTypesFromId(type)\n    collectTypesFromId(additionalSigned)\n  })\n\n  const sortedTypes = [...types].sort((a, b) => a - b)\n  return new Map(sortedTypes.map((value, idx) => [value, idx]))\n}\n","import { Lookup, LookupValue, ScalePrimitive, TypeDef, TypeRef } from \"./codecs\"\n\nconst bitSequenceBytes = {\n  u8: 1,\n  u16: 2,\n  u32: 4,\n  u64: 8,\n}\n\nconst constructTypeDef = (\n  definitions: Map<number, LookupValue>,\n  getTypeRef: (frameId: number) => TypeRef,\n  getPrimitive: (frameId: number) => ScalePrimitive[\"tag\"] | null,\n  frameId: number,\n): TypeDef[] => {\n  const {\n    def: { tag, value },\n  } = definitions.get(frameId)!\n  switch (tag) {\n    case \"composite\":\n      return [\n        {\n          tag,\n          value: value.map((f) => ({\n            name: f.name,\n            typeName: f.typeName,\n            ty: getTypeRef(f.type),\n          })),\n        },\n      ]\n    case \"variant\": {\n      return value.map((v) => ({\n        tag: \"enumeration\",\n        value: {\n          name: v.name,\n          index: v.index,\n          fields: v.fields.map((f) => ({\n            name: f.name,\n            typeName: f.typeName,\n            ty: getTypeRef(f.type),\n          })),\n        },\n      }))\n    }\n    case \"sequence\":\n      return [\n        {\n          tag,\n          value: getTypeRef(value),\n        },\n      ]\n    case \"array\":\n      return [\n        {\n          tag,\n          value: {\n            len: value.len,\n            typeParam: getTypeRef(value.type),\n          },\n        },\n      ]\n    case \"tuple\":\n      return [\n        {\n          tag,\n          value: value.map(getTypeRef),\n        },\n      ]\n    case \"bitSequence\": {\n      const primitive = getPrimitive(value.bitStoreType)\n      const numBytes = bitSequenceBytes[primitive as \"u8\"]\n      if (!numBytes) throw new Error(\"Invalid primitive for BitSequence\")\n\n      const storeOrderPath = definitions.get(value.bitOrderType)!.path\n      const leastSignificantBitFirst = storeOrderPath.includes(\"Lsb0\")\n      if (!leastSignificantBitFirst && !storeOrderPath.includes(\"Msb0\"))\n        throw new Error(\"BitOrderType not recognized\")\n\n      return [\n        {\n          tag: \"bitSequence\",\n          value: { numBytes, leastSignificantBitFirst },\n        },\n      ]\n    }\n  }\n\n  throw new Error(`FrameId(${frameId}) should have been filtered out`)\n}\n\nexport const getLookup = (\n  definitions: Map<number, LookupValue>,\n  accessibleTypes: Map<number, number>,\n  getTypeRef: (frameId: number) => TypeRef,\n  getPrimitive: (frameId: number) => ScalePrimitive[\"tag\"] | null,\n) => {\n  const typeTree: Lookup = []\n  ;[...accessibleTypes.entries()].forEach(([frameId, typeId]) => {\n    const { path } = definitions.get(frameId)!\n    constructTypeDef(definitions, getTypeRef, getPrimitive, frameId).forEach(\n      (typeDef) => {\n        typeTree.push({\n          path,\n          typeId,\n          typeDef,\n        })\n      },\n    )\n  })\n\n  typeTree.sort((a, b) => {\n    if (a.typeId !== b.typeId) return a.typeId - b.typeId // in general\n    // should only happen for variants\n    if (a.typeDef.tag !== \"enumeration\" || b.typeDef.tag !== \"enumeration\")\n      throw new Error(\"Found two types with same id\")\n    return a.typeDef.value.index - b.typeDef.value.index\n  })\n  return typeTree\n}\n","import {\n  decAnyMetadata,\n  UnifiedMetadata,\n  type HexString,\n  unifyMetadata,\n} from \"@polkadot-api/substrate-bindings\"\n\nexport const getMetadata = (\n  input: Uint8Array | HexString,\n): UnifiedMetadata<15 | 16> => {\n  try {\n    const metadata = unifyMetadata(decAnyMetadata(input))\n    if (metadata.version <= 14) throw new Error(\"Wrong metadata version\")\n    return metadata as UnifiedMetadata<15 | 16>\n  } catch (e) {\n    throw e || new Error(\"Unable to decode metadata\")\n  }\n}\n","import { type HexString } from \"@polkadot-api/substrate-bindings\"\nimport { fromHex } from \"@polkadot-api/utils\"\n\nexport const toBytes = (input: Uint8Array | HexString) =>\n  typeof input === \"string\" ? fromHex(input) : input\n\nexport const compactTypeRefs = {\n  null: \"void\" as const,\n  u8: \"compactU8\" as const,\n  u16: \"compactU16\" as const,\n  u32: \"compactU32\" as const,\n  u64: \"compactU64\" as const,\n  u128: \"compactU128\" as const,\n  u256: \"compactU256\" as const,\n}\n","import {\n  HexString,\n  _void,\n  compact,\n  createDecoder,\n  i128,\n  i16,\n  i256,\n  i32,\n  i64,\n  i8,\n  str,\n  u128,\n  u16,\n  u256,\n  u32,\n  u64,\n  u8,\n} from \"@polkadot-api/substrate-bindings\"\nimport { Lookup, TypeDef, TypeRef } from \"./codecs\"\n\nconst typeRefDecoders = {\n  bool: u8,\n  char: u8,\n  str,\n  u8,\n  u16,\n  u32,\n  u64,\n  u128,\n  u256,\n  i8,\n  i16,\n  i32,\n  i64,\n  i128,\n  i256,\n  void: _void,\n  compactU8: compact,\n  compactU16: compact,\n  compactU32: compact,\n  compactU64: compact,\n  compactU128: compact,\n  compactU256: compact,\n}\n\nconst innerDecodeAndCollect = (\n  input: Uint8Array,\n  typeRef: TypeRef,\n  idToLookups: Map<number, Array<number>>,\n  lookup: Lookup,\n  collected: Set<number>,\n) => {\n  if (typeRef.tag !== \"perId\") {\n    typeRefDecoders[typeRef.tag][1](input)\n    return\n  }\n\n  const handleTypeRef = (typeRef: TypeRef) => {\n    innerDecodeAndCollect(input, typeRef, idToLookups, lookup, collected)\n  }\n\n  const lookupIdxs = idToLookups.get(typeRef.value)!\n  const [currentIdx] = lookupIdxs\n  const current = lookup[currentIdx]\n\n  if (lookupIdxs.length === 1) collected.add(currentIdx)\n\n  switch (current.typeDef.tag) {\n    case \"enumeration\": {\n      const selectedIdx = u8.dec(input)\n      const [selected, collectedIdx] = lookupIdxs\n        .map(\n          (lookupIdx) =>\n            [lookup[lookupIdx].typeDef, lookupIdx] as [\n              TypeDef & { tag: \"enumeration\" },\n              number,\n            ],\n        )\n        .find(([x]) => x.value.index === selectedIdx)!\n      collected.add(collectedIdx)\n      selected.value.fields.forEach(({ ty }) => {\n        handleTypeRef(ty)\n      })\n      break\n    }\n    case \"sequence\": {\n      const len = compact.dec(input)\n      for (let i = 0; i < len; i++) handleTypeRef(current.typeDef.value)\n      break\n    }\n    case \"array\": {\n      for (let i = 0; i < current.typeDef.value.len; i++)\n        handleTypeRef(current.typeDef.value.typeParam)\n      break\n    }\n    case \"composite\": {\n      current.typeDef.value.forEach((x) => {\n        handleTypeRef(x.ty)\n      })\n      break\n    }\n    case \"tuple\": {\n      current.typeDef.value.forEach(handleTypeRef)\n      break\n    }\n    case \"bitSequence\":\n      throw new Error(\"bitSequence is not supported\")\n  }\n}\n\nexport const decodeAndCollectKnownLeafs = (\n  data: Uint8Array | HexString,\n  typeRefs: Array<TypeRef>,\n  lookup: Lookup,\n): Array<number> => {\n  let input: Uint8Array<ArrayBufferLike> = new Uint8Array()\n  createDecoder((_input) => {\n    input = _input\n  })(data)\n\n  const idToLookups = new Map<number, number[]>()\n  lookup.forEach((lookup, idx) => {\n    const arr = idToLookups.get(lookup.typeId)\n    if (arr) arr.push(idx)\n    else idToLookups.set(lookup.typeId, [idx])\n  })\n\n  const result = new Set<number>()\n  typeRefs.forEach((typeRef) => {\n    innerDecodeAndCollect(input, typeRef, idToLookups, lookup, result)\n  })\n\n  return [...result].sort((a, b) => a - b)\n}\n","const getLevelFromIdx = (idx: number) => Math.log2(idx + 1) | 0\nconst getAncestorIdx = (from: number, nLevels: number) =>\n  ((from + 1) >> nLevels) - 1\n\nexport function getProofData(\n  leaves: Array<Uint8Array>,\n  knownLeavesIdxs: Array<number>,\n) {\n  const knownLeaves = knownLeavesIdxs.map((idx) => leaves[idx])\n\n  const startingIdx = leaves.length - 1\n  const leafIdxs = knownLeavesIdxs.map((idx) => startingIdx + idx)\n\n  const proofIdxs: Array<number> = []\n  if (leafIdxs.length) {\n    const nLevels = getLevelFromIdx(leafIdxs.at(-1)!)\n    const splitPosition = Math.pow(2, nLevels) - 1\n    const splitIdx = leafIdxs.findIndex((x) => x >= splitPosition)\n    if (splitIdx > 0) {\n      leafIdxs.unshift(...leafIdxs.splice(splitIdx))\n      knownLeaves.unshift(...knownLeaves.splice(splitIdx))\n    }\n  }\n\n  let targetIdx = 0\n  const traverse = (nodeIdx: number): void => {\n    if (targetIdx === leafIdxs.length) {\n      proofIdxs.push(nodeIdx)\n      return\n    }\n\n    const target = leafIdxs[targetIdx]\n    if (target === nodeIdx) {\n      ++targetIdx\n      return\n    }\n\n    const currentLevel = getLevelFromIdx(nodeIdx)\n    const targetLevel = getLevelFromIdx(target)\n\n    if (nodeIdx !== getAncestorIdx(target, targetLevel - currentLevel)) {\n      proofIdxs.push(nodeIdx)\n      return\n    }\n\n    const leftSon = 2 * nodeIdx + 1\n    traverse(leftSon)\n    traverse(leftSon + 1)\n  }\n  traverse(0)\n\n  return {\n    leaves: knownLeaves,\n    leafIdxs,\n    proofIdxs,\n  }\n}\n","import {\n  Blake3256,\n  HexString,\n  compact,\n  u32,\n} from \"@polkadot-api/substrate-bindings\"\nimport {\n  ExtraInfo,\n  ExtrinsicMetadata,\n  LookupValue,\n  MetadataDigest,\n  ScalePrimitive,\n  TypeRef,\n  extraInfo,\n  extrinsicMetadata,\n  lookupType,\n  metadataDigest,\n  extrinsicDec,\n} from \"./codecs\"\nimport { getAccessibleTypes } from \"./get-accessible-types\"\nimport { getLookup } from \"./get-lookup\"\nimport { getMetadata } from \"./get-metadata\"\nimport { compactTypeRefs, toBytes } from \"./utils\"\nimport { decodeAndCollectKnownLeafs } from \"./decode-and-collect\"\nimport { getProofData } from \"./proof\"\nimport { getDynamicBuilder, getLookupFn } from \"@polkadot-api/metadata-builders\"\nimport { mergeUint8 } from \"@polkadot-api/utils\"\n\nexport interface MetadataMerkleizer {\n  /**\n   * @returns Digest value of the metadata (aka its merkleized root-hash)\n   */\n  digest: () => Uint8Array\n\n  /**\n   * Get proof for an `Extrinsic`.\n   *\n   * @param transaction         Encoded `Extrinsic`, both signed or unsigned.\n   * @param txAdditionalSigned  Optionally collect types for given\n   *                            `additionalSigned` part of signedExtensions.\n   * @returns Encoded `Proof`\n   */\n  getProofForExtrinsic: (\n    transaction: Uint8Array | HexString,\n    txAdditionalSigned?: Uint8Array | HexString,\n  ) => Uint8Array\n\n  /**\n   * Get proof for `ExtrinsicPayload` parts.\n   *\n   * @param callData              Call data of the transaction. It has to be\n   *                              bare; i.e.\n   *                              without prepended compact length.\n   * @param includedInExtrinsic   Extra part of the signed extensions, all of\n   *                              them concatenated.\n   * @param includedInSignedData  Additional signed part of the signed\n   *                              extensions, all of them concatenated.\n   * @returns Encoded `Proof`\n   */\n  getProofForExtrinsicParts: (\n    callData: Uint8Array | HexString,\n    includedInExtrinsic: Uint8Array | HexString,\n    includedInSignedData: Uint8Array | HexString,\n  ) => Uint8Array\n\n  /**\n   * Get proof for `ExtrinsicPayload`.\n   *\n   * @param extrinsicPayload  Call data, extra part of signedExtensions and\n   *                          additional signed part of signedExtensions\n   *                          concatenated. It has to be bare; i.e. without\n   *                          prepended compact length.\n   * @returns Encoded `Proof`\n   */\n  getProofForExtrinsicPayload: (\n    extrinsicPayload: Uint8Array | HexString,\n  ) => Uint8Array\n}\n\nconst assertExpected = <T>(name: string, expected: T, received?: T): void => {\n  if (received != null && received !== expected)\n    throw new Error(\n      `${name} not expected. Received ${received} expected ${expected}`,\n    )\n}\n\nexport const merkleizeMetadata = (\n  metadataBytes: Uint8Array | HexString,\n  {\n    decimals,\n    tokenSymbol,\n    ...hinted\n  }: { decimals: number; tokenSymbol: string } & Partial<ExtraInfo>,\n): MetadataMerkleizer => {\n  const metadata = getMetadata(metadataBytes)\n\n  const checkedVersion = metadata.extrinsic.version.includes(4) ? 4 : null\n  if (checkedVersion == null) throw new Error(\"Only extrinsic v4 is supported\")\n\n  const { ss58Prefix, buildDefinition } = getDynamicBuilder(\n    getLookupFn(metadata),\n  )\n  if (ss58Prefix == null) throw new Error(\"SS58 prefix not found in metadata\")\n  assertExpected(\"SS58 prefix\", ss58Prefix, hinted.base58Prefix)\n  const version = metadata.pallets\n    .find((x) => x.name === \"System\")\n    ?.constants.find((x) => x.name === \"Version\")\n  if (version == null) throw new Error(\"System.Version constant not found\")\n  const { spec_name: specName, spec_version: specVersion } = buildDefinition(\n    version.type,\n  ).dec(version.value)\n  if (typeof specName !== \"string\" || typeof specVersion !== \"number\")\n    throw new Error(\"Spec name or spec version not found\")\n  assertExpected(\"Spec name\", specName, hinted.specName)\n  assertExpected(\"Spec version\", specVersion, hinted.specVersion)\n\n  const info: ExtraInfo = {\n    decimals,\n    tokenSymbol,\n    specVersion,\n    specName,\n    base58Prefix: ss58Prefix,\n  }\n  const definitions = new Map<number, LookupValue>(\n    metadata.lookup.map((value) => [value.id, value]),\n  )\n  const accessibleTypes = getAccessibleTypes(metadata, definitions)\n  const getPrimitive = (frameId: number): ScalePrimitive[\"tag\"] | null => {\n    const {\n      def: { tag, value },\n    } = definitions.get(frameId)!\n\n    if (tag === \"primitive\") return value.tag\n\n    if ((tag !== \"composite\" && tag !== \"tuple\") || value.length > 1)\n      throw new Error(\"The provided definition doesn't map to a primitive\")\n\n    return value.length === 0\n      ? null // signals `void`\n      : getPrimitive(tag === \"tuple\" ? value[0] : value[0].type)\n  }\n\n  const getTypeRef = (frameId: number): TypeRef => {\n    const { def } = definitions.get(frameId)!\n\n    if (def.tag === \"primitive\") return { tag: def.value.tag, value: undefined }\n\n    if (def.tag === \"compact\") {\n      const primitive = getPrimitive(def.value)\n      const tag = compactTypeRefs[primitive as \"u8\"]\n      if (!tag) throw new Error(\"Invalid primitive for Compact\")\n      return { tag, value: undefined }\n    }\n\n    return accessibleTypes.has(frameId)\n      ? { tag: \"perId\", value: accessibleTypes.get(frameId)! }\n      : { tag: \"void\", value: undefined }\n  }\n\n  const extrinsic: ExtrinsicMetadata = {\n    version: checkedVersion,\n    addressTy: getTypeRef(metadata.extrinsic.address),\n    callTy: getTypeRef(metadata.extrinsic.call),\n    signatureTy: getTypeRef(metadata.extrinsic.signature),\n    signedExtensions: metadata.extrinsic.signedExtensions.map((se) => ({\n      identifier: se.identifier,\n      includedInExtrinsic: getTypeRef(se.type),\n      includedInSignedData: getTypeRef(se.additionalSigned),\n    })),\n  }\n\n  const lookup = getLookup(\n    definitions,\n    accessibleTypes,\n    getTypeRef,\n    getPrimitive,\n  )\n  const lookupEncoded = lookup.map(lookupType.enc)\n\n  let hashTree: Array<Uint8Array> | undefined\n  const getHashTree = (): Array<Uint8Array> => {\n    if (hashTree) return hashTree\n\n    if (!lookupEncoded.length) return (hashTree = [new Uint8Array(32).fill(0)])\n\n    hashTree = new Array(lookupEncoded.length * 2 - 1)\n\n    let leavesStartIdx = lookupEncoded.length - 1\n    for (let i = 0; i < lookupEncoded.length; i++)\n      hashTree[leavesStartIdx + i] = Blake3256(lookupEncoded[i])\n\n    for (let i = hashTree.length - 2; i > 0; i -= 2)\n      hashTree[(i - 1) / 2] = Blake3256(\n        mergeUint8([hashTree[i], hashTree[i + 1]]),\n      )\n\n    return hashTree\n  }\n\n  let digested: undefined | Uint8Array\n  const digest = () => {\n    if (digested) return digested\n    const rootLookupHash = getHashTree()[0]\n\n    const digest: MetadataDigest = {\n      tag: \"V1\",\n      value: {\n        typeInformationTreeRoot: rootLookupHash,\n        extrinsicMetadataHash: Blake3256(extrinsicMetadata.enc(extrinsic)),\n        ...info,\n      },\n    }\n\n    return (digested = Blake3256(metadataDigest.enc(digest)))\n  }\n\n  const generateProof = (knownIndexes: number[]) => {\n    const proofData = getProofData(lookupEncoded, knownIndexes)\n\n    const hashTree = getHashTree()\n    const proofs = proofData.proofIdxs.map((idx) => hashTree[idx])\n\n    return mergeUint8([\n      compact.enc(proofData.leaves.length),\n      ...proofData.leaves,\n      compact.enc(proofData.leafIdxs.length),\n      ...proofData.leafIdxs.map((x) => u32.enc(x)),\n      compact.enc(proofs.length),\n      ...proofs,\n      extrinsicMetadata.enc(extrinsic),\n      extraInfo.enc(info),\n    ])\n  }\n\n  const getProofForExtrinsicPayload = (\n    extrinsicPayload: Uint8Array | HexString,\n  ) => {\n    const typeRefs: Array<TypeRef> = [\n      extrinsic.callTy,\n      ...extrinsic.signedExtensions.map((x) => x.includedInExtrinsic),\n      ...extrinsic.signedExtensions.map((x) => x.includedInSignedData),\n    ]\n    return generateProof(\n      decodeAndCollectKnownLeafs(extrinsicPayload, typeRefs, lookup),\n    )\n  }\n\n  const getProofForExtrinsicParts = (\n    callData: Uint8Array | HexString,\n    includedInExtrinsic: Uint8Array | HexString,\n    includedInSignedData: Uint8Array | HexString,\n  ) => {\n    const bytes = mergeUint8(\n      [callData, includedInExtrinsic, includedInSignedData].map(toBytes),\n    )\n    return getProofForExtrinsicPayload(bytes)\n  }\n\n  const getProofForExtrinsic = (\n    transaction: Uint8Array | HexString,\n    txAdditionalSigned?: Uint8Array | HexString,\n  ) => {\n    let [, { version, type }, bytes] = extrinsicDec(transaction)\n\n    if (version !== extrinsic.version)\n      throw new Error(\"Incorrect extrinsic version\")\n\n    const typeRefs: TypeRef[] =\n      type === \"signed\"\n        ? [\n            extrinsic.addressTy,\n            extrinsic.signatureTy,\n            ...extrinsic.signedExtensions.map((x) => x.includedInExtrinsic),\n            extrinsic.callTy,\n          ]\n        : [extrinsic.callTy]\n\n    if (txAdditionalSigned) {\n      bytes = mergeUint8([bytes, toBytes(txAdditionalSigned)])\n      typeRefs.push(\n        ...extrinsic.signedExtensions.map((x) => x.includedInSignedData),\n      )\n    }\n\n    return generateProof(decodeAndCollectKnownLeafs(bytes, typeRefs, lookup))\n  }\n\n  return {\n    digest,\n    getProofForExtrinsic,\n    getProofForExtrinsicParts,\n    getProofForExtrinsicPayload,\n  }\n}\n"],"names":["u32","str","u16","u8","Struct","Bytes","ScaleEnum","_void","compactNumber","Option","Vector","bool","Tuple","compact","extrinsicFormat","unifyMetadata","decAnyMetadata","fromHex","u64","u128","u256","i8","i16","i32","i64","i128","i256","typeRef","createDecoder","lookup","getDynamicBuilder","getLookupFn","Blake3256","mergeUint8","digest","hashTree","version"],"mappings":";;;;;;AAqBA,MAAM,cAAA,GAAiB;AAAA,EACrB,WAAA,EAAaA,qBAAA;AAAA,EACb,QAAA,EAAUC,qBAAA;AAAA,EACV,YAAA,EAAcC,qBAAA;AAAA,EACd,QAAA,EAAUC,oBAAA;AAAA,EACV,WAAA,EAAaF;AACf,CAAA;AACO,MAAM,SAAA,GAAYG,yBAAO,cAAc;AAGvC,MAAM,IAAA,GAAOC,wBAAM,EAAE;AACrB,MAAM,iBAAiBC,2BAAA,CAAU;AAAA,EACtC,EAAA,EAAIC,uBAAA;AAAA,EACJ,IAAIH,wBAAA,CAAO;AAAA,IACT,uBAAA,EAAyB,IAAA;AAAA,IACzB,qBAAA,EAAuB,IAAA;AAAA,IACvB,GAAG;AAAA,GACJ;AACH,CAAC,CAAA;AAG6BE,2BAAA,CAAU;AAAA,EACtC,IAAA,EAAMC,uBAAA;AAAA,EACN,IAAA,EAAMA,uBAAA;AAAA,EACN,GAAA,EAAKA,uBAAA;AAAA,EACL,EAAA,EAAIA,uBAAA;AAAA,EACJ,GAAA,EAAKA,uBAAA;AAAA,EACL,GAAA,EAAKA,uBAAA;AAAA,EACL,GAAA,EAAKA,uBAAA;AAAA,EACL,IAAA,EAAMA,uBAAA;AAAA,EACN,IAAA,EAAMA,uBAAA;AAAA,EACN,EAAA,EAAIA,uBAAA;AAAA,EACJ,GAAA,EAAKA,uBAAA;AAAA,EACL,GAAA,EAAKA,uBAAA;AAAA,EACL,GAAA,EAAKA,uBAAA;AAAA,EACL,IAAA,EAAMA,uBAAA;AAAA,EACN,IAAA,EAAMA;AACR,CAAC;AAGM,MAAM,UAAUD,2BAAA,CAAU;AAAA,EAC/B,IAAA,EAAMC,uBAAA;AAAA,EACN,IAAA,EAAMA,uBAAA;AAAA,EACN,GAAA,EAAKA,uBAAA;AAAA,EACL,EAAA,EAAIA,uBAAA;AAAA,EACJ,GAAA,EAAKA,uBAAA;AAAA,EACL,GAAA,EAAKA,uBAAA;AAAA,EACL,GAAA,EAAKA,uBAAA;AAAA,EACL,IAAA,EAAMA,uBAAA;AAAA,EACN,IAAA,EAAMA,uBAAA;AAAA,EACN,EAAA,EAAIA,uBAAA;AAAA,EACJ,GAAA,EAAKA,uBAAA;AAAA,EACL,GAAA,EAAKA,uBAAA;AAAA,EACL,GAAA,EAAKA,uBAAA;AAAA,EACL,IAAA,EAAMA,uBAAA;AAAA,EACN,IAAA,EAAMA,uBAAA;AAAA,EACN,SAAA,EAAWA,uBAAA;AAAA,EACX,UAAA,EAAYA,uBAAA;AAAA,EACZ,UAAA,EAAYA,uBAAA;AAAA,EACZ,UAAA,EAAYA,uBAAA;AAAA,EACZ,WAAA,EAAaA,uBAAA;AAAA,EACb,WAAA,EAAaA,uBAAA;AAAA,EACb,IAAA,EAAMA,uBAAA;AAAA,EACN,KAAA,EAAOC;AACT,CAAC,CAAA;AAGD,MAAM,QAAQJ,wBAAA,CAAO;AAAA,EACnB,IAAA,EAAMK,yBAAOR,qBAAG,CAAA;AAAA,EAChB,EAAA,EAAI,OAAA;AAAA,EACJ,QAAA,EAAUQ,yBAAOR,qBAAG;AACtB,CAAC,CAAA;AACM,MAAM,UAAUK,2BAAA,CAAU;AAAA,EAC/B,SAAA,EAAWI,yBAAO,KAAK,CAAA;AAAA,EACvB,aAAaN,wBAAA,CAAO;AAAA,IAClB,IAAA,EAAMH,qBAAA;AAAA,IACN,MAAA,EAAQS,yBAAO,KAAK,CAAA;AAAA,IACpB,KAAA,EAAOF;AAAA,GACR,CAAA;AAAA,EACD,QAAA,EAAU,OAAA;AAAA,EACV,OAAOJ,wBAAA,CAAO;AAAA,IACZ,GAAA,EAAKJ,qBAAA;AAAA,IACL,SAAA,EAAW;AAAA,GACZ,CAAA;AAAA,EACD,KAAA,EAAOU,yBAAO,OAAO,CAAA;AAAA,EACrB,aAAaN,wBAAA,CAAO;AAAA,IAClB,QAAA,EAAUD,oBAAA;AAAA,IACV,wBAAA,EAA0BQ;AAAA,GAC3B;AACH,CAAC,CAAA;AAGM,MAAM,aAAaP,wBAAA,CAAO;AAAA,EAC/B,IAAA,EAAMM,yBAAOT,qBAAG,CAAA;AAAA,EAChB,OAAA;AAAA,EACA,MAAA,EAAQO;AACV,CAAC;AAGM,MAAM,MAAA,GAAwBE,yBAAO,UAAU;AAE/C,MAAM,oBAAoBN,wBAAA,CAAO;AAAA,EACtC,OAAA,EAASD,oBAAA;AAAA,EACT,SAAA,EAAW,OAAA;AAAA,EACX,MAAA,EAAQ,OAAA;AAAA,EACR,WAAA,EAAa,OAAA;AAAA,EACb,gBAAA,EAAkBO,wBAAA;AAAA,IAChBN,wBAAA,CAAO;AAAA,MACL,UAAA,EAAYH,qBAAA;AAAA,MACZ,mBAAA,EAAqB,OAAA;AAAA,MACrB,oBAAA,EAAsB;AAAA,KACvB;AAAA;AAEL,CAAC;AAIM,MAAM,eAAeW,uBAAA,CAAM,GAAA;AAAA,EAChCC,0BAAQ,CAAC,CAAA;AAAA,EACTC,kCAAgB,CAAC,CAAA;AAAA,EACjBT,uBAAA,CAAM,QAAQ,CAAA,CAAE,CAAC;AACnB,CAAA;AAEO,MAAM,QAAQD,wBAAA,CAAO;AAAA,EAC1B,MAAA,EAAQ,MAAA;AAAA,EACR,QAAA,EAAUM,yBAAOV,qBAAG,CAAA;AAAA,EACpB,MAAA,EAAQU,yBAAO,IAAI,CAAA;AAAA,EACnB,SAAA,EAAW,iBAAA;AAAA,EACX,IAAA,EAAM;AACR,CAAC;;ACnJM,MAAM,kBAAA,GAAqB,CAChC,QAAA,EACA,WAAA,KACwB;AACxB,EAAA,MAAM,KAAA,uBAAY,GAAA,EAAY;AAE9B,EAAA,MAAM,kBAAA,GAAqB,CAAC,EAAA,KAAe;AACzC,IAAA,IAAI,KAAA,CAAM,GAAA,CAAI,EAAE,CAAA,EAAG;AAEnB,IAAA,MAAM,EAAE,GAAA,EAAK,KAAA,KAAU,WAAA,CAAY,GAAA,CAAI,EAAE,CAAA,CAAG,GAAA;AAC5C,IAAA,QAAQ,GAAA;AAAK,MACX,KAAK,WAAA;AACH,QAAA,IAAI,CAAC,MAAM,MAAA,EAAQ;AACnB,QAAA,KAAA,CAAM,IAAI,EAAE,CAAA;AACZ,QAAA,KAAA,CAAM,OAAA,CAAQ,CAAC,EAAE,IAAA,EAAK,KAAM;AAC1B,UAAA,kBAAA,CAAmB,IAAI,CAAA;AAAA,QACzB,CAAC,CAAA;AACD,QAAA;AAAA,MACF,KAAK,SAAA;AACH,QAAA,IAAI,CAAC,MAAM,MAAA,EAAQ;AACnB,QAAA,KAAA,CAAM,IAAI,EAAE,CAAA;AACZ,QAAA,KAAA,CAAM,OAAA,CAAQ,CAAC,EAAE,MAAA,EAAO,KAAM;AAC5B,UAAA,MAAA,CAAO,OAAA,CAAQ,CAAC,EAAE,IAAA,EAAK,KAAM;AAC3B,YAAA,kBAAA,CAAmB,IAAI,CAAA;AAAA,UACzB,CAAC,CAAA;AAAA,QACH,CAAC,CAAA;AACD,QAAA;AAAA,MACF,KAAK,OAAA;AACH,QAAA,IAAI,CAAC,MAAM,MAAA,EAAQ;AACnB,QAAA,KAAA,CAAM,IAAI,EAAE,CAAA;AACZ,QAAA,KAAA,CAAM,QAAQ,kBAAkB,CAAA;AAChC,QAAA;AAAA,MACF,KAAK,UAAA;AACH,QAAA,KAAA,CAAM,IAAI,EAAE,CAAA;AACZ,QAAA,kBAAA,CAAmB,KAAK,CAAA;AACxB,QAAA;AAAA,MACF,KAAK,OAAA;AACH,QAAA,KAAA,CAAM,IAAI,EAAE,CAAA;AACZ,QAAA,kBAAA,CAAmB,MAAM,IAAI,CAAA;AAC7B,QAAA;AAAA,MACF,KAAK,aAAA;AACH,QAAA,KAAA,CAAM,IAAI,EAAE,CAAA;AAAA;AAEhB,EACF,CAAA;AAEA,EAAA,kBAAA,CAAmB,QAAA,CAAS,UAAU,IAAI,CAAA;AAC1C,EAAA,kBAAA,CAAmB,QAAA,CAAS,UAAU,OAAO,CAAA;AAC7C,EAAA,kBAAA,CAAmB,QAAA,CAAS,UAAU,SAAS,CAAA;AAC/C,EAAA,QAAA,CAAS,UAAU,gBAAA,CAAiB,OAAA,CAAQ,CAAC,EAAE,IAAA,EAAM,kBAAiB,KAAM;AAC1E,IAAA,kBAAA,CAAmB,IAAI,CAAA;AACvB,IAAA,kBAAA,CAAmB,gBAAgB,CAAA;AAAA,EACrC,CAAC,CAAA;AAED,EAAA,MAAM,WAAA,GAAc,CAAC,GAAG,KAAK,CAAA,CAAE,KAAK,CAAC,CAAA,EAAG,CAAA,KAAM,CAAA,GAAI,CAAC,CAAA;AACnD,EAAA,OAAO,IAAI,GAAA,CAAI,WAAA,CAAY,GAAA,CAAI,CAAC,KAAA,EAAO,GAAA,KAAQ,CAAC,KAAA,EAAO,GAAG,CAAC,CAAC,CAAA;AAC9D,CAAA;;ACzDA,MAAM,gBAAA,GAAmB;AAAA,EACvB,EAAA,EAAI,CAAA;AAAA,EACJ,GAAA,EAAK,CAAA;AAAA,EACL,GAAA,EAAK,CAAA;AAAA,EACL,GAAA,EAAK;AACP,CAAA;AAEA,MAAM,gBAAA,GAAmB,CACvB,WAAA,EACA,UAAA,EACA,cACA,OAAA,KACc;AACd,EAAA,MAAM;AAAA,IACJ,GAAA,EAAK,EAAE,GAAA,EAAK,KAAA;AAAM,GACpB,GAAI,WAAA,CAAY,GAAA,CAAI,OAAO,CAAA;AAC3B,EAAA,QAAQ,GAAA;AAAK,IACX,KAAK,WAAA;AACH,MAAA,OAAO;AAAA,QACL;AAAA,UACE,GAAA;AAAA,UACA,KAAA,EAAO,KAAA,CAAM,GAAA,CAAI,CAAC,CAAA,MAAO;AAAA,YACvB,MAAM,CAAA,CAAE,IAAA;AAAA,YACR,UAAU,CAAA,CAAE,QAAA;AAAA,YACZ,EAAA,EAAI,UAAA,CAAW,CAAA,CAAE,IAAI;AAAA,WACvB,CAAE;AAAA;AACJ,OACF;AAAA,IACF,KAAK,SAAA,EAAW;AACd,MAAA,OAAO,KAAA,CAAM,GAAA,CAAI,CAAC,CAAA,MAAO;AAAA,QACvB,GAAA,EAAK,aAAA;AAAA,QACL,KAAA,EAAO;AAAA,UACL,MAAM,CAAA,CAAE,IAAA;AAAA,UACR,OAAO,CAAA,CAAE,KAAA;AAAA,UACT,MAAA,EAAQ,CAAA,CAAE,MAAA,CAAO,GAAA,CAAI,CAAC,CAAA,MAAO;AAAA,YAC3B,MAAM,CAAA,CAAE,IAAA;AAAA,YACR,UAAU,CAAA,CAAE,QAAA;AAAA,YACZ,EAAA,EAAI,UAAA,CAAW,CAAA,CAAE,IAAI;AAAA,WACvB,CAAE;AAAA;AACJ,OACF,CAAE,CAAA;AAAA,IACJ;AAAA,IACA,KAAK,UAAA;AACH,MAAA,OAAO;AAAA,QACL;AAAA,UACE,GAAA;AAAA,UACA,KAAA,EAAO,WAAW,KAAK;AAAA;AACzB,OACF;AAAA,IACF,KAAK,OAAA;AACH,MAAA,OAAO;AAAA,QACL;AAAA,UACE,GAAA;AAAA,UACA,KAAA,EAAO;AAAA,YACL,KAAK,KAAA,CAAM,GAAA;AAAA,YACX,SAAA,EAAW,UAAA,CAAW,KAAA,CAAM,IAAI;AAAA;AAClC;AACF,OACF;AAAA,IACF,KAAK,OAAA;AACH,MAAA,OAAO;AAAA,QACL;AAAA,UACE,GAAA;AAAA,UACA,KAAA,EAAO,KAAA,CAAM,GAAA,CAAI,UAAU;AAAA;AAC7B,OACF;AAAA,IACF,KAAK,aAAA,EAAe;AAClB,MAAA,MAAM,SAAA,GAAY,YAAA,CAAa,KAAA,CAAM,YAAY,CAAA;AACjD,MAAA,MAAM,QAAA,GAAW,iBAAiB,SAAiB,CAAA;AACnD,MAAA,IAAI,CAAC,QAAA,EAAU,MAAM,IAAI,MAAM,mCAAmC,CAAA;AAElE,MAAA,MAAM,cAAA,GAAiB,WAAA,CAAY,GAAA,CAAI,KAAA,CAAM,YAAY,CAAA,CAAG,IAAA;AAC5D,MAAA,MAAM,wBAAA,GAA2B,cAAA,CAAe,QAAA,CAAS,MAAM,CAAA;AAC/D,MAAA,IAAI,CAAC,wBAAA,IAA4B,CAAC,cAAA,CAAe,SAAS,MAAM,CAAA;AAC9D,QAAA,MAAM,IAAI,MAAM,6BAA6B,CAAA;AAE/C,MAAA,OAAO;AAAA,QACL;AAAA,UACE,GAAA,EAAK,aAAA;AAAA,UACL,KAAA,EAAO,EAAE,QAAA,EAAU,wBAAA;AAAyB;AAC9C,OACF;AAAA,IACF;AAAA;AAGF,EAAA,MAAM,IAAI,KAAA,CAAM,CAAA,QAAA,EAAW,OAAO,CAAA,+BAAA,CAAiC,CAAA;AACrE,CAAA;AAEO,MAAM,SAAA,GAAY,CACvB,WAAA,EACA,eAAA,EACA,YACA,YAAA,KACG;AACH,EAAA,MAAM,WAAmB,EAAC;AACzB,EAAA,CAAC,GAAG,eAAA,CAAgB,OAAA,EAAS,CAAA,CAAE,QAAQ,CAAC,CAAC,OAAA,EAAS,MAAM,CAAA,KAAM;AAC7D,IAAA,MAAM,EAAE,IAAA,EAAK,GAAI,WAAA,CAAY,IAAI,OAAO,CAAA;AACxC,IAAA,gBAAA,CAAiB,WAAA,EAAa,UAAA,EAAY,YAAA,EAAc,OAAO,CAAA,CAAE,OAAA;AAAA,MAC/D,CAAC,OAAA,KAAY;AACX,QAAA,QAAA,CAAS,IAAA,CAAK;AAAA,UACZ,IAAA;AAAA,UACA,MAAA;AAAA,UACA;AAAA,SACD,CAAA;AAAA,MACH;AAAA,KACF;AAAA,EACF,CAAC,CAAA;AAED,EAAA,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA,EAAG,CAAA,KAAM;AACtB,IAAA,IAAI,EAAE,MAAA,KAAW,CAAA,CAAE,QAAQ,OAAO,CAAA,CAAE,SAAS,CAAA,CAAE,MAAA;AAE/C,IAAA,IAAI,EAAE,OAAA,CAAQ,GAAA,KAAQ,aAAA,IAAiB,CAAA,CAAE,QAAQ,GAAA,KAAQ,aAAA;AACvD,MAAA,MAAM,IAAI,MAAM,8BAA8B,CAAA;AAChD,IAAA,OAAO,EAAE,OAAA,CAAQ,KAAA,CAAM,KAAA,GAAQ,CAAA,CAAE,QAAQ,KAAA,CAAM,KAAA;AAAA,EACjD,CAAC,CAAA;AACD,EAAA,OAAO,QAAA;AACT,CAAA;;AC/GO,MAAM,WAAA,GAAc,CACzB,KAAA,KAC6B;AAC7B,EAAA,IAAI;AACF,IAAA,MAAM,QAAA,GAAWK,+BAAA,CAAcC,gCAAA,CAAe,KAAK,CAAC,CAAA;AACpD,IAAA,IAAI,SAAS,OAAA,IAAW,EAAA,EAAI,MAAM,IAAI,MAAM,wBAAwB,CAAA;AACpE,IAAA,OAAO,QAAA;AAAA,EACT,SAAS,CAAA,EAAG;AACV,IAAA,MAAM,CAAA,IAAK,IAAI,KAAA,CAAM,2BAA2B,CAAA;AAAA,EAClD;AACF,CAAA;;ACdO,MAAM,OAAA,GAAU,CAAC,KAAA,KACtB,OAAO,UAAU,QAAA,GAAWC,aAAA,CAAQ,KAAK,CAAA,GAAI,KAAA;AAExC,MAAM,eAAA,GAAkB;AAAA,EAC7B,IAAA,EAAM,MAAA;AAAA,EACN,EAAA,EAAI,WAAA;AAAA,EACJ,GAAA,EAAK,YAAA;AAAA,EACL,GAAA,EAAK,YAAA;AAAA,EACL,GAAA,EAAK,YAAA;AAAA,EACL,IAAA,EAAM,aAAA;AAAA,EACN,IAAA,EAAM;AACR,CAAA;;ACOA,MAAM,eAAA,GAAkB;AAAA,EACtB,IAAA,EAAMd,oBAAA;AAAA,EACN,IAAA,EAAMA,oBAAA;AAAA,OACNF,qBAAA;AAAA,MACAE,oBAAA;AAAA,OACAD,qBAAA;AAAA,OACAF,qBAAA;AAAA,OACAkB,qBAAA;AAAA,QACAC,sBAAA;AAAA,QACAC,sBAAA;AAAA,MACAC,oBAAA;AAAA,OACAC,qBAAA;AAAA,OACAC,qBAAA;AAAA,OACAC,qBAAA;AAAA,QACAC,sBAAA;AAAA,QACAC,sBAAA;AAAA,EACA,IAAA,EAAMnB,uBAAA;AAAA,EACN,SAAA,EAAWM,yBAAA;AAAA,EACX,UAAA,EAAYA,yBAAA;AAAA,EACZ,UAAA,EAAYA,yBAAA;AAAA,EACZ,UAAA,EAAYA,yBAAA;AAAA,EACZ,WAAA,EAAaA,yBAAA;AAAA,EACb,WAAA,EAAaA;AACf,CAAA;AAEA,MAAM,wBAAwB,CAC5B,KAAA,EACA,OAAA,EACA,WAAA,EACA,QACA,SAAA,KACG;AACH,EAAA,IAAI,OAAA,CAAQ,QAAQ,OAAA,EAAS;AAC3B,IAAA,eAAA,CAAgB,OAAA,CAAQ,GAAG,CAAA,CAAE,CAAC,EAAE,KAAK,CAAA;AACrC,IAAA;AAAA,EACF;AAEA,EAAA,MAAM,aAAA,GAAgB,CAACc,QAAAA,KAAqB;AAC1C,IAAA,qBAAA,CAAsB,KAAA,EAAOA,QAAAA,EAAS,WAAA,EAAa,MAAA,EAAQ,SAAS,CAAA;AAAA,EACtE,CAAA;AAEA,EAAA,MAAM,UAAA,GAAa,WAAA,CAAY,GAAA,CAAI,OAAA,CAAQ,KAAK,CAAA;AAChD,EAAA,MAAM,CAAC,UAAU,CAAA,GAAI,UAAA;AACrB,EAAA,MAAM,OAAA,GAAU,OAAO,UAAU,CAAA;AAEjC,EAAA,IAAI,UAAA,CAAW,MAAA,KAAW,CAAA,EAAG,SAAA,CAAU,IAAI,UAAU,CAAA;AAErD,EAAA,QAAQ,OAAA,CAAQ,QAAQ,GAAA;AAAK,IAC3B,KAAK,aAAA,EAAe;AAClB,MAAA,MAAM,WAAA,GAAcxB,oBAAA,CAAG,GAAA,CAAI,KAAK,CAAA;AAChC,MAAA,MAAM,CAAC,QAAA,EAAU,YAAY,CAAA,GAAI,UAAA,CAC9B,GAAA;AAAA,QACC,CAAC,SAAA,KACC,CAAC,OAAO,SAAS,CAAA,CAAE,SAAS,SAAS;AAAA,OAIzC,CACC,KAAK,CAAC,CAAC,CAAC,CAAA,KAAM,CAAA,CAAE,KAAA,CAAM,KAAA,KAAU,WAAW,CAAA;AAC9C,MAAA,SAAA,CAAU,IAAI,YAAY,CAAA;AAC1B,MAAA,QAAA,CAAS,MAAM,MAAA,CAAO,OAAA,CAAQ,CAAC,EAAE,IAAG,KAAM;AACxC,QAAA,aAAA,CAAc,EAAE,CAAA;AAAA,MAClB,CAAC,CAAA;AACD,MAAA;AAAA,IACF;AAAA,IACA,KAAK,UAAA,EAAY;AACf,MAAA,MAAM,GAAA,GAAMU,yBAAA,CAAQ,GAAA,CAAI,KAAK,CAAA;AAC7B,MAAA,KAAA,IAAS,CAAA,GAAI,GAAG,CAAA,GAAI,GAAA,EAAK,KAAK,aAAA,CAAc,OAAA,CAAQ,QAAQ,KAAK,CAAA;AACjE,MAAA;AAAA,IACF;AAAA,IACA,KAAK,OAAA,EAAS;AACZ,MAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,OAAA,CAAQ,MAAM,GAAA,EAAK,CAAA,EAAA;AAC7C,QAAA,aAAA,CAAc,OAAA,CAAQ,OAAA,CAAQ,KAAA,CAAM,SAAS,CAAA;AAC/C,MAAA;AAAA,IACF;AAAA,IACA,KAAK,WAAA,EAAa;AAChB,MAAA,OAAA,CAAQ,OAAA,CAAQ,KAAA,CAAM,OAAA,CAAQ,CAAC,CAAA,KAAM;AACnC,QAAA,aAAA,CAAc,EAAE,EAAE,CAAA;AAAA,MACpB,CAAC,CAAA;AACD,MAAA;AAAA,IACF;AAAA,IACA,KAAK,OAAA,EAAS;AACZ,MAAA,OAAA,CAAQ,OAAA,CAAQ,KAAA,CAAM,OAAA,CAAQ,aAAa,CAAA;AAC3C,MAAA;AAAA,IACF;AAAA,IACA,KAAK,aAAA;AACH,MAAA,MAAM,IAAI,MAAM,8BAA8B,CAAA;AAAA;AAEpD,CAAA;AAEO,MAAM,0BAAA,GAA6B,CACxC,IAAA,EACA,QAAA,EACA,MAAA,KACkB;AAClB,EAAA,IAAI,KAAA,GAAqC,IAAI,UAAA,EAAW;AACxD,EAAAe,+BAAA,CAAc,CAAC,MAAA,KAAW;AACxB,IAAA,KAAA,GAAQ,MAAA;AAAA,EACV,CAAC,EAAE,IAAI,CAAA;AAEP,EAAA,MAAM,WAAA,uBAAkB,GAAA,EAAsB;AAC9C,EAAA,MAAA,CAAO,OAAA,CAAQ,CAACC,OAAAA,EAAQ,GAAA,KAAQ;AAC9B,IAAA,MAAM,GAAA,GAAM,WAAA,CAAY,GAAA,CAAIA,OAAAA,CAAO,MAAM,CAAA;AACzC,IAAA,IAAI,GAAA,EAAK,GAAA,CAAI,IAAA,CAAK,GAAG,CAAA;AAAA,qBACJ,GAAA,CAAIA,OAAAA,CAAO,MAAA,EAAQ,CAAC,GAAG,CAAC,CAAA;AAAA,EAC3C,CAAC,CAAA;AAED,EAAA,MAAM,MAAA,uBAAa,GAAA,EAAY;AAC/B,EAAA,QAAA,CAAS,OAAA,CAAQ,CAAC,OAAA,KAAY;AAC5B,IAAA,qBAAA,CAAsB,KAAA,EAAO,OAAA,EAAS,WAAA,EAAa,MAAA,EAAQ,MAAM,CAAA;AAAA,EACnE,CAAC,CAAA;AAED,EAAA,OAAO,CAAC,GAAG,MAAM,CAAA,CAAE,KAAK,CAAC,CAAA,EAAG,CAAA,KAAM,CAAA,GAAI,CAAC,CAAA;AACzC,CAAA;;ACtIA,MAAM,kBAAkB,CAAC,GAAA,KAAgB,KAAK,IAAA,CAAK,GAAA,GAAM,CAAC,CAAA,GAAI,CAAA;AAC9D,MAAM,iBAAiB,CAAC,IAAA,EAAc,OAAA,KAAA,CAClC,IAAA,GAAO,KAAM,OAAA,IAAW,CAAA;AAErB,SAAS,YAAA,CACd,QACA,eAAA,EACA;AACA,EAAA,MAAM,cAAc,eAAA,CAAgB,GAAA,CAAI,CAAC,GAAA,KAAQ,MAAA,CAAO,GAAG,CAAC,CAAA;AAE5D,EAAA,MAAM,WAAA,GAAc,OAAO,MAAA,GAAS,CAAA;AACpC,EAAA,MAAM,WAAW,eAAA,CAAgB,GAAA,CAAI,CAAC,GAAA,KAAQ,cAAc,GAAG,CAAA;AAE/D,EAAA,MAAM,YAA2B,EAAC;AAClC,EAAA,IAAI,SAAS,MAAA,EAAQ;AACnB,IAAA,MAAM,OAAA,GAAU,eAAA,CAAgB,QAAA,CAAS,EAAA,CAAG,EAAE,CAAE,CAAA;AAChD,IAAA,MAAM,aAAA,GAAgB,IAAA,CAAK,GAAA,CAAI,CAAA,EAAG,OAAO,CAAA,GAAI,CAAA;AAC7C,IAAA,MAAM,WAAW,QAAA,CAAS,SAAA,CAAU,CAAC,CAAA,KAAM,KAAK,aAAa,CAAA;AAC7D,IAAA,IAAI,WAAW,CAAA,EAAG;AAChB,MAAA,QAAA,CAAS,OAAA,CAAQ,GAAG,QAAA,CAAS,MAAA,CAAO,QAAQ,CAAC,CAAA;AAC7C,MAAA,WAAA,CAAY,OAAA,CAAQ,GAAG,WAAA,CAAY,MAAA,CAAO,QAAQ,CAAC,CAAA;AAAA,IACrD;AAAA,EACF;AAEA,EAAA,IAAI,SAAA,GAAY,CAAA;AAChB,EAAA,MAAM,QAAA,GAAW,CAAC,OAAA,KAA0B;AAC1C,IAAA,IAAI,SAAA,KAAc,SAAS,MAAA,EAAQ;AACjC,MAAA,SAAA,CAAU,KAAK,OAAO,CAAA;AACtB,MAAA;AAAA,IACF;AAEA,IAAA,MAAM,MAAA,GAAS,SAAS,SAAS,CAAA;AACjC,IAAA,IAAI,WAAW,OAAA,EAAS;AACtB,MAAA,EAAE,SAAA;AACF,MAAA;AAAA,IACF;AAEA,IAAA,MAAM,YAAA,GAAe,gBAAgB,OAAO,CAAA;AAC5C,IAAA,MAAM,WAAA,GAAc,gBAAgB,MAAM,CAAA;AAE1C,IAAA,IAAI,OAAA,KAAY,cAAA,CAAe,MAAA,EAAQ,WAAA,GAAc,YAAY,CAAA,EAAG;AAClE,MAAA,SAAA,CAAU,KAAK,OAAO,CAAA;AACtB,MAAA;AAAA,IACF;AAEA,IAAA,MAAM,OAAA,GAAU,IAAI,OAAA,GAAU,CAAA;AAC9B,IAAA,QAAA,CAAS,OAAO,CAAA;AAChB,IAAA,QAAA,CAAS,UAAU,CAAC,CAAA;AAAA,EACtB,CAAA;AACA,EAAA,QAAA,CAAS,CAAC,CAAA;AAEV,EAAA,OAAO;AAAA,IACL,MAAA,EAAQ,WAAA;AAAA,IACR,QAAA;AAAA,IACA;AAAA,GACF;AACF;;ACuBA,MAAM,cAAA,GAAiB,CAAI,IAAA,EAAc,QAAA,EAAa,QAAA,KAAuB;AAC3E,EAAA,IAAI,QAAA,IAAY,QAAQ,QAAA,KAAa,QAAA;AACnC,IAAA,MAAM,IAAI,KAAA;AAAA,MACR,CAAA,EAAG,IAAI,CAAA,wBAAA,EAA2B,QAAQ,aAAa,QAAQ,CAAA;AAAA,KACjE;AACJ,CAAA;AAEO,MAAM,iBAAA,GAAoB,CAC/B,aAAA,EACA;AAAA,EACE,QAAA;AAAA,EACA,WAAA;AAAA,EACA,GAAG;AACL,CAAA,KACuB;AACvB,EAAA,MAAM,QAAA,GAAW,YAAY,aAAa,CAAA;AAE1C,EAAA,MAAM,iBAAiB,QAAA,CAAS,SAAA,CAAU,QAAQ,QAAA,CAAS,CAAC,IAAI,CAAA,GAAI,IAAA;AACpE,EAAA,IAAI,cAAA,IAAkB,IAAA,EAAM,MAAM,IAAI,MAAM,gCAAgC,CAAA;AAE5E,EAAA,MAAM,EAAE,UAAA,EAAY,eAAA,EAAgB,GAAIC,kCAAA;AAAA,IACtCC,6BAAY,QAAQ;AAAA,GACtB;AACA,EAAA,IAAI,UAAA,IAAc,IAAA,EAAM,MAAM,IAAI,MAAM,mCAAmC,CAAA;AAC3E,EAAA,cAAA,CAAe,aAAA,EAAe,UAAA,EAAY,MAAA,CAAO,YAAY,CAAA;AAC7D,EAAA,MAAM,UAAU,QAAA,CAAS,OAAA,CACtB,IAAA,CAAK,CAAC,MAAM,CAAA,CAAE,IAAA,KAAS,QAAQ,CAAA,EAC9B,UAAU,IAAA,CAAK,CAAC,CAAA,KAAM,CAAA,CAAE,SAAS,SAAS,CAAA;AAC9C,EAAA,IAAI,OAAA,IAAW,IAAA,EAAM,MAAM,IAAI,MAAM,mCAAmC,CAAA;AACxE,EAAA,MAAM,EAAE,SAAA,EAAW,QAAA,EAAU,YAAA,EAAc,aAAY,GAAI,eAAA;AAAA,IACzD,OAAA,CAAQ;AAAA,GACV,CAAE,GAAA,CAAI,OAAA,CAAQ,KAAK,CAAA;AACnB,EAAA,IAAI,OAAO,QAAA,KAAa,QAAA,IAAY,OAAO,WAAA,KAAgB,QAAA;AACzD,IAAA,MAAM,IAAI,MAAM,qCAAqC,CAAA;AACvD,EAAA,cAAA,CAAe,WAAA,EAAa,QAAA,EAAU,MAAA,CAAO,QAAQ,CAAA;AACrD,EAAA,cAAA,CAAe,cAAA,EAAgB,WAAA,EAAa,MAAA,CAAO,WAAW,CAAA;AAE9D,EAAA,MAAM,IAAA,GAAkB;AAAA,IACtB,QAAA;AAAA,IACA,WAAA;AAAA,IACA,WAAA;AAAA,IACA,QAAA;AAAA,IACA,YAAA,EAAc;AAAA,GAChB;AACA,EAAA,MAAM,cAAc,IAAI,GAAA;AAAA,IACtB,QAAA,CAAS,OAAO,GAAA,CAAI,CAAC,UAAU,CAAC,KAAA,CAAM,EAAA,EAAI,KAAK,CAAC;AAAA,GAClD;AACA,EAAA,MAAM,eAAA,GAAkB,kBAAA,CAAmB,QAAA,EAAU,WAAW,CAAA;AAChE,EAAA,MAAM,YAAA,GAAe,CAAC,OAAA,KAAkD;AACtE,IAAA,MAAM;AAAA,MACJ,GAAA,EAAK,EAAE,GAAA,EAAK,KAAA;AAAM,KACpB,GAAI,WAAA,CAAY,GAAA,CAAI,OAAO,CAAA;AAE3B,IAAA,IAAI,GAAA,KAAQ,WAAA,EAAa,OAAO,KAAA,CAAM,GAAA;AAEtC,IAAA,IAAK,GAAA,KAAQ,WAAA,IAAe,GAAA,KAAQ,OAAA,IAAY,MAAM,MAAA,GAAS,CAAA;AAC7D,MAAA,MAAM,IAAI,MAAM,oDAAoD,CAAA;AAEtE,IAAA,OAAO,KAAA,CAAM,MAAA,KAAW,CAAA,GACpB,IAAA,GACA,YAAA,CAAa,GAAA,KAAQ,OAAA,GAAU,KAAA,CAAM,CAAC,CAAA,GAAI,KAAA,CAAM,CAAC,EAAE,IAAI,CAAA;AAAA,EAC7D,CAAA;AAEA,EAAA,MAAM,UAAA,GAAa,CAAC,OAAA,KAA6B;AAC/C,IAAA,MAAM,EAAE,GAAA,EAAI,GAAI,WAAA,CAAY,IAAI,OAAO,CAAA;AAEvC,IAAA,IAAI,GAAA,CAAI,GAAA,KAAQ,WAAA,EAAa,OAAO,EAAE,KAAK,GAAA,CAAI,KAAA,CAAM,GAAA,EAAK,KAAA,EAAO,MAAA,EAAU;AAE3E,IAAA,IAAI,GAAA,CAAI,QAAQ,SAAA,EAAW;AACzB,MAAA,MAAM,SAAA,GAAY,YAAA,CAAa,GAAA,CAAI,KAAK,CAAA;AACxC,MAAA,MAAM,GAAA,GAAM,gBAAgB,SAAiB,CAAA;AAC7C,MAAA,IAAI,CAAC,GAAA,EAAK,MAAM,IAAI,MAAM,+BAA+B,CAAA;AACzD,MAAA,OAAO,EAAE,GAAA,EAAK,KAAA,EAAO,MAAA,EAAU;AAAA,IACjC;AAEA,IAAA,OAAO,gBAAgB,GAAA,CAAI,OAAO,CAAA,GAC9B,EAAE,KAAK,OAAA,EAAS,KAAA,EAAO,eAAA,CAAgB,GAAA,CAAI,OAAO,CAAA,EAAG,GACrD,EAAE,GAAA,EAAK,MAAA,EAAQ,OAAO,MAAA,EAAU;AAAA,EACtC,CAAA;AAEA,EAAA,MAAM,SAAA,GAA+B;AAAA,IACnC,OAAA,EAAS,cAAA;AAAA,IACT,SAAA,EAAW,UAAA,CAAW,QAAA,CAAS,SAAA,CAAU,OAAO,CAAA;AAAA,IAChD,MAAA,EAAQ,UAAA,CAAW,QAAA,CAAS,SAAA,CAAU,IAAI,CAAA;AAAA,IAC1C,WAAA,EAAa,UAAA,CAAW,QAAA,CAAS,SAAA,CAAU,SAAS,CAAA;AAAA,IACpD,kBAAkB,QAAA,CAAS,SAAA,CAAU,gBAAA,CAAiB,GAAA,CAAI,CAAC,EAAA,MAAQ;AAAA,MACjE,YAAY,EAAA,CAAG,UAAA;AAAA,MACf,mBAAA,EAAqB,UAAA,CAAW,EAAA,CAAG,IAAI,CAAA;AAAA,MACvC,oBAAA,EAAsB,UAAA,CAAW,EAAA,CAAG,gBAAgB;AAAA,KACtD,CAAE;AAAA,GACJ;AAEA,EAAA,MAAM,MAAA,GAAS,SAAA;AAAA,IACb,WAAA;AAAA,IACA,eAAA;AAAA,IACA,UAAA;AAAA,IACA;AAAA,GACF;AACA,EAAA,MAAM,aAAA,GAAgB,MAAA,CAAO,GAAA,CAAI,UAAA,CAAW,GAAG,CAAA;AAE/C,EAAA,IAAI,QAAA;AACJ,EAAA,MAAM,cAAc,MAAyB;AAC3C,IAAA,IAAI,UAAU,OAAO,QAAA;AAErB,IAAA,IAAI,CAAC,aAAA,CAAc,MAAA,EAAQ,OAAQ,QAAA,GAAW,CAAC,IAAI,UAAA,CAAW,EAAE,CAAA,CAAE,IAAA,CAAK,CAAC,CAAC,CAAA;AAEzE,IAAA,QAAA,GAAW,IAAI,KAAA,CAAM,aAAA,CAAc,MAAA,GAAS,IAAI,CAAC,CAAA;AAEjD,IAAA,IAAI,cAAA,GAAiB,cAAc,MAAA,GAAS,CAAA;AAC5C,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,aAAA,CAAc,MAAA,EAAQ,CAAA,EAAA;AACxC,MAAA,QAAA,CAAS,iBAAiB,CAAC,CAAA,GAAIC,2BAAA,CAAU,aAAA,CAAc,CAAC,CAAC,CAAA;AAE3D,IAAA,KAAA,IAAS,IAAI,QAAA,CAAS,MAAA,GAAS,CAAA,EAAG,CAAA,GAAI,GAAG,CAAA,IAAK,CAAA;AAC5C,MAAA,QAAA,CAAA,CAAU,CAAA,GAAI,CAAA,IAAK,CAAC,CAAA,GAAIA,2BAAA;AAAA,QACtBC,gBAAA,CAAW,CAAC,QAAA,CAAS,CAAC,GAAG,QAAA,CAAS,CAAA,GAAI,CAAC,CAAC,CAAC;AAAA,OAC3C;AAEF,IAAA,OAAO,QAAA;AAAA,EACT,CAAA;AAEA,EAAA,IAAI,QAAA;AACJ,EAAA,MAAM,SAAS,MAAM;AACnB,IAAA,IAAI,UAAU,OAAO,QAAA;AACrB,IAAA,MAAM,cAAA,GAAiB,WAAA,EAAY,CAAE,CAAC,CAAA;AAEtC,IAAA,MAAMC,OAAAA,GAAyB;AAAA,MAC7B,GAAA,EAAK,IAAA;AAAA,MACL,KAAA,EAAO;AAAA,QACL,uBAAA,EAAyB,cAAA;AAAA,QACzB,qBAAA,EAAuBF,2BAAA,CAAU,iBAAA,CAAkB,GAAA,CAAI,SAAS,CAAC,CAAA;AAAA,QACjE,GAAG;AAAA;AACL,KACF;AAEA,IAAA,OAAQ,QAAA,GAAWA,2BAAA,CAAU,cAAA,CAAe,GAAA,CAAIE,OAAM,CAAC,CAAA;AAAA,EACzD,CAAA;AAEA,EAAA,MAAM,aAAA,GAAgB,CAAC,YAAA,KAA2B;AAChD,IAAA,MAAM,SAAA,GAAY,YAAA,CAAa,aAAA,EAAe,YAAY,CAAA;AAE1D,IAAA,MAAMC,YAAW,WAAA,EAAY;AAC7B,IAAA,MAAM,MAAA,GAAS,UAAU,SAAA,CAAU,GAAA,CAAI,CAAC,GAAA,KAAQA,SAAAA,CAAS,GAAG,CAAC,CAAA;AAE7D,IAAA,OAAOF,gBAAA,CAAW;AAAA,MAChBpB,yBAAA,CAAQ,GAAA,CAAI,SAAA,CAAU,MAAA,CAAO,MAAM,CAAA;AAAA,MACnC,GAAG,SAAA,CAAU,MAAA;AAAA,MACbA,yBAAA,CAAQ,GAAA,CAAI,SAAA,CAAU,QAAA,CAAS,MAAM,CAAA;AAAA,MACrC,GAAG,UAAU,QAAA,CAAS,GAAA,CAAI,CAAC,CAAA,KAAMb,qBAAA,CAAI,GAAA,CAAI,CAAC,CAAC,CAAA;AAAA,MAC3Ca,yBAAA,CAAQ,GAAA,CAAI,MAAA,CAAO,MAAM,CAAA;AAAA,MACzB,GAAG,MAAA;AAAA,MACH,iBAAA,CAAkB,IAAI,SAAS,CAAA;AAAA,MAC/B,SAAA,CAAU,IAAI,IAAI;AAAA,KACnB,CAAA;AAAA,EACH,CAAA;AAEA,EAAA,MAAM,2BAAA,GAA8B,CAClC,gBAAA,KACG;AACH,IAAA,MAAM,QAAA,GAA2B;AAAA,MAC/B,SAAA,CAAU,MAAA;AAAA,MACV,GAAG,SAAA,CAAU,gBAAA,CAAiB,IAAI,CAAC,CAAA,KAAM,EAAE,mBAAmB,CAAA;AAAA,MAC9D,GAAG,SAAA,CAAU,gBAAA,CAAiB,IAAI,CAAC,CAAA,KAAM,EAAE,oBAAoB;AAAA,KACjE;AACA,IAAA,OAAO,aAAA;AAAA,MACL,0BAAA,CAA2B,gBAAA,EAAkB,QAAA,EAAU,MAAM;AAAA,KAC/D;AAAA,EACF,CAAA;AAEA,EAAA,MAAM,yBAAA,GAA4B,CAChC,QAAA,EACA,mBAAA,EACA,oBAAA,KACG;AACH,IAAA,MAAM,KAAA,GAAQoB,gBAAA;AAAA,MACZ,CAAC,QAAA,EAAU,mBAAA,EAAqB,oBAAoB,CAAA,CAAE,IAAI,OAAO;AAAA,KACnE;AACA,IAAA,OAAO,4BAA4B,KAAK,CAAA;AAAA,EAC1C,CAAA;AAEA,EAAA,MAAM,oBAAA,GAAuB,CAC3B,WAAA,EACA,kBAAA,KACG;AACH,IAAA,IAAI,GAAG,EAAE,OAAA,EAAAG,QAAAA,EAAS,MAAK,EAAG,KAAK,CAAA,GAAI,YAAA,CAAa,WAAW,CAAA;AAE3D,IAAA,IAAIA,aAAY,SAAA,CAAU,OAAA;AACxB,MAAA,MAAM,IAAI,MAAM,6BAA6B,CAAA;AAE/C,IAAA,MAAM,QAAA,GACJ,SAAS,QAAA,GACL;AAAA,MACE,SAAA,CAAU,SAAA;AAAA,MACV,SAAA,CAAU,WAAA;AAAA,MACV,GAAG,SAAA,CAAU,gBAAA,CAAiB,IAAI,CAAC,CAAA,KAAM,EAAE,mBAAmB,CAAA;AAAA,MAC9D,SAAA,CAAU;AAAA,KACZ,GACA,CAAC,SAAA,CAAU,MAAM,CAAA;AAEvB,IAAA,IAAI,kBAAA,EAAoB;AACtB,MAAA,KAAA,GAAQH,iBAAW,CAAC,KAAA,EAAO,OAAA,CAAQ,kBAAkB,CAAC,CAAC,CAAA;AACvD,MAAA,QAAA,CAAS,IAAA;AAAA,QACP,GAAG,SAAA,CAAU,gBAAA,CAAiB,IAAI,CAAC,CAAA,KAAM,EAAE,oBAAoB;AAAA,OACjE;AAAA,IACF;AAEA,IAAA,OAAO,aAAA,CAAc,0BAAA,CAA2B,KAAA,EAAO,QAAA,EAAU,MAAM,CAAC,CAAA;AAAA,EAC1E,CAAA;AAEA,EAAA,OAAO;AAAA,IACL,MAAA;AAAA,IACA,oBAAA;AAAA,IACA,yBAAA;AAAA,IACA;AAAA,GACF;AACF;;;;;;;;;;"}