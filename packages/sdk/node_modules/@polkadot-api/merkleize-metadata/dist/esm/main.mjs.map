{"version":3,"file":"main.mjs","sources":["../../src/main.ts"],"sourcesContent":["import {\n  Blake3256,\n  HexString,\n  compact,\n  u32,\n} from \"@polkadot-api/substrate-bindings\"\nimport {\n  ExtraInfo,\n  ExtrinsicMetadata,\n  LookupValue,\n  MetadataDigest,\n  ScalePrimitive,\n  TypeRef,\n  extraInfo,\n  extrinsicMetadata,\n  lookupType,\n  metadataDigest,\n  extrinsicDec,\n} from \"./codecs\"\nimport { getAccessibleTypes } from \"./get-accessible-types\"\nimport { getLookup } from \"./get-lookup\"\nimport { getMetadata } from \"./get-metadata\"\nimport { compactTypeRefs, toBytes } from \"./utils\"\nimport { decodeAndCollectKnownLeafs } from \"./decode-and-collect\"\nimport { getProofData } from \"./proof\"\nimport { getDynamicBuilder, getLookupFn } from \"@polkadot-api/metadata-builders\"\nimport { mergeUint8 } from \"@polkadot-api/utils\"\n\nexport interface MetadataMerkleizer {\n  /**\n   * @returns Digest value of the metadata (aka its merkleized root-hash)\n   */\n  digest: () => Uint8Array\n\n  /**\n   * Get proof for an `Extrinsic`.\n   *\n   * @param transaction         Encoded `Extrinsic`, both signed or unsigned.\n   * @param txAdditionalSigned  Optionally collect types for given\n   *                            `additionalSigned` part of signedExtensions.\n   * @returns Encoded `Proof`\n   */\n  getProofForExtrinsic: (\n    transaction: Uint8Array | HexString,\n    txAdditionalSigned?: Uint8Array | HexString,\n  ) => Uint8Array\n\n  /**\n   * Get proof for `ExtrinsicPayload` parts.\n   *\n   * @param callData              Call data of the transaction. It has to be\n   *                              bare; i.e.\n   *                              without prepended compact length.\n   * @param includedInExtrinsic   Extra part of the signed extensions, all of\n   *                              them concatenated.\n   * @param includedInSignedData  Additional signed part of the signed\n   *                              extensions, all of them concatenated.\n   * @returns Encoded `Proof`\n   */\n  getProofForExtrinsicParts: (\n    callData: Uint8Array | HexString,\n    includedInExtrinsic: Uint8Array | HexString,\n    includedInSignedData: Uint8Array | HexString,\n  ) => Uint8Array\n\n  /**\n   * Get proof for `ExtrinsicPayload`.\n   *\n   * @param extrinsicPayload  Call data, extra part of signedExtensions and\n   *                          additional signed part of signedExtensions\n   *                          concatenated. It has to be bare; i.e. without\n   *                          prepended compact length.\n   * @returns Encoded `Proof`\n   */\n  getProofForExtrinsicPayload: (\n    extrinsicPayload: Uint8Array | HexString,\n  ) => Uint8Array\n}\n\nconst assertExpected = <T>(name: string, expected: T, received?: T): void => {\n  if (received != null && received !== expected)\n    throw new Error(\n      `${name} not expected. Received ${received} expected ${expected}`,\n    )\n}\n\nexport const merkleizeMetadata = (\n  metadataBytes: Uint8Array | HexString,\n  {\n    decimals,\n    tokenSymbol,\n    ...hinted\n  }: { decimals: number; tokenSymbol: string } & Partial<ExtraInfo>,\n): MetadataMerkleizer => {\n  const metadata = getMetadata(metadataBytes)\n\n  const checkedVersion = metadata.extrinsic.version.includes(4) ? 4 : null\n  if (checkedVersion == null) throw new Error(\"Only extrinsic v4 is supported\")\n\n  const { ss58Prefix, buildDefinition } = getDynamicBuilder(\n    getLookupFn(metadata),\n  )\n  if (ss58Prefix == null) throw new Error(\"SS58 prefix not found in metadata\")\n  assertExpected(\"SS58 prefix\", ss58Prefix, hinted.base58Prefix)\n  const version = metadata.pallets\n    .find((x) => x.name === \"System\")\n    ?.constants.find((x) => x.name === \"Version\")\n  if (version == null) throw new Error(\"System.Version constant not found\")\n  const { spec_name: specName, spec_version: specVersion } = buildDefinition(\n    version.type,\n  ).dec(version.value)\n  if (typeof specName !== \"string\" || typeof specVersion !== \"number\")\n    throw new Error(\"Spec name or spec version not found\")\n  assertExpected(\"Spec name\", specName, hinted.specName)\n  assertExpected(\"Spec version\", specVersion, hinted.specVersion)\n\n  const info: ExtraInfo = {\n    decimals,\n    tokenSymbol,\n    specVersion,\n    specName,\n    base58Prefix: ss58Prefix,\n  }\n  const definitions = new Map<number, LookupValue>(\n    metadata.lookup.map((value) => [value.id, value]),\n  )\n  const accessibleTypes = getAccessibleTypes(metadata, definitions)\n  const getPrimitive = (frameId: number): ScalePrimitive[\"tag\"] | null => {\n    const {\n      def: { tag, value },\n    } = definitions.get(frameId)!\n\n    if (tag === \"primitive\") return value.tag\n\n    if ((tag !== \"composite\" && tag !== \"tuple\") || value.length > 1)\n      throw new Error(\"The provided definition doesn't map to a primitive\")\n\n    return value.length === 0\n      ? null // signals `void`\n      : getPrimitive(tag === \"tuple\" ? value[0] : value[0].type)\n  }\n\n  const getTypeRef = (frameId: number): TypeRef => {\n    const { def } = definitions.get(frameId)!\n\n    if (def.tag === \"primitive\") return { tag: def.value.tag, value: undefined }\n\n    if (def.tag === \"compact\") {\n      const primitive = getPrimitive(def.value)\n      const tag = compactTypeRefs[primitive as \"u8\"]\n      if (!tag) throw new Error(\"Invalid primitive for Compact\")\n      return { tag, value: undefined }\n    }\n\n    return accessibleTypes.has(frameId)\n      ? { tag: \"perId\", value: accessibleTypes.get(frameId)! }\n      : { tag: \"void\", value: undefined }\n  }\n\n  const extrinsic: ExtrinsicMetadata = {\n    version: checkedVersion,\n    addressTy: getTypeRef(metadata.extrinsic.address),\n    callTy: getTypeRef(metadata.extrinsic.call),\n    signatureTy: getTypeRef(metadata.extrinsic.signature),\n    signedExtensions: metadata.extrinsic.signedExtensions.map((se) => ({\n      identifier: se.identifier,\n      includedInExtrinsic: getTypeRef(se.type),\n      includedInSignedData: getTypeRef(se.additionalSigned),\n    })),\n  }\n\n  const lookup = getLookup(\n    definitions,\n    accessibleTypes,\n    getTypeRef,\n    getPrimitive,\n  )\n  const lookupEncoded = lookup.map(lookupType.enc)\n\n  let hashTree: Array<Uint8Array> | undefined\n  const getHashTree = (): Array<Uint8Array> => {\n    if (hashTree) return hashTree\n\n    if (!lookupEncoded.length) return (hashTree = [new Uint8Array(32).fill(0)])\n\n    hashTree = new Array(lookupEncoded.length * 2 - 1)\n\n    let leavesStartIdx = lookupEncoded.length - 1\n    for (let i = 0; i < lookupEncoded.length; i++)\n      hashTree[leavesStartIdx + i] = Blake3256(lookupEncoded[i])\n\n    for (let i = hashTree.length - 2; i > 0; i -= 2)\n      hashTree[(i - 1) / 2] = Blake3256(\n        mergeUint8([hashTree[i], hashTree[i + 1]]),\n      )\n\n    return hashTree\n  }\n\n  let digested: undefined | Uint8Array\n  const digest = () => {\n    if (digested) return digested\n    const rootLookupHash = getHashTree()[0]\n\n    const digest: MetadataDigest = {\n      tag: \"V1\",\n      value: {\n        typeInformationTreeRoot: rootLookupHash,\n        extrinsicMetadataHash: Blake3256(extrinsicMetadata.enc(extrinsic)),\n        ...info,\n      },\n    }\n\n    return (digested = Blake3256(metadataDigest.enc(digest)))\n  }\n\n  const generateProof = (knownIndexes: number[]) => {\n    const proofData = getProofData(lookupEncoded, knownIndexes)\n\n    const hashTree = getHashTree()\n    const proofs = proofData.proofIdxs.map((idx) => hashTree[idx])\n\n    return mergeUint8([\n      compact.enc(proofData.leaves.length),\n      ...proofData.leaves,\n      compact.enc(proofData.leafIdxs.length),\n      ...proofData.leafIdxs.map((x) => u32.enc(x)),\n      compact.enc(proofs.length),\n      ...proofs,\n      extrinsicMetadata.enc(extrinsic),\n      extraInfo.enc(info),\n    ])\n  }\n\n  const getProofForExtrinsicPayload = (\n    extrinsicPayload: Uint8Array | HexString,\n  ) => {\n    const typeRefs: Array<TypeRef> = [\n      extrinsic.callTy,\n      ...extrinsic.signedExtensions.map((x) => x.includedInExtrinsic),\n      ...extrinsic.signedExtensions.map((x) => x.includedInSignedData),\n    ]\n    return generateProof(\n      decodeAndCollectKnownLeafs(extrinsicPayload, typeRefs, lookup),\n    )\n  }\n\n  const getProofForExtrinsicParts = (\n    callData: Uint8Array | HexString,\n    includedInExtrinsic: Uint8Array | HexString,\n    includedInSignedData: Uint8Array | HexString,\n  ) => {\n    const bytes = mergeUint8(\n      [callData, includedInExtrinsic, includedInSignedData].map(toBytes),\n    )\n    return getProofForExtrinsicPayload(bytes)\n  }\n\n  const getProofForExtrinsic = (\n    transaction: Uint8Array | HexString,\n    txAdditionalSigned?: Uint8Array | HexString,\n  ) => {\n    let [, { version, type }, bytes] = extrinsicDec(transaction)\n\n    if (version !== extrinsic.version)\n      throw new Error(\"Incorrect extrinsic version\")\n\n    const typeRefs: TypeRef[] =\n      type === \"signed\"\n        ? [\n            extrinsic.addressTy,\n            extrinsic.signatureTy,\n            ...extrinsic.signedExtensions.map((x) => x.includedInExtrinsic),\n            extrinsic.callTy,\n          ]\n        : [extrinsic.callTy]\n\n    if (txAdditionalSigned) {\n      bytes = mergeUint8([bytes, toBytes(txAdditionalSigned)])\n      typeRefs.push(\n        ...extrinsic.signedExtensions.map((x) => x.includedInSignedData),\n      )\n    }\n\n    return generateProof(decodeAndCollectKnownLeafs(bytes, typeRefs, lookup))\n  }\n\n  return {\n    digest,\n    getProofForExtrinsic,\n    getProofForExtrinsicParts,\n    getProofForExtrinsicPayload,\n  }\n}\n"],"names":["digest","hashTree","version"],"mappings":"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"}